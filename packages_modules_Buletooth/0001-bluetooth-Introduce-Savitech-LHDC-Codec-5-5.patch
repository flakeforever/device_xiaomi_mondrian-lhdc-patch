From 64cedacab2a0976e516d6fadb05d1e9caefc2492 Mon Sep 17 00:00:00 2001
From: jimmy chen <jimmy.chen@savitech.co>
Date: Fri, 7 Mar 2025 01:03:13 +0800
Subject: [PATCH] bluetooth: Introduce Savitech LHDC Codec [5/5]

Import Savitech LHDC Codec from https://gitlab.com/savitech-lhdc/
---
 android/app/res/values/config.xml             |    3 +
 .../bluetooth/a2dp/A2dpCodecConfig.java       |   47 +-
 .../bluetooth/a2dp/A2dpStateMachine.java      |   12 +
 apex/Android.bp                               |   28 +-
 framework/api/current.txt                     |    2 +
 framework/api/lint-baseline.txt               |    5 +
 framework/api/module-lib-lint-baseline.txt    |    6 +
 framework/api/system-lint-baseline.txt        |    5 +
 .../bluetooth/BluetoothCodecConfig.java       |   44 +-
 .../android/bluetooth/BluetoothCodecType.java |   16 +
 .../aidl/a2dp_encoding_aidl.cc                |    6 +
 .../aidl/codec_status_aidl.cc                 |    1 +
 system/btif/co/bta_av_co.cc                   |   19 +-
 system/btif/src/btif_a2dp_source.cc           |   19 +-
 system/include/hardware/bt_av.h               |   17 +-
 system/internal_include/bt_target.h           |    3 +-
 system/stack/Android.bp                       |    9 +
 system/stack/a2dp/a2dp_codec_config.cc        |   23 +-
 system/stack/a2dp/a2dp_vendor.cc              |  234 +-
 system/stack/a2dp/a2dp_vendor_lhdcv3.cc       | 2483 +++++++++++++
 system/stack/a2dp/a2dp_vendor_lhdcv3_dec.cc   | 2087 +++++++++++
 .../stack/a2dp/a2dp_vendor_lhdcv3_decoder.cc  |  554 +++
 .../stack/a2dp/a2dp_vendor_lhdcv3_encoder.cc  | 1054 ++++++
 system/stack/a2dp/a2dp_vendor_lhdcv5.cc       | 3149 +++++++++++++++++
 .../stack/a2dp/a2dp_vendor_lhdcv5_decoder.cc  |  617 ++++
 .../stack/a2dp/a2dp_vendor_lhdcv5_encoder.cc  | 1309 +++++++
 system/stack/include/a2dp_constants.h         |    2 +
 .../include/a2dp_vendor_lhdc_constants.h      |  308 ++
 system/stack/include/a2dp_vendor_lhdcv3.h     |  324 ++
 system/stack/include/a2dp_vendor_lhdcv3_dec.h |  192 +
 .../include/a2dp_vendor_lhdcv3_decoder.h      |   59 +
 .../include/a2dp_vendor_lhdcv3_encoder.h      |   77 +
 system/stack/include/a2dp_vendor_lhdcv5.h     |  291 ++
 .../include/a2dp_vendor_lhdcv5_constants.h    |  258 ++
 .../include/a2dp_vendor_lhdcv5_decoder.h      |   58 +
 .../include/a2dp_vendor_lhdcv5_encoder.h      |   66 +
 36 files changed, 13373 insertions(+), 14 deletions(-)
 create mode 100755 system/stack/a2dp/a2dp_vendor_lhdcv3.cc
 create mode 100755 system/stack/a2dp/a2dp_vendor_lhdcv3_dec.cc
 create mode 100755 system/stack/a2dp/a2dp_vendor_lhdcv3_decoder.cc
 create mode 100755 system/stack/a2dp/a2dp_vendor_lhdcv3_encoder.cc
 create mode 100755 system/stack/a2dp/a2dp_vendor_lhdcv5.cc
 create mode 100755 system/stack/a2dp/a2dp_vendor_lhdcv5_decoder.cc
 create mode 100755 system/stack/a2dp/a2dp_vendor_lhdcv5_encoder.cc
 create mode 100755 system/stack/include/a2dp_vendor_lhdc_constants.h
 create mode 100755 system/stack/include/a2dp_vendor_lhdcv3.h
 create mode 100755 system/stack/include/a2dp_vendor_lhdcv3_dec.h
 create mode 100755 system/stack/include/a2dp_vendor_lhdcv3_decoder.h
 create mode 100755 system/stack/include/a2dp_vendor_lhdcv3_encoder.h
 create mode 100755 system/stack/include/a2dp_vendor_lhdcv5.h
 create mode 100755 system/stack/include/a2dp_vendor_lhdcv5_constants.h
 create mode 100755 system/stack/include/a2dp_vendor_lhdcv5_decoder.h
 create mode 100755 system/stack/include/a2dp_vendor_lhdcv5_encoder.h

diff --git a/android/app/res/values/config.xml b/android/app/res/values/config.xml
index 7418000e8e..5e7bdfba35 100644
--- a/android/app/res/values/config.xml
+++ b/android/app/res/values/config.xml
@@ -137,6 +137,9 @@
     <integer name="a2dp_source_codec_priority_ldac">5001</integer>
     <integer name="a2dp_source_codec_priority_lc3">6001</integer>
     <integer name="a2dp_source_codec_priority_opus">7001</integer>
+    <integer name="a2dp_source_codec_priority_lhdcv2">8001</integer>
+    <integer name="a2dp_source_codec_priority_lhdcv3">8002</integer>
+    <integer name="a2dp_source_codec_priority_lhdcv5">8003</integer>
 
     <!-- For enabling the AVRCP Target Cover Artowrk feature-->
     <bool name="avrcp_target_enable_cover_art">true</bool>
diff --git a/android/app/src/com/android/bluetooth/a2dp/A2dpCodecConfig.java b/android/app/src/com/android/bluetooth/a2dp/A2dpCodecConfig.java
index 39efb93496..865d35793c 100644
--- a/android/app/src/com/android/bluetooth/a2dp/A2dpCodecConfig.java
+++ b/android/app/src/com/android/bluetooth/a2dp/A2dpCodecConfig.java
@@ -54,7 +54,12 @@ class A2dpCodecConfig {
             BluetoothCodecConfig.CODEC_PRIORITY_DEFAULT;
     private @CodecPriority int mA2dpSourceCodecPriorityOpus =
             BluetoothCodecConfig.CODEC_PRIORITY_DEFAULT;
-
+    // Savitech LHDC - Start
+    private @CodecPriority int mA2dpSourceCodecPriorityLhdcV3 =
+            BluetoothCodecConfig.CODEC_PRIORITY_DEFAULT;
+    private @CodecPriority int mA2dpSourceCodecPriorityLhdcV5 =
+            BluetoothCodecConfig.CODEC_PRIORITY_DEFAULT;
+    // Savitech LHDC - End
     private BluetoothCodecConfig[] mCodecConfigOffloading = new BluetoothCodecConfig[0];
 
     A2dpCodecConfig(Context context, A2dpNativeInterface a2dpNativeInterface) {
@@ -262,9 +267,34 @@ class A2dpCodecConfig {
                 && (value < BluetoothCodecConfig.CODEC_PRIORITY_HIGHEST)) {
             mA2dpSourceCodecPriorityOpus = value;
         }
+        // Savitech LHDC -- START
+        try {
+            value = SystemProperties.getInt(
+                "bluetooth.a2dp.source.lhdcv3_priority.config",
+                resources.getInteger(R.integer.a2dp_source_codec_priority_lhdcv3));
+        } catch (NotFoundException e) {
+            value = BluetoothCodecConfig.CODEC_PRIORITY_DEFAULT;
+        }
+        if ((value >= BluetoothCodecConfig.CODEC_PRIORITY_DISABLED) && (value
+                < BluetoothCodecConfig.CODEC_PRIORITY_HIGHEST)) {
+            mA2dpSourceCodecPriorityLhdcV3 = value;
+        }
+
+        try {
+            value = SystemProperties.getInt(
+                "bluetooth.a2dp.source.lhdcv5_priority.config",
+                resources.getInteger(R.integer.a2dp_source_codec_priority_lhdcv5));
+        } catch (NotFoundException e) {
+            value = BluetoothCodecConfig.CODEC_PRIORITY_DEFAULT;
+        }
+        if ((value >= BluetoothCodecConfig.CODEC_PRIORITY_DISABLED) && (value
+                < BluetoothCodecConfig.CODEC_PRIORITY_HIGHEST)) {
+            mA2dpSourceCodecPriorityLhdcV5 = value;
+        }
+        // Savitech LHDC -- END
 
         BluetoothCodecConfig codecConfig;
-        BluetoothCodecConfig[] codecConfigArray = new BluetoothCodecConfig[6];
+        BluetoothCodecConfig[] codecConfigArray = new BluetoothCodecConfig[8];  // Savitech LHDC patch
         codecConfig =
                 new BluetoothCodecConfig.Builder()
                         .setCodecType(BluetoothCodecConfig.SOURCE_CODEC_TYPE_SBC)
@@ -301,7 +331,18 @@ class A2dpCodecConfig {
                         .setCodecPriority(mA2dpSourceCodecPriorityOpus)
                         .build();
         codecConfigArray[5] = codecConfig;
-
+        // Savitech LHDC -- START
+        codecConfig = new BluetoothCodecConfig.Builder()
+                .setCodecType(BluetoothCodecConfig.SOURCE_CODEC_TYPE_LHDCV3)
+                .setCodecPriority(mA2dpSourceCodecPriorityLhdcV3)
+                .build();
+        codecConfigArray[6] = codecConfig;
+        codecConfig = new BluetoothCodecConfig.Builder()
+                .setCodecType(BluetoothCodecConfig.SOURCE_CODEC_TYPE_LHDCV5)
+                .setCodecPriority(mA2dpSourceCodecPriorityLhdcV5)
+                .build();
+        codecConfigArray[7] = codecConfig;
+        // Savitech LHDC -- END
         return codecConfigArray;
     }
 
diff --git a/android/app/src/com/android/bluetooth/a2dp/A2dpStateMachine.java b/android/app/src/com/android/bluetooth/a2dp/A2dpStateMachine.java
index b53ee4c505..bdc5cdb965 100644
--- a/android/app/src/com/android/bluetooth/a2dp/A2dpStateMachine.java
+++ b/android/app/src/com/android/bluetooth/a2dp/A2dpStateMachine.java
@@ -768,6 +768,18 @@ final class A2dpStateMachine extends StateMachine {
                     && (prevCodecConfig.getCodecSpecific1()
                             != newCodecConfig.getCodecSpecific1())) {
                 update = true;
+            } else if ((newCodecConfig.getCodecType()
+                            == BluetoothCodecConfig.SOURCE_CODEC_TYPE_LHDCV3)
+                    && (prevCodecConfig != null)
+                    && (prevCodecConfig.getCodecSpecific1()
+                            != newCodecConfig.getCodecSpecific1())) {
+                update = true;
+            } else if ((newCodecConfig.getCodecType()
+                            == BluetoothCodecConfig.SOURCE_CODEC_TYPE_LHDCV5)
+                    && (prevCodecConfig != null)
+                    && (prevCodecConfig.getCodecSpecific1()
+                            != newCodecConfig.getCodecSpecific1())) {
+                update = true;
             } else if ((newCodecConfig.getCodecType()
                             == BluetoothCodecConfig.SOURCE_CODEC_TYPE_OPUS)
                     && (prevCodecConfig != null)
diff --git a/apex/Android.bp b/apex/Android.bp
index 52b9631fb4..a6775ca92d 100644
--- a/apex/Android.bp
+++ b/apex/Android.bp
@@ -13,10 +13,36 @@ linker_config {
     installable: false,
 }
 
+// savitech LHDC
+soong_config_module_type {
+    name: "lhdc_apex_defaults",
+    module_type: "apex_defaults",
+    config_namespace: "btservices",
+    bool_variables: ["use_lhdc"],
+    properties: [
+        "native_shared_libs",
+    ],
+}
+
+lhdc_apex_defaults {
+    name: "com.android.btservices.lhdc_defaults",
+    soong_config_variables: {
+        use_lhdc: {
+            native_shared_libs: [
+                "liblhdcBT_enc",
+                "liblhdcv5BT_enc",
+            ],
+        },
+    }
+}
+
 // Mainline bluetooth apex module.
 apex {
     name: "com.android.btservices",
-    defaults: ["t-launched-apex-module"],
+    defaults: [
+        "t-launched-apex-module",
+        "com.android.btservices.lhdc_defaults",
+    ],
     manifest: "apex_manifest.json",
     bootclasspath_fragments: ["com.android.btservices-bootclasspath-fragment"],
     systemserverclasspath_fragments: ["com.android.btservices-systemserverclasspath-fragment"],
diff --git a/framework/api/current.txt b/framework/api/current.txt
index 29d8ef989d..61853a3970 100644
--- a/framework/api/current.txt
+++ b/framework/api/current.txt
@@ -459,6 +459,8 @@ package android.bluetooth {
     field @Deprecated public static final int SOURCE_CODEC_TYPE_INVALID = 1000000; // 0xf4240
     field @Deprecated public static final int SOURCE_CODEC_TYPE_LC3 = 5; // 0x5
     field @Deprecated public static final int SOURCE_CODEC_TYPE_LDAC = 4; // 0x4
+    field @Deprecated public static final int SOURCE_CODEC_TYPE_LHDCV3 = 7; // 0x7
+    field @Deprecated public static final int SOURCE_CODEC_TYPE_LHDCV5 = 8; // 0x8
     field @Deprecated public static final int SOURCE_CODEC_TYPE_OPUS = 6; // 0x6
     field @Deprecated public static final int SOURCE_CODEC_TYPE_SBC = 0; // 0x0
   }
diff --git a/framework/api/lint-baseline.txt b/framework/api/lint-baseline.txt
index 5e5e511354..0b00260904 100644
--- a/framework/api/lint-baseline.txt
+++ b/framework/api/lint-baseline.txt
@@ -29,3 +29,8 @@ BroadcastBehavior: android.bluetooth.BluetoothDevice#ACTION_PAIRING_REQUEST:
     Field 'ACTION_PAIRING_REQUEST' is missing @BroadcastBehavior
 BroadcastBehavior: android.bluetooth.BluetoothDevice#ACTION_UUID:
     Field 'ACTION_UUID' is missing @BroadcastBehavior
+
+DeprecationMismatch: android.bluetooth.BluetoothCodecConfig#SOURCE_CODEC_TYPE_LHDCV3:
+    Field BluetoothCodecConfig.SOURCE_CODEC_TYPE_LHDCV3: @Deprecated annotation (present) and @deprecated doc tag (not present) do not match
+DeprecationMismatch: android.bluetooth.BluetoothCodecConfig#SOURCE_CODEC_TYPE_LHDCV5:
+    Field BluetoothCodecConfig.SOURCE_CODEC_TYPE_LHDCV5: @Deprecated annotation (present) and @deprecated doc tag (not present) do not match
diff --git a/framework/api/module-lib-lint-baseline.txt b/framework/api/module-lib-lint-baseline.txt
index d8f82447aa..b842a496ff 100644
--- a/framework/api/module-lib-lint-baseline.txt
+++ b/framework/api/module-lib-lint-baseline.txt
@@ -45,6 +45,12 @@ BroadcastBehavior: android.bluetooth.BluetoothDevice#ACTION_UUID:
     Field 'ACTION_UUID' is missing @BroadcastBehavior
 
 
+DeprecationMismatch: android.bluetooth.BluetoothCodecConfig#SOURCE_CODEC_TYPE_LHDCV3:
+    Field BluetoothCodecConfig.SOURCE_CODEC_TYPE_LHDCV3: @Deprecated annotation (present) and @deprecated doc tag (not present) do not match
+DeprecationMismatch: android.bluetooth.BluetoothCodecConfig#SOURCE_CODEC_TYPE_LHDCV5:
+    Field BluetoothCodecConfig.SOURCE_CODEC_TYPE_LHDCV5: @Deprecated annotation (present) and @deprecated doc tag (not present) do not match
+
+
 RequiresPermission: android.bluetooth.BluetoothA2dp#setCodecConfigPreference(android.bluetooth.BluetoothDevice, android.bluetooth.BluetoothCodecConfig):
     Method 'setCodecConfigPreference' documentation mentions permissions already declared by @RequiresPermission
 RequiresPermission: android.bluetooth.BluetoothAdapter#getAddress():
diff --git a/framework/api/system-lint-baseline.txt b/framework/api/system-lint-baseline.txt
index 0fe01325a8..224f16f520 100644
--- a/framework/api/system-lint-baseline.txt
+++ b/framework/api/system-lint-baseline.txt
@@ -43,3 +43,8 @@ BroadcastBehavior: android.bluetooth.BluetoothDevice#ACTION_SWITCH_BUFFER_SIZE:
     Field 'ACTION_SWITCH_BUFFER_SIZE' is missing @BroadcastBehavior
 BroadcastBehavior: android.bluetooth.BluetoothDevice#ACTION_UUID:
     Field 'ACTION_UUID' is missing @BroadcastBehavior
+
+DeprecationMismatch: android.bluetooth.BluetoothCodecConfig#SOURCE_CODEC_TYPE_LHDCV3:
+    Field BluetoothCodecConfig.SOURCE_CODEC_TYPE_LHDCV3: @Deprecated annotation (present) and @deprecated doc tag (not present) do not match
+DeprecationMismatch: android.bluetooth.BluetoothCodecConfig#SOURCE_CODEC_TYPE_LHDCV5:
+    Field BluetoothCodecConfig.SOURCE_CODEC_TYPE_LHDCV5: @Deprecated annotation (present) and @deprecated doc tag (not present) do not match
diff --git a/framework/java/android/bluetooth/BluetoothCodecConfig.java b/framework/java/android/bluetooth/BluetoothCodecConfig.java
index 8e9ed78ef1..8e7d7c3162 100644
--- a/framework/java/android/bluetooth/BluetoothCodecConfig.java
+++ b/framework/java/android/bluetooth/BluetoothCodecConfig.java
@@ -52,6 +52,9 @@ public final class BluetoothCodecConfig implements Parcelable {
                 SOURCE_CODEC_TYPE_LDAC,
                 SOURCE_CODEC_TYPE_LC3,
                 SOURCE_CODEC_TYPE_OPUS,
+                SOURCE_CODEC_TYPE_LHDCV3,
+                SOURCE_CODEC_TYPE_LHDCV5,
+                SOURCE_CODEC_TYPE_MAX,
                 SOURCE_CODEC_TYPE_INVALID
             })
     @Retention(RetentionPolicy.SOURCE)
@@ -113,6 +116,18 @@ public final class BluetoothCodecConfig implements Parcelable {
      */
     @Deprecated public static final int SOURCE_CODEC_TYPE_OPUS = 6;
 
+    // Savitech LHDC -- START
+    /**
+     * Source codec type LHDCV3(V4).
+     */
+    @Deprecated public static final int SOURCE_CODEC_TYPE_LHDCV3 = 7;
+
+    /**
+     * Source codec type LHDCV5.
+     */
+    @Deprecated public static final int SOURCE_CODEC_TYPE_LHDCV5 = 8;
+    // Savitech LHDC -- END
+
     /**
      * Source codec type invalid. This is the default value used for codec type.
      *
@@ -122,7 +137,7 @@ public final class BluetoothCodecConfig implements Parcelable {
     @Deprecated public static final int SOURCE_CODEC_TYPE_INVALID = 1000 * 1000;
 
     /** Represents the count of valid source codec types. */
-    static final int SOURCE_CODEC_TYPE_MAX = 7;
+    static final int SOURCE_CODEC_TYPE_MAX = 9;
 
     /** @hide */
     @IntDef(
@@ -528,6 +543,12 @@ public final class BluetoothCodecConfig implements Parcelable {
                 return "LC3";
             case SOURCE_CODEC_TYPE_OPUS:
                 return "Opus";
+            // Savitech LHDC -- START
+            case SOURCE_CODEC_TYPE_LHDCV3:
+                return "LHDC V3";
+            case SOURCE_CODEC_TYPE_LHDCV5:
+                return "LHDC V5";
+            // Savitech LHDC -- END
             case SOURCE_CODEC_TYPE_INVALID:
                 return "INVALID CODEC";
             default:
@@ -750,7 +771,12 @@ public final class BluetoothCodecConfig implements Parcelable {
         return (other != null
                 && other.mSampleRate == mSampleRate
                 && other.mBitsPerSample == mBitsPerSample
-                && other.mChannelMode == mChannelMode);
+                && other.mChannelMode == mChannelMode
+                && other.mCodecSpecific1 == mCodecSpecific1
+                && other.mCodecSpecific2 == mCodecSpecific2
+                && other.mCodecSpecific3 == mCodecSpecific3
+                && other.mCodecSpecific3 == mCodecSpecific4);
+                // Savitech LHDC -- END
     }
 
     /**
@@ -795,6 +821,8 @@ public final class BluetoothCodecConfig implements Parcelable {
      *
      * <p>Currently, only AAC VBR and LDAC Playback Quality on CodecSpecific1 are compared.
      *
+     * <p> For LHDC, Playback Quality on CodecSpecific1;
+     * Low Latency Mode at CodecSpecific2; Other audio features at CodecSpecific3.
      * @param other the codec config to compare against
      * @return {@code true} if the codec specific parameters are the same, {@code false} otherwise
      * @hide
@@ -811,7 +839,17 @@ public final class BluetoothCodecConfig implements Parcelable {
                 if (mCodecSpecific1 != other.mCodecSpecific1) {
                     return false;
                 }
-                // fall through
+                return true;
+            case SOURCE_CODEC_TYPE_LHDCV3:
+            case SOURCE_CODEC_TYPE_LHDCV5:
+                if (mCodecSpecific1 != other.mCodecSpecific1 ||
+                    mCodecSpecific2 != other.mCodecSpecific2 ||
+                    mCodecSpecific3 != other.mCodecSpecific3 ||
+                    mCodecSpecific4 != other.mCodecSpecific4) {
+                        return false;
+                }
+                return true;
+            // Savitech LHDC -- END
             default:
                 return true;
         }
diff --git a/framework/java/android/bluetooth/BluetoothCodecType.java b/framework/java/android/bluetooth/BluetoothCodecType.java
index bcac9c5c41..2da73ed81a 100644
--- a/framework/java/android/bluetooth/BluetoothCodecType.java
+++ b/framework/java/android/bluetooth/BluetoothCodecType.java
@@ -59,6 +59,20 @@ public final class BluetoothCodecType implements Parcelable {
     /** LDAC codec identifier. See {@link BluetoothCodecType#getCodecId}. */
     public static final long CODEC_ID_LDAC = 0x00aa012dff;
 
+    /**
+     * LHDCV3 codec identifier
+     *
+     * @hide
+     */
+    public static final long CODEC_ID_LHDCV3 = 0x334c3a05fL;
+
+    /**
+     * LHDCV5 codec identifier
+     *
+     * @hide
+     */
+    public static final long CODEC_ID_LHDCV5 = 0x354c3a05ffL;
+
     /** Opus codec identifier. See {@link BluetoothCodecType#getCodecId}. */
     public static final long CODEC_ID_OPUS = 0x000100e0ff;
 
@@ -186,6 +200,8 @@ public final class BluetoothCodecType implements Parcelable {
                     case BluetoothCodecConfig.SOURCE_CODEC_TYPE_APTX -> CODEC_ID_APTX;
                     case BluetoothCodecConfig.SOURCE_CODEC_TYPE_APTX_HD -> CODEC_ID_APTX_HD;
                     case BluetoothCodecConfig.SOURCE_CODEC_TYPE_LDAC -> CODEC_ID_LDAC;
+                    case BluetoothCodecConfig.SOURCE_CODEC_TYPE_LHDCV3 -> CODEC_ID_LHDCV3;
+                    case BluetoothCodecConfig.SOURCE_CODEC_TYPE_LHDCV5 -> CODEC_ID_LHDCV5;
                     case BluetoothCodecConfig.SOURCE_CODEC_TYPE_OPUS -> CODEC_ID_OPUS;
                     case BluetoothCodecConfig.SOURCE_CODEC_TYPE_LC3,
                                     BluetoothCodecConfig.SOURCE_CODEC_TYPE_INVALID ->
diff --git a/system/audio_hal_interface/aidl/a2dp_encoding_aidl.cc b/system/audio_hal_interface/aidl/a2dp_encoding_aidl.cc
index 6e715c4a75..b52ddcd00a 100644
--- a/system/audio_hal_interface/aidl/a2dp_encoding_aidl.cc
+++ b/system/audio_hal_interface/aidl/a2dp_encoding_aidl.cc
@@ -294,6 +294,12 @@ bool a2dp_get_selected_hal_codec_config(A2dpCodecConfig* a2dp_config, uint16_t p
       }
       break;
     }
+    case BTAV_A2DP_CODEC_INDEX_SOURCE_LHDCV3: {
+      return true;
+    }
+    case BTAV_A2DP_CODEC_INDEX_SOURCE_LHDCV5: {
+      return true;
+    }
     case BTAV_A2DP_CODEC_INDEX_MAX:
       [[fallthrough]];
     default:
diff --git a/system/audio_hal_interface/aidl/codec_status_aidl.cc b/system/audio_hal_interface/aidl/codec_status_aidl.cc
index 9f5fc95dab..d65535427c 100644
--- a/system/audio_hal_interface/aidl/codec_status_aidl.cc
+++ b/system/audio_hal_interface/aidl/codec_status_aidl.cc
@@ -28,6 +28,7 @@
 #include "a2dp_vendor_aptx_constants.h"
 #include "a2dp_vendor_aptx_hd_constants.h"
 #include "a2dp_vendor_ldac_constants.h"
+#include "a2dp_vendor_lhdc_constants.h"
 #include "bta/av/bta_av_int.h"
 #include "client_interface_aidl.h"
 
diff --git a/system/btif/co/bta_av_co.cc b/system/btif/co/bta_av_co.cc
index 75f42cb1d3..f5f94170ff 100644
--- a/system/btif/co/bta_av_co.cc
+++ b/system/btif/co/bta_av_co.cc
@@ -249,7 +249,12 @@ tA2DP_STATUS BtaAvCo::ProcessSourceGetConfig(tBTA_AV_HNDL bta_av_handle,
   // Select the Source codec
   const BtaAvCoSep* p_sink = nullptr;
   if (p_peer->acceptor) {
-    UpdateAllSelectableSourceCodecs(p_peer);
+
+    // Savitech Patch - START
+    //UpdateAllSelectableSourceCodecs(p_peer);
+    size_t updated_codecs = UpdateAllSelectableSourceCodecs(p_peer);
+    // Savitech Patch - END
+
     if (p_peer->p_sink == nullptr) {
       // Update the selected codec
       p_peer->p_sink = peer_cache_->FindPeerSink(
@@ -260,6 +265,14 @@ tA2DP_STATUS BtaAvCo::ProcessSourceGetConfig(tBTA_AV_HNDL bta_av_handle,
       log::error("cannot find the selected codec for peer {}", p_peer->addr);
       return A2DP_FAIL;
     }
+    // Savitech Patch - START
+    //    NOTE: Dispatch the event to make sure a callback with the most recent UPDATED
+    //    codec info is generated.
+    if (updated_codecs > 0) {
+      log::info(": onCodecConfigChanged(updated_codecs:{})",  updated_codecs);
+      ReportSourceCodecState(p_peer);
+    }
+    // Savitech Patch - END
   } else {
     if (btif_av_peer_prefers_mandatory_codec(p_peer->addr, A2dpType::kSource)) {
       // Apply user preferred codec directly before first codec selected.
@@ -1418,7 +1431,9 @@ static bool bta_av_co_should_select_hardware_codec(
   // Prioritize LDAC, AptX HD and AptX over AAC and SBC offload codecs
   if (software_codec_index == BTAV_A2DP_CODEC_INDEX_SOURCE_LDAC ||
       software_codec_index == BTAV_A2DP_CODEC_INDEX_SOURCE_APTX_HD ||
-      software_codec_index == BTAV_A2DP_CODEC_INDEX_SOURCE_APTX) {
+      software_codec_index == BTAV_A2DP_CODEC_INDEX_SOURCE_APTX ||
+      software_codec_index == BTAV_A2DP_CODEC_INDEX_SOURCE_LHDCV3 ||
+      software_codec_index == BTAV_A2DP_CODEC_INDEX_SOURCE_LHDCV5) {
     log::verbose("select software codec: {}", A2DP_CodecIndexStr(software_codec_index));
     return false;
   }
diff --git a/system/btif/src/btif_a2dp_source.cc b/system/btif/src/btif_a2dp_source.cc
index f67527da8b..9ee80f49bb 100644
--- a/system/btif/src/btif_a2dp_source.cc
+++ b/system/btif/src/btif_a2dp_source.cc
@@ -874,7 +874,24 @@ static void btif_a2dp_source_audio_handle_timer(void) {
 }
 
 static uint32_t btif_a2dp_source_read_callback(uint8_t* p_buf, uint32_t len) {
-  uint32_t bytes_read = bluetooth::audio::a2dp::read(p_buf, len);
+  uint32_t bytes_read = 0;
+  uint32_t bytes_offset = 0;
+  uint32_t len_read = len;
+  uint32_t timeout_cnt = 0;
+
+  while (true) {
+    bytes_read = bluetooth::audio::a2dp::read(p_buf, len);
+
+    // Savitech LHDC -- Low Latency Mode
+    bytes_offset += bytes_read;
+    len_read -= bytes_read;
+    timeout_cnt++;
+    if (len_read <= 0 || timeout_cnt >= 5) {
+        bytes_read = bytes_offset;
+        break;
+    }
+    usleep(1000);
+  }
 
   if (btif_a2dp_source_cb.sw_audio_is_encoding && bytes_read < len) {
     log::warn("UNDERFLOW: ONLY READ {} BYTES OUT OF {}", bytes_read, len);
diff --git a/system/include/hardware/bt_av.h b/system/include/hardware/bt_av.h
index befbfb4530..fb1ddeeb52 100644
--- a/system/include/hardware/bt_av.h
+++ b/system/include/hardware/bt_av.h
@@ -59,6 +59,8 @@ typedef enum {
   BTAV_A2DP_CODEC_INDEX_SOURCE_LDAC,
   BTAV_A2DP_CODEC_INDEX_SOURCE_LC3,
   BTAV_A2DP_CODEC_INDEX_SOURCE_OPUS,
+  BTAV_A2DP_CODEC_INDEX_SOURCE_LHDCV3,
+  BTAV_A2DP_CODEC_INDEX_SOURCE_LHDCV5,
 
   BTAV_A2DP_CODEC_INDEX_SOURCE_MAX,
 
@@ -75,7 +77,8 @@ typedef enum {
   BTAV_A2DP_CODEC_INDEX_SINK_AAC,
   BTAV_A2DP_CODEC_INDEX_SINK_LDAC,
   BTAV_A2DP_CODEC_INDEX_SINK_OPUS,
-
+  BTAV_A2DP_CODEC_INDEX_SINK_LHDCV3,
+  BTAV_A2DP_CODEC_INDEX_SINK_LHDCV5,
   BTAV_A2DP_CODEC_INDEX_SINK_MAX,
 
   // Range of codec indexes reserved for Offload codec extensibility.
@@ -178,12 +181,24 @@ struct btav_a2dp_codec_config_t {
         return "aptX HD";
       case BTAV_A2DP_CODEC_INDEX_SOURCE_LDAC:
         return "LDAC";
+      // Savitech Patch - START
+      case BTAV_A2DP_CODEC_INDEX_SOURCE_LHDCV3:
+        return "LHDC V3";
+      case BTAV_A2DP_CODEC_INDEX_SOURCE_LHDCV5:
+        return "LHDC V5";
+      // Savitech Patch - END
       case BTAV_A2DP_CODEC_INDEX_SINK_SBC:
         return "SBC (Sink)";
       case BTAV_A2DP_CODEC_INDEX_SINK_AAC:
         return "AAC (Sink)";
       case BTAV_A2DP_CODEC_INDEX_SINK_LDAC:
         return "LDAC (Sink)";
+      // Savitech Patch - START
+      case BTAV_A2DP_CODEC_INDEX_SINK_LHDCV3:
+        return "LHDC V3 (Sink)";
+      case BTAV_A2DP_CODEC_INDEX_SINK_LHDCV5:
+        return "LHDC V5 (Sink)";
+      // Savitech Patch - END
       case BTAV_A2DP_CODEC_INDEX_SOURCE_LC3:
         return "LC3";
       case BTAV_A2DP_CODEC_INDEX_SINK_OPUS:
diff --git a/system/internal_include/bt_target.h b/system/internal_include/bt_target.h
index 24e1cb32e0..0fa2133ccd 100644
--- a/system/internal_include/bt_target.h
+++ b/system/internal_include/bt_target.h
@@ -520,7 +520,8 @@
 
 /* Number of simultaneous stream endpoints. */
 #ifndef AVDT_NUM_SEPS
-#define AVDT_NUM_SEPS 12
+//#define AVDT_NUM_SEPS 12
+#define AVDT_NUM_SEPS 16    //Savitech LHDC
 #endif
 
 /* Number of transport channels setup by AVDT for all media streams */
diff --git a/system/stack/Android.bp b/system/stack/Android.bp
index 817c94ee16..6b91c5d707 100644
--- a/system/stack/Android.bp
+++ b/system/stack/Android.bp
@@ -66,6 +66,8 @@ cc_library_static {
         "external/libldac/abr/inc",
         "external/libldac/inc",
         "external/libopus/include",
+        "external/liblhdc/inc",
+        "external/liblhdc/include",
         "packages/modules/Bluetooth/system",
         "packages/modules/Bluetooth/system/bta/include",
         "packages/modules/Bluetooth/system/bta/sys",
@@ -100,6 +102,13 @@ cc_library_static {
         "a2dp/a2dp_vendor_opus.cc",
         "a2dp/a2dp_vendor_opus_decoder.cc",
         "a2dp/a2dp_vendor_opus_encoder.cc",
+        "a2dp/a2dp_vendor_lhdcv3.cc",
+        "a2dp/a2dp_vendor_lhdcv3_encoder.cc",
+        "a2dp/a2dp_vendor_lhdcv3_dec.cc",
+        "a2dp/a2dp_vendor_lhdcv3_decoder.cc",
+        "a2dp/a2dp_vendor_lhdcv5.cc",
+        "a2dp/a2dp_vendor_lhdcv5_encoder.cc",
+        "a2dp/a2dp_vendor_lhdcv5_decoder.cc",
         "avct/avct_api.cc",
         "avct/avct_bcb_act.cc",
         "avct/avct_ccb.cc",
diff --git a/system/stack/a2dp/a2dp_codec_config.cc b/system/stack/a2dp/a2dp_codec_config.cc
index 2a59138d7e..42554f2ce6 100644
--- a/system/stack/a2dp/a2dp_codec_config.cc
+++ b/system/stack/a2dp/a2dp_codec_config.cc
@@ -33,6 +33,9 @@
 #include "a2dp_vendor_aptx_hd.h"
 #include "a2dp_vendor_ldac.h"
 #include "a2dp_vendor_opus.h"
+#include "a2dp_vendor_lhdcv3.h"
+#include "a2dp_vendor_lhdcv3_dec.h"
+#include "a2dp_vendor_lhdcv5.h"
 #endif
 
 #include "audio_hal_interface/a2dp_encoding.h"
@@ -147,6 +150,20 @@ A2dpCodecConfig* A2dpCodecConfig::createCodec(btav_a2dp_codec_index_t codec_inde
     case BTAV_A2DP_CODEC_INDEX_SINK_OPUS:
       codec_config = new A2dpCodecConfigOpusSink(codec_priority);
       break;
+    // Savitech LHDC - START
+    case BTAV_A2DP_CODEC_INDEX_SOURCE_LHDCV3:
+      codec_config = new A2dpCodecConfigLhdcV3(codec_priority);
+      break;
+    case BTAV_A2DP_CODEC_INDEX_SOURCE_LHDCV5:
+      codec_config = new A2dpCodecConfigLhdcV5Source(codec_priority);
+      break;
+    case BTAV_A2DP_CODEC_INDEX_SINK_LHDCV3:
+      codec_config = new A2dpCodecConfigLhdcV3Sink(codec_priority);
+      break;
+    case BTAV_A2DP_CODEC_INDEX_SINK_LHDCV5:
+      codec_config = new A2dpCodecConfigLhdcV5Sink(codec_priority);
+      break;
+    // Savitech LHDC - END
 #endif
     case BTAV_A2DP_CODEC_INDEX_MAX:
     default:
@@ -365,7 +382,11 @@ tA2DP_STATUS A2dpCodecConfig::setCodecUserConfig(
   btav_a2dp_codec_config_t new_codec_config = getCodecConfig();
   if ((saved_codec_config.sample_rate != new_codec_config.sample_rate) ||
       (saved_codec_config.bits_per_sample != new_codec_config.bits_per_sample) ||
-      (saved_codec_config.channel_mode != new_codec_config.channel_mode)) {
+      (saved_codec_config.channel_mode != new_codec_config.channel_mode) ||
+      (saved_codec_config.codec_specific_1 != new_codec_config.codec_specific_1) || // Savitech LHDC
+      (saved_codec_config.codec_specific_2 != new_codec_config.codec_specific_2) ||
+      (saved_codec_config.codec_specific_3 != new_codec_config.codec_specific_3) ||
+      (saved_codec_config.codec_specific_4 != new_codec_config.codec_specific_4)) {
     *p_restart_input = true;
   }
 
diff --git a/system/stack/a2dp/a2dp_vendor.cc b/system/stack/a2dp/a2dp_vendor.cc
index 84979bbff0..f0360d1e44 100644
--- a/system/stack/a2dp/a2dp_vendor.cc
+++ b/system/stack/a2dp/a2dp_vendor.cc
@@ -22,13 +22,21 @@
 
 #include "a2dp_vendor.h"
 
+#include <bluetooth/log.h>
+#include <string.h>
+
 #include "a2dp_vendor_aptx.h"
 #include "a2dp_vendor_aptx_hd.h"
 #include "a2dp_vendor_ldac.h"
 #include "a2dp_vendor_opus.h"
+#include "a2dp_vendor_lhdcv3.h"
+#include "a2dp_vendor_lhdcv3_dec.h"
+#include "a2dp_vendor_lhdcv5.h"
 #include "internal_include/bt_trace.h"
 #include "stack/include/bt_hdr.h"
 
+using namespace bluetooth;
+
 bool A2DP_IsVendorSourceCodecValid(const uint8_t* p_codec_info) {
   uint32_t vendor_id = A2DP_VendorCodecGetVendorId(p_codec_info);
   uint16_t codec_id = A2DP_VendorCodecGetCodecId(p_codec_info);
@@ -55,6 +63,16 @@ bool A2DP_IsVendorSourceCodecValid(const uint8_t* p_codec_info) {
     return A2DP_IsCodecValidOpus(p_codec_info);
   }
 
+  // Check for Savitech LHDCV3
+  if (vendor_id == A2DP_LHDC_VENDOR_ID && codec_id == A2DP_LHDCV3_CODEC_ID) {
+    return A2DP_IsVendorSourceCodecValidLhdcV3(p_codec_info);
+  }
+
+  // Check for Savitech LHDCV5
+  if (vendor_id == A2DP_LHDC_VENDOR_ID && codec_id == A2DP_LHDCV5_CODEC_ID) {
+    return A2DP_IsVendorSourceCodecValidLhdcV5(p_codec_info);
+  }
+
   // Add checks based on <vendor_id, codec_id>
 
   return false;
@@ -77,6 +95,15 @@ bool A2DP_IsVendorPeerSourceCodecValid(const uint8_t* p_codec_info) {
     return A2DP_IsCodecValidOpus(p_codec_info);
   }
 
+  // Check for Savitech LHDCV3 Sink
+  if (vendor_id == A2DP_LHDC_VENDOR_ID && codec_id == A2DP_LHDCV3_CODEC_ID) {
+    return A2DP_IsVendorPeerSourceCodecValidLhdcV3(p_codec_info);
+  }
+  // Check for Savitech LHDCV5 Sink
+  if (vendor_id == A2DP_LHDC_VENDOR_ID && codec_id == A2DP_LHDCV5_CODEC_ID) {
+    return A2DP_IsVendorPeerSourceCodecValidLhdcV5(p_codec_info);
+  }
+
   return false;
 }
 
@@ -106,6 +133,16 @@ bool A2DP_IsVendorPeerSinkCodecValid(const uint8_t* p_codec_info) {
     return A2DP_IsCodecValidOpus(p_codec_info);
   }
 
+  // Check for Savitech LHDCV3
+  if (vendor_id == A2DP_LHDC_VENDOR_ID && codec_id == A2DP_LHDCV3_CODEC_ID) {
+    return A2DP_IsVendorPeerSinkCodecValidLhdcV3(p_codec_info);
+  }
+
+  // Check for Savitech LHDCV5
+  if (vendor_id == A2DP_LHDC_VENDOR_ID && codec_id == A2DP_LHDCV5_CODEC_ID) {
+    return A2DP_IsVendorPeerSinkCodecValidLhdcV5(p_codec_info);
+  }
+
   // Add checks based on <vendor_id, codec_id>
 
   return false;
@@ -128,6 +165,16 @@ tA2DP_STATUS A2DP_IsVendorSinkCodecSupported(const uint8_t* p_codec_info) {
     return A2DP_IsVendorSinkCodecSupportedOpus(p_codec_info);
   }
 
+  // Check for Savitech LHDCV3 Sink
+  else if (vendor_id == A2DP_LHDC_VENDOR_ID && codec_id == A2DP_LHDCV3_CODEC_ID) {
+    return A2DP_IsVendorSinkCodecSupportedLhdcV3(p_codec_info);
+  }
+
+  // Check for Savitech LHDCV5 Sink
+  else if (vendor_id == A2DP_LHDC_VENDOR_ID && codec_id == A2DP_LHDCV5_CODEC_ID) {
+    return A2DP_IsVendorSinkCodecSupportedLhdcV5(p_codec_info);
+  }
+
   return A2DP_NOT_SUPPORTED_CODEC_TYPE;
 }
 
@@ -172,6 +219,17 @@ bool A2DP_VendorUsesRtpHeader(bool content_protection_enabled, const uint8_t* p_
     return A2DP_VendorUsesRtpHeaderOpus(content_protection_enabled, p_codec_info);
   }
 
+  // Check for Savitech LHDCV3
+  if (vendor_id == A2DP_LHDC_VENDOR_ID && codec_id == A2DP_LHDCV3_CODEC_ID) {
+    return A2DP_VendorUsesRtpHeaderLhdcV3(content_protection_enabled,
+                                          p_codec_info);
+  }
+
+  // Check for Savitech LHDCV5
+  if (vendor_id == A2DP_LHDC_VENDOR_ID && codec_id == A2DP_LHDCV5_CODEC_ID) {
+    return A2DP_VendorUsesRtpHeaderLhdcV5(content_protection_enabled,
+                                          p_codec_info);
+  }
   // Add checks based on <content_protection_enabled, vendor_id, codec_id>
 
   return true;
@@ -201,6 +259,16 @@ const char* A2DP_VendorCodecName(const uint8_t* p_codec_info) {
     return A2DP_VendorCodecNameOpus(p_codec_info);
   }
 
+  // Check for Savitech LHDCV3
+  if (vendor_id == A2DP_LHDC_VENDOR_ID && codec_id == A2DP_LHDCV3_CODEC_ID) {
+    return A2DP_VendorCodecNameLhdcV3(p_codec_info);
+  }
+
+  // Check for Savitech LHDCV5
+  if (vendor_id == A2DP_LHDC_VENDOR_ID && codec_id == A2DP_LHDCV5_CODEC_ID) {
+    return A2DP_VendorCodecNameLhdcV5(p_codec_info);
+  }
+
   // Add checks based on <vendor_id, codec_id>
 
   return "UNKNOWN VENDOR CODEC";
@@ -243,6 +311,14 @@ bool A2DP_VendorCodecTypeEquals(const uint8_t* p_codec_info_a, const uint8_t* p_
     return A2DP_VendorCodecTypeEqualsOpus(p_codec_info_a, p_codec_info_b);
   }
 
+  // Check for Savitech LHDCV3
+  if (vendor_id_a == A2DP_LHDC_VENDOR_ID && codec_id_a == A2DP_LHDCV3_CODEC_ID) {
+    return A2DP_VendorCodecTypeEqualsLhdcV3(p_codec_info_a, p_codec_info_b);
+  }
+  // Check for Savitech LHDCV5
+  if (vendor_id_a == A2DP_LHDC_VENDOR_ID && codec_id_a == A2DP_LHDCV5_CODEC_ID) {
+    return A2DP_VendorCodecTypeEqualsLhdcV5(p_codec_info_a, p_codec_info_b);
+  }
   // OPTIONAL: Add extra vendor-specific checks based on the
   // vendor-specific data stored in "p_codec_info_a" and "p_codec_info_b".
 
@@ -286,6 +362,15 @@ bool A2DP_VendorCodecEquals(const uint8_t* p_codec_info_a, const uint8_t* p_code
     return A2DP_VendorCodecEqualsOpus(p_codec_info_a, p_codec_info_b);
   }
 
+  // Check for Savitech LHDCV3
+  if (vendor_id_a == A2DP_LHDC_VENDOR_ID && codec_id_a == A2DP_LHDCV3_CODEC_ID) {
+    return A2DP_VendorCodecEqualsLhdcV3(p_codec_info_a, p_codec_info_b);
+  }
+
+  // Check for Savitech LHDCV5
+  if (vendor_id_a == A2DP_LHDC_VENDOR_ID && codec_id_a == A2DP_LHDCV5_CODEC_ID) {
+    return A2DP_VendorCodecEqualsLhdcV5(p_codec_info_a, p_codec_info_b);
+  }
   // Add extra vendor-specific checks based on the
   // vendor-specific data stored in "p_codec_info_a" and "p_codec_info_b".
 
@@ -316,6 +401,16 @@ int A2DP_VendorGetBitRate(const uint8_t* p_codec_info) {
     return A2DP_VendorGetBitRateOpus(p_codec_info);
   }
 
+  // Check for Savitech LHDCV3
+  if (vendor_id == A2DP_LHDC_VENDOR_ID && codec_id == A2DP_LHDCV3_CODEC_ID) {
+    return A2DP_VendorGetBitRateLhdcV3(p_codec_info);
+  }
+
+  // Check for Savitech LHDCV5
+  if (vendor_id == A2DP_LHDC_VENDOR_ID && codec_id == A2DP_LHDCV5_CODEC_ID) {
+    return A2DP_VendorGetBitRateLhdcV5(p_codec_info);
+  }
+
   // Add checks based on <vendor_id, codec_id>
 
   return -1;
@@ -345,6 +440,15 @@ int A2DP_VendorGetTrackSampleRate(const uint8_t* p_codec_info) {
     return A2DP_VendorGetTrackSampleRateOpus(p_codec_info);
   }
 
+  // Check for Savitech LHDCV3
+  if (vendor_id == A2DP_LHDC_VENDOR_ID && codec_id == A2DP_LHDCV3_CODEC_ID) {
+    return A2DP_VendorGetTrackSampleRateLhdcV3(p_codec_info);
+  }
+
+  // Check for Savitech LHDCV5
+  if (vendor_id == A2DP_LHDC_VENDOR_ID && codec_id == A2DP_LHDCV5_CODEC_ID) {
+    return A2DP_VendorGetTrackSampleRateLhdcV5(p_codec_info);
+  }
   // Add checks based on <vendor_id, codec_id>
 
   return -1;
@@ -374,6 +478,15 @@ int A2DP_VendorGetTrackBitsPerSample(const uint8_t* p_codec_info) {
     return A2DP_VendorGetTrackBitsPerSampleOpus(p_codec_info);
   }
 
+  // Check for Savitech LHDCV3
+  if (vendor_id == A2DP_LHDC_VENDOR_ID && codec_id == A2DP_LHDCV3_CODEC_ID) {
+    return A2DP_VendorGetTrackBitsPerSampleLhdcV3(p_codec_info);
+  }
+
+  // Check for Savitech LHDCV5
+  if (vendor_id == A2DP_LHDC_VENDOR_ID && codec_id == A2DP_LHDCV5_CODEC_ID) {
+    return A2DP_VendorGetTrackBitsPerSampleLhdcV5(p_codec_info);
+  }
   // Add checks based on <vendor_id, codec_id>
 
   return -1;
@@ -403,6 +516,15 @@ int A2DP_VendorGetTrackChannelCount(const uint8_t* p_codec_info) {
     return A2DP_VendorGetTrackChannelCountOpus(p_codec_info);
   }
 
+  // Check for Savitech LHDCV3
+  if (vendor_id == A2DP_LHDC_VENDOR_ID && codec_id == A2DP_LHDCV3_CODEC_ID) {
+    return A2DP_VendorGetTrackChannelCountLhdcV3(p_codec_info);
+  }
+
+  // Check for Savitech LHDCV5
+  if (vendor_id == A2DP_LHDC_VENDOR_ID && codec_id == A2DP_LHDCV5_CODEC_ID) {
+    return A2DP_VendorGetTrackChannelCountLhdcV5(p_codec_info);
+  }
   // Add checks based on <vendor_id, codec_id>
 
   return -1;
@@ -425,6 +547,15 @@ int A2DP_VendorGetSinkTrackChannelType(const uint8_t* p_codec_info) {
     return A2DP_VendorGetSinkTrackChannelTypeOpus(p_codec_info);
   }
 
+  // Check for Savitech LHDC V3
+  if (vendor_id == A2DP_LHDC_VENDOR_ID && codec_id == A2DP_LHDCV3_CODEC_ID) {
+    return A2DP_VendorGetSinkTrackChannelTypeLhdcV3(p_codec_info);
+  }
+
+  // Check for Savitech LHDC V5
+  if (vendor_id == A2DP_LHDC_VENDOR_ID && codec_id == A2DP_LHDCV5_CODEC_ID) {
+    return A2DP_VendorGetSinkTrackChannelTypeLhdcV5(p_codec_info);
+  }
   return -1;
 }
 
@@ -453,6 +584,16 @@ bool A2DP_VendorGetPacketTimestamp(const uint8_t* p_codec_info, const uint8_t* p
     return A2DP_VendorGetPacketTimestampOpus(p_codec_info, p_data, p_timestamp);
   }
 
+  // Check for Savitech LHDCV3
+  if (vendor_id == A2DP_LHDC_VENDOR_ID && codec_id == A2DP_LHDCV3_CODEC_ID) {
+    return A2DP_VendorGetPacketTimestampLhdcV3(p_codec_info, p_data, p_timestamp);
+  }
+
+  // Check for Savitech LHDCV5
+  if (vendor_id == A2DP_LHDC_VENDOR_ID && codec_id == A2DP_LHDCV5_CODEC_ID) {
+    return A2DP_VendorGetPacketTimestampLhdcV5(p_codec_info, p_data, p_timestamp);
+  }
+
   // Add checks based on <vendor_id, codec_id>
 
   return false;
@@ -483,6 +624,17 @@ bool A2DP_VendorBuildCodecHeader(const uint8_t* p_codec_info, BT_HDR* p_buf,
     return A2DP_VendorBuildCodecHeaderOpus(p_codec_info, p_buf, frames_per_packet);
   }
 
+  // Check for Savitech LHDCV3
+  if (vendor_id == A2DP_LHDC_VENDOR_ID && codec_id == A2DP_LHDCV3_CODEC_ID) {
+    return A2DP_VendorBuildCodecHeaderLhdcV3(p_codec_info, p_buf,
+                                               frames_per_packet);
+  }
+
+  // Check for Savitech LHDCV5
+  if (vendor_id == A2DP_LHDC_VENDOR_ID && codec_id == A2DP_LHDCV5_CODEC_ID) {
+    return A2DP_VendorBuildCodecHeaderLhdcV5(p_codec_info, p_buf,
+                                               frames_per_packet);
+  }
   // Add checks based on <vendor_id, codec_id>
 
   return false;
@@ -512,6 +664,15 @@ const tA2DP_ENCODER_INTERFACE* A2DP_VendorGetEncoderInterface(const uint8_t* p_c
     return A2DP_VendorGetEncoderInterfaceOpus(p_codec_info);
   }
 
+  // Check for Savitech LHDCV3
+  if (vendor_id == A2DP_LHDC_VENDOR_ID && codec_id == A2DP_LHDCV3_CODEC_ID) {
+    return A2DP_VendorGetEncoderInterfaceLhdcV3(p_codec_info);
+  }
+
+  // Check for Savitech LHDCV5
+  if (vendor_id == A2DP_LHDC_VENDOR_ID && codec_id == A2DP_LHDCV5_CODEC_ID) {
+    return A2DP_VendorGetEncoderInterfaceLhdcV5(p_codec_info);
+  }
   // Add checks based on <vendor_id, codec_id>
 
   return NULL;
@@ -534,6 +695,15 @@ const tA2DP_DECODER_INTERFACE* A2DP_VendorGetDecoderInterface(const uint8_t* p_c
     return A2DP_VendorGetDecoderInterfaceOpus(p_codec_info);
   }
 
+  // Check for Savitech LHDCV3 Sink
+  if (vendor_id == A2DP_LHDC_VENDOR_ID && codec_id == A2DP_LHDCV3_CODEC_ID) {
+    return A2DP_VendorGetDecoderInterfaceLhdcV3(p_codec_info);
+  }
+
+  // Check for Savitech LHDCV5 Sink
+  if (vendor_id == A2DP_LHDC_VENDOR_ID && codec_id == A2DP_LHDCV5_CODEC_ID) {
+    return A2DP_VendorGetDecoderInterfaceLhdcV5(p_codec_info);
+  }
   return NULL;
 }
 
@@ -561,6 +731,16 @@ bool A2DP_VendorAdjustCodec(uint8_t* p_codec_info) {
     return A2DP_VendorAdjustCodecOpus(p_codec_info);
   }
 
+  // Check for Savitech LHDCV3
+  if (vendor_id == A2DP_LHDC_VENDOR_ID && codec_id == A2DP_LHDCV3_CODEC_ID) {
+    return A2DP_VendorAdjustCodecLhdcV3(p_codec_info);
+  }
+
+  // Check for Savitech LHDCV5
+  if (vendor_id == A2DP_LHDC_VENDOR_ID && codec_id == A2DP_LHDCV5_CODEC_ID) {
+    return A2DP_VendorAdjustCodecLhdcV5(p_codec_info);
+  }
+
   // Add checks based on <vendor_id, codec_id>
 
   return false;
@@ -570,6 +750,8 @@ btav_a2dp_codec_index_t A2DP_VendorSourceCodecIndex(const uint8_t* p_codec_info)
   uint32_t vendor_id = A2DP_VendorCodecGetVendorId(p_codec_info);
   uint16_t codec_id = A2DP_VendorCodecGetCodecId(p_codec_info);
 
+  log::error("vendor_id 0x{:x} codec_id 0x{:x}", vendor_id, codec_id);
+
   // Check for aptX
   if (vendor_id == A2DP_APTX_VENDOR_ID && codec_id == A2DP_APTX_CODEC_ID_BLUETOOTH) {
     return A2DP_VendorSourceCodecIndexAptx(p_codec_info);
@@ -590,6 +772,16 @@ btav_a2dp_codec_index_t A2DP_VendorSourceCodecIndex(const uint8_t* p_codec_info)
     return A2DP_VendorSourceCodecIndexOpus(p_codec_info);
   }
 
+  // Check for Savitech LHDCV3
+  if (vendor_id == A2DP_LHDC_VENDOR_ID && codec_id == A2DP_LHDCV3_CODEC_ID) {
+    return A2DP_VendorSourceCodecIndexLhdcV3(p_codec_info);
+  }
+
+  // Check for Savitech LHDCV5
+  if (vendor_id == A2DP_LHDC_VENDOR_ID && codec_id == A2DP_LHDCV5_CODEC_ID) {
+    return A2DP_VendorSourceCodecIndexLhdcV5(p_codec_info);
+  }
+
   // Add checks based on <vendor_id, codec_id>
 
   return BTAV_A2DP_CODEC_INDEX_MAX;
@@ -612,6 +804,16 @@ btav_a2dp_codec_index_t A2DP_VendorSinkCodecIndex(const uint8_t* p_codec_info) {
     return A2DP_VendorSinkCodecIndexOpus(p_codec_info);
   }
 
+  // Check for Savitech LHDC V3
+  if (vendor_id == A2DP_LHDC_VENDOR_ID && codec_id == A2DP_LHDCV3_CODEC_ID) {
+    return A2DP_VendorSinkCodecIndexLhdcV3(p_codec_info);
+  }
+
+  // Check for Savitech LHDC V5
+  if (vendor_id == A2DP_LHDC_VENDOR_ID && codec_id == A2DP_LHDCV5_CODEC_ID) {
+    return A2DP_VendorSinkCodecIndexLhdcV5(p_codec_info);
+  }
+
   return BTAV_A2DP_CODEC_INDEX_MAX;
 }
 
@@ -637,6 +839,16 @@ const char* A2DP_VendorCodecIndexStr(btav_a2dp_codec_index_t codec_index) {
       return A2DP_VendorCodecIndexStrOpus();
     case BTAV_A2DP_CODEC_INDEX_SINK_OPUS:
       return A2DP_VendorCodecIndexStrOpusSink();
+    // Savitech Patch - START
+    case BTAV_A2DP_CODEC_INDEX_SOURCE_LHDCV3:
+      return A2DP_VendorCodecIndexStrLhdcV3();
+    case BTAV_A2DP_CODEC_INDEX_SOURCE_LHDCV5:
+      return A2DP_VendorCodecIndexStrLhdcV5();
+    case BTAV_A2DP_CODEC_INDEX_SINK_LHDCV3:
+      return A2DP_VendorCodecIndexStrLhdcV3Sink();
+    case BTAV_A2DP_CODEC_INDEX_SINK_LHDCV5:
+      return A2DP_VendorCodecIndexStrLhdcV5Sink();
+    // Savitech Patch - END
     // Add a switch statement for each vendor-specific codec
     case BTAV_A2DP_CODEC_INDEX_MAX:
       break;
@@ -670,6 +882,16 @@ bool A2DP_VendorInitCodecConfig(btav_a2dp_codec_index_t codec_index, AvdtpSepCon
       return A2DP_VendorInitCodecConfigOpus(p_cfg);
     case BTAV_A2DP_CODEC_INDEX_SINK_OPUS:
       return A2DP_VendorInitCodecConfigOpusSink(p_cfg);
+    // Savitech Patch - START
+    case BTAV_A2DP_CODEC_INDEX_SOURCE_LHDCV3:
+      return A2DP_VendorInitCodecConfigLhdcV3(p_cfg);
+    case BTAV_A2DP_CODEC_INDEX_SOURCE_LHDCV5:
+      return A2DP_VendorInitCodecConfigLhdcV5(p_cfg);
+    case BTAV_A2DP_CODEC_INDEX_SINK_LHDCV3:
+      return A2DP_VendorInitCodecConfigLhdcV3Sink(p_cfg);
+    case BTAV_A2DP_CODEC_INDEX_SINK_LHDCV5:
+      return A2DP_VendorInitCodecConfigLhdcV5Sink(p_cfg);
+    // Savitech Patch - END
     // Add a switch statement for each vendor-specific codec
     case BTAV_A2DP_CODEC_INDEX_MAX:
       break;
@@ -677,7 +899,7 @@ bool A2DP_VendorInitCodecConfig(btav_a2dp_codec_index_t codec_index, AvdtpSepCon
     case BTAV_A2DP_CODEC_INDEX_SINK_EXT_MIN:
       break;
   }
-
+  
   return false;
 }
 
@@ -705,6 +927,16 @@ std::string A2DP_VendorCodecInfoString(const uint8_t* p_codec_info) {
     return A2DP_VendorCodecInfoStringOpus(p_codec_info);
   }
 
+  // Check for Savitech LHDCV3
+  if (vendor_id == A2DP_LHDC_VENDOR_ID && codec_id == A2DP_LHDCV3_CODEC_ID) {
+    return A2DP_VendorCodecInfoStringLhdcV3(p_codec_info);
+  }
+
+  // Check for Savitech LHDCV5
+  if (vendor_id == A2DP_LHDC_VENDOR_ID && codec_id == A2DP_LHDCV5_CODEC_ID) {
+    return A2DP_VendorCodecInfoStringLhdcV5(p_codec_info);
+  }
+
   // Add checks based on <vendor_id, codec_id>
 
   return "Unsupported codec vendor_id: " + loghex(vendor_id) + " codec_id: " + loghex(codec_id);
diff --git a/system/stack/a2dp/a2dp_vendor_lhdcv3.cc b/system/stack/a2dp/a2dp_vendor_lhdcv3.cc
new file mode 100755
index 0000000000..4db93a4c4a
--- /dev/null
+++ b/system/stack/a2dp/a2dp_vendor_lhdcv3.cc
@@ -0,0 +1,2483 @@
+/*
+ * Copyright (C) 2016 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+/******************************************************************************
+ *
+ *  Utility functions to help build and parse the LHDC Codec Information
+ *  Element and Media Payload.
+ *
+ ******************************************************************************/
+
+#define LOG_TAG "bluetooth-a2dp"
+#include "bt_target.h"
+
+#include "a2dp_vendor_lhdcv3.h"
+
+#include "a2dp_vendor_lhdcv3_dec.h"
+
+#include <string.h>
+
+#include <base/logging.h>
+#include "a2dp_vendor.h"
+#include "a2dp_vendor_lhdcv3_encoder.h"
+#include "btif/include/btif_av_co.h"
+#include "internal_include/bt_trace.h"
+#include "stack/include/bt_hdr.h"
+#include "osi/include/osi.h"
+#include <bluetooth/log.h>
+#include "os/log.h"
+using namespace bluetooth;
+
+typedef struct {
+  btav_a2dp_codec_config_t *_codec_config_;
+  btav_a2dp_codec_config_t *_codec_capability_;
+  btav_a2dp_codec_config_t *_codec_local_capability_;
+  btav_a2dp_codec_config_t *_codec_selectable_capability_;
+  btav_a2dp_codec_config_t *_codec_user_config_;
+  btav_a2dp_codec_config_t *_codec_audio_config_;
+}tA2DP_CODEC_CONFIGS_PACK;
+
+typedef struct {
+  uint8_t   featureCode;    /* code definition for LHDC API ex: LHDC_EXTEND_FUNC_A2DP_LHDC_JAS_CODE */
+  uint8_t   inSpecBank;     /* in which specific bank */
+  uint8_t   bitPos;         /* at which bit index number of the specific bank */
+}tA2DP_LHDC_FEATURE_POS;
+
+/* source side metadata of JAS feature */
+static const tA2DP_LHDC_FEATURE_POS a2dp_lhdc_source_caps_JAS = {
+  LHDC_EXTEND_FUNC_A2DP_LHDC_JAS_CODE,
+  LHDC_EXTEND_FUNC_A2DP_SPECIFIC3_INDEX,
+  A2DP_LHDC_JAS_SPEC_BIT_POS,
+};
+/* source side metadata of AR feature */
+static const tA2DP_LHDC_FEATURE_POS a2dp_lhdc_source_caps_AR = {
+  LHDC_EXTEND_FUNC_A2DP_LHDC_AR_CODE,
+  LHDC_EXTEND_FUNC_A2DP_SPECIFIC3_INDEX,
+  A2DP_LHDC_AR_SPEC_BIT_POS
+};
+/* source side metadata of LLAC feature */
+static const tA2DP_LHDC_FEATURE_POS a2dp_lhdc_source_caps_LLAC = {
+  LHDC_EXTEND_FUNC_A2DP_LHDC_LLAC_CODE,
+  LHDC_EXTEND_FUNC_A2DP_SPECIFIC3_INDEX,
+  A2DP_LHDC_LLAC_SPEC_BIT_POS
+};
+/* source side metadata of META feature */
+static const tA2DP_LHDC_FEATURE_POS a2dp_lhdc_source_caps_META = {
+  LHDC_EXTEND_FUNC_A2DP_LHDC_META_CODE,
+  LHDC_EXTEND_FUNC_A2DP_SPECIFIC3_INDEX,
+  A2DP_LHDC_META_SPEC_BIT_POS
+};
+/* source side metadata of MBR feature */
+static const tA2DP_LHDC_FEATURE_POS a2dp_lhdc_source_caps_MBR = {
+  LHDC_EXTEND_FUNC_A2DP_LHDC_MBR_CODE,
+  LHDC_EXTEND_FUNC_A2DP_SPECIFIC3_INDEX,
+  A2DP_LHDC_MBR_SPEC_BIT_POS
+};
+/* source side metadata of LARC feature */
+static const tA2DP_LHDC_FEATURE_POS a2dp_lhdc_source_caps_LARC = {
+  LHDC_EXTEND_FUNC_A2DP_LHDC_LARC_CODE,
+  LHDC_EXTEND_FUNC_A2DP_SPECIFIC3_INDEX,
+  A2DP_LHDC_LARC_SPEC_BIT_POS
+};
+/* source side metadata of LHDCV4 feature */
+static const tA2DP_LHDC_FEATURE_POS a2dp_lhdc_source_caps_LHDCV4 = {
+  LHDC_EXTEND_FUNC_A2DP_LHDC_V4_CODE,
+  LHDC_EXTEND_FUNC_A2DP_SPECIFIC3_INDEX,
+  A2DP_LHDC_V4_SPEC_BIT_POS
+};
+
+static const tA2DP_LHDC_FEATURE_POS a2dp_lhdc_source_caps_all[] = {
+  a2dp_lhdc_source_caps_JAS,
+  a2dp_lhdc_source_caps_AR,
+  a2dp_lhdc_source_caps_LLAC,
+  a2dp_lhdc_source_caps_META,
+  a2dp_lhdc_source_caps_MBR,
+  a2dp_lhdc_source_caps_LARC,
+  a2dp_lhdc_source_caps_LHDCV4,
+};
+
+
+// data type for the LHDC Codec Information Element */
+// NOTE: bits_per_sample is needed only for LHDC encoder initialization.
+typedef struct {
+  uint32_t vendorId;
+  uint16_t codecId;    /* Codec ID for LHDC */
+  uint8_t sampleRate;  /* Sampling Frequency for LHDC*/
+  uint8_t llac_sampleRate;  /* Sampling Frequency for LLAC */
+  btav_a2dp_codec_bits_per_sample_t bits_per_sample;
+  uint8_t channelSplitMode;
+  uint8_t version;
+  uint8_t maxTargetBitrate;
+  bool isLLSupported;
+  //uint8_t supportedBitrate;
+  bool hasFeatureJAS;
+  bool hasFeatureAR;
+  bool hasFeatureLLAC;
+  bool hasFeatureMETA;
+  bool hasFeatureMinBitrate;
+  bool hasFeatureLARC;
+  bool hasFeatureLHDCV4;
+} tA2DP_LHDC_CIE;
+
+/* LHDC Source codec capabilities */
+static const tA2DP_LHDC_CIE a2dp_lhdc_source_caps = {
+  A2DP_LHDC_VENDOR_ID,  // vendorId
+  A2DP_LHDCV3_CODEC_ID,   // codecId
+  // sampleRate
+  //(A2DP_LHDC_SAMPLING_FREQ_48000),
+  (A2DP_LHDC_SAMPLING_FREQ_44100 | A2DP_LHDC_SAMPLING_FREQ_48000 | A2DP_LHDC_SAMPLING_FREQ_96000),
+  (A2DP_LHDC_SAMPLING_FREQ_48000),
+  // bits_per_sample
+  (BTAV_A2DP_CODEC_BITS_PER_SAMPLE_16 | BTAV_A2DP_CODEC_BITS_PER_SAMPLE_24),
+  //Channel Separation
+  (A2DP_LHDC_CH_SPLIT_NONE | A2DP_LHDC_CH_SPLIT_TWS),
+  //Version number
+  A2DP_LHDC_VER3 | A2DP_LHDC_VER4 | A2DP_LHDC_VER6,
+  //Target bit Rate
+  A2DP_LHDC_MAX_BIT_RATE_900K,
+  //LL supported ?
+  true,
+
+  /*******************************
+   *  LHDC features/capabilities:
+   *  hasFeatureJAS
+   *  hasFeatureAR
+   *  hasFeatureLLAC
+   *  hasFeatureMETA
+   *  hasFeatureMinBitrate
+   *  hasFeatureLARC
+   *  hasFeatureLHDCV4
+   *******************************/
+  //bool hasFeatureJAS;
+  false,
+
+  //bool hasFeatureAR;
+  false,
+
+  //bool hasFeatureLLAC;
+  true,
+
+  //bool hasFeatureMETA;
+  false,
+
+  //bool hasFeatureMinBitrate;
+  true,
+
+  //bool hasFeatureLARC;
+  false,
+
+  //bool hasFeatureLHDCV4;
+  true,
+};
+
+/* for response to API */
+static int A2DP_VendorGetSrcCapNumberLhdcv3()
+{
+  return (sizeof(a2dp_lhdc_source_caps_all) / sizeof(tA2DP_LHDC_FEATURE_POS) );
+}
+
+/* for response to API */
+bool A2DP_VendorGetSrcCapVectorLhdcv3(uint8_t *capVector)
+{
+  int capNumber = 0, run = 0;
+
+  if(!capVector) {
+    log::error( " : null buffer!");
+    return false;
+  }
+
+  /* count and check the number of source available capabilities */
+  capNumber = A2DP_VendorGetSrcCapNumberLhdcv3();
+  if(capNumber <= 0) {
+    log::info(":no capabilities, nothing to do!");
+    return true;
+  }
+
+  /* configure capabilities vector for LHDC API */
+  /* Byte-1:      featureCode
+   * Byte-2[7-6]: inSpecBank
+   * Byte-2[5-0]: bitPos
+   */
+  for(int i=0; i<capNumber; i++) {
+    capVector[run] = a2dp_lhdc_source_caps_all[i].featureCode;
+    capVector[run+1] = a2dp_lhdc_source_caps_all[i].inSpecBank | a2dp_lhdc_source_caps_all[i].bitPos;
+    //log::info( " : fill cap({}):[0x{} 0x{}]", i, capVector[run], capVector[run+1]);
+    run+=2;
+  }
+
+  return true;
+}
+
+/* Default LHDC codec configuration */
+static const tA2DP_LHDC_CIE a2dp_lhdc_default_config = {
+  A2DP_LHDC_VENDOR_ID,                // vendorId
+  A2DP_LHDCV3_CODEC_ID,                 // codecId
+  A2DP_LHDC_SAMPLING_FREQ_96000,      // LHDC default best sampleRate
+  A2DP_LHDC_SAMPLING_FREQ_48000,      // LLAC default best sampleRate
+  BTAV_A2DP_CODEC_BITS_PER_SAMPLE_24,  // bits_per_sample
+  A2DP_LHDC_CH_SPLIT_NONE,
+  A2DP_LHDC_VER3,
+  A2DP_LHDC_MAX_BIT_RATE_900K,
+  //LL supported ?
+  true,
+
+  //bool hasFeatureJAS;
+  false,
+
+  //bool hasFeatureAR;
+  false,
+
+  //bool hasFeatureLLAC;
+  true,
+
+  //bool hasFeatureMETA;
+  false,
+
+  //bool hasFeatureMinBitrate;
+  true,
+
+  //bool hasFeatureLARC;
+  false,
+
+  //bool hasFeatureLHDCV4;
+  true,
+};
+
+static std::string lhdcV3_QualityModeBitRate_toString(uint32_t value) {
+  switch((int)value)
+  {
+    case A2DP_LHDC_QUALITY_ABR:
+      return "ABR";
+    case A2DP_LHDC_QUALITY_HIGH1:
+      return "HIGH 1 (1000 Kbps)";
+    case A2DP_LHDC_QUALITY_HIGH:
+      return "HIGH (900 Kbps)";
+    case A2DP_LHDC_QUALITY_MID:
+      return "MID (500 Kbps)";
+    case A2DP_LHDC_QUALITY_LOW:
+      return "LOW (400 Kbps)";
+    case A2DP_LHDC_QUALITY_LOW4:
+      return "LOW 4 (320 Kbps)";
+    case A2DP_LHDC_QUALITY_LOW3:
+      return "LOW 3 (256 Kbps)";
+    case A2DP_LHDC_QUALITY_LOW2:
+      return "LOW 2 (192 Kbps)";
+    case A2DP_LHDC_QUALITY_LOW1:
+      return "LOW 1 (128 Kbps)";
+    case A2DP_LHDC_QUALITY_LOW0:
+      return "LOW 0 (64 Kbps)";
+    default:
+      return "Unknown Bit Rate Mode";
+  }
+}
+
+static const tA2DP_ENCODER_INTERFACE a2dp_encoder_interface_lhdcv3 = {
+  a2dp_vendor_lhdcv3_encoder_init,
+  a2dp_vendor_lhdcv3_encoder_cleanup,
+  a2dp_vendor_lhdcv3_feeding_reset,
+  a2dp_vendor_lhdcv3_feeding_flush,
+  a2dp_vendor_lhdcv3_get_encoder_interval_ms,
+  a2dp_vendor_lhdcv3_get_effective_frame_size,
+  a2dp_vendor_lhdcv3_send_frames,
+  a2dp_vendor_lhdcv3_set_transmit_queue_length};
+
+UNUSED_ATTR static tA2DP_STATUS A2DP_CodecInfoMatchesCapabilityLhdcV3(
+    const tA2DP_LHDC_CIE* p_cap, const uint8_t* p_codec_info,
+    bool is_peer_codec_info);
+
+
+// Builds the LHDC Media Codec Capabilities byte sequence beginning from the
+// LOSC octet. |media_type| is the media type |AVDT_MEDIA_TYPE_*|.
+// |p_ie| is a pointer to the LHDC Codec Information Element information.
+// The result is stored in |p_result|. Returns A2DP_SUCCESS on success,
+// otherwise the corresponding A2DP error status code.
+static tA2DP_STATUS A2DP_BuildInfoLhdcV3(uint8_t media_type,
+                                         const tA2DP_LHDC_CIE* p_ie,
+                                         uint8_t* p_result) {
+
+  const uint8_t* tmpInfo = p_result;
+  if (p_ie == NULL || p_result == NULL) {
+      return A2DP_INVALID_CODEC_PARAMETER;
+  }
+
+  *p_result++ = A2DP_LHDCV3_CODEC_LEN;    //0
+  *p_result++ = (media_type << 4);      //1
+  *p_result++ = A2DP_MEDIA_CT_NON_A2DP; //2
+
+  // Vendor ID and Codec ID
+  *p_result++ = (uint8_t)(p_ie->vendorId & 0x000000FF); //3
+  *p_result++ = (uint8_t)((p_ie->vendorId & 0x0000FF00) >> 8);  //4
+  *p_result++ = (uint8_t)((p_ie->vendorId & 0x00FF0000) >> 16); //5
+  *p_result++ = (uint8_t)((p_ie->vendorId & 0xFF000000) >> 24); //6
+  *p_result++ = (uint8_t)(p_ie->codecId & 0x00FF);  //7
+  *p_result++ = (uint8_t)((p_ie->codecId & 0xFF00) >> 8);   //8
+
+  // Sampling Frequency & Bits per sample
+  uint8_t para = 0;
+
+  // sample rate bit0 ~ bit2
+  para = (uint8_t)(p_ie->sampleRate & A2DP_LHDC_SAMPLING_FREQ_MASK);
+
+  if (p_ie->bits_per_sample == (BTAV_A2DP_CODEC_BITS_PER_SAMPLE_24 | BTAV_A2DP_CODEC_BITS_PER_SAMPLE_16)) {
+    para = para | (A2DP_LHDC_BIT_FMT_24 | A2DP_LHDC_BIT_FMT_16);
+  }else if(p_ie->bits_per_sample == BTAV_A2DP_CODEC_BITS_PER_SAMPLE_24){
+    para = para | A2DP_LHDC_BIT_FMT_24;
+  }else if(p_ie->bits_per_sample == BTAV_A2DP_CODEC_BITS_PER_SAMPLE_16){
+    para = para | A2DP_LHDC_BIT_FMT_16;
+  }
+
+  if (p_ie->hasFeatureJAS) {
+    para |= A2DP_LHDC_FEATURE_JAS;
+  }
+
+  if (p_ie->hasFeatureAR) {
+    para |= A2DP_LHDC_FEATURE_AR;
+  }
+
+  // Save octet 9
+  *p_result++ = para;   //9
+
+  para = p_ie->version;
+
+  para |= p_ie->maxTargetBitrate;
+
+  para |= p_ie->isLLSupported ? A2DP_LHDC_LL_SUPPORTED : A2DP_LHDC_LL_NONE;
+
+  if (p_ie->hasFeatureLLAC) {
+    para |= A2DP_LHDC_FEATURE_LLAC;
+  }
+
+  // Save octet 10
+  *p_result++ = para;   //a
+
+  //Save octet 11
+  para = p_ie->channelSplitMode;
+
+  if (p_ie->hasFeatureMETA) {
+    para |= A2DP_LHDC_FEATURE_META;
+  }
+
+  if (p_ie->hasFeatureMinBitrate) {
+    para |= A2DP_LHDC_FEATURE_MIN_BR;
+  }
+
+  if (p_ie->hasFeatureLARC) {
+    para |= A2DP_LHDC_FEATURE_LARC;
+  }
+
+  if (p_ie->hasFeatureLHDCV4) {
+    para |= A2DP_LHDC_FEATURE_LHDCV4;
+  }
+
+  *p_result++ = para;   //b
+
+  //Save octet 12
+  //para = p_ie->supportedBitrate;
+  //*p_result++ = para;   //c
+
+  log::info( ": Info build result = [0]:0x{:02x}, [1]:0x{:02x}, [2]:0x{:02x}, [3]:0x%{:02x}, "
+    "[4]:0x{:02x}, [5]:0x{:02x}, [6]:0x{:02x}, [7]:0x{:02x}, [8]:0x{:02x}, [9]:0x{:02x}, [10]:0x{:02x}, [11]:0x{:02x}",
+    tmpInfo[0], tmpInfo[1], tmpInfo[2], tmpInfo[3],
+    tmpInfo[4], tmpInfo[5], tmpInfo[6], tmpInfo[7], tmpInfo[8], tmpInfo[9], tmpInfo[10], tmpInfo[11]);
+  return A2DP_SUCCESS;
+}
+
+// Parses the LHDC Media Codec Capabilities byte sequence beginning from the
+// LOSC octet. The result is stored in |p_ie|. The byte sequence to parse is
+// |p_codec_info|. If |is_capability| is true, the byte sequence is
+// codec capabilities, otherwise is codec configuration.
+// Returns A2DP_SUCCESS on success, otherwise the corresponding A2DP error
+// status code.
+static tA2DP_STATUS A2DP_ParseInfoLhdcV3(tA2DP_LHDC_CIE* p_ie,
+                                         const uint8_t* p_codec_info,
+                                         bool is_capability) {
+  uint8_t losc;
+  uint8_t media_type;
+  tA2DP_CODEC_TYPE codec_type;
+  const uint8_t* tmpInfo = p_codec_info;
+
+  //log::info( " : p_ie = {}, p_codec_info = {}", p_ie, p_codec_info);
+  if (p_ie == NULL || p_codec_info == NULL) return AVDTP_UNSUPPORTED_CONFIGURATION;
+
+  // Check the codec capability length
+  losc = *p_codec_info++;
+
+  if (losc != A2DP_LHDCV3_CODEC_LEN) return AVDTP_UNSUPPORTED_CONFIGURATION;
+
+  media_type = (*p_codec_info++) >> 4;
+  codec_type = static_cast<tA2DP_CODEC_TYPE>(*p_codec_info++);
+  //log::info( " : media_type = {}, codec_type = {}", media_type, codec_type);
+  /* Check the Media Type and Media Codec Type */
+  if (media_type != AVDT_MEDIA_TYPE_AUDIO || codec_type != A2DP_MEDIA_CT_NON_A2DP) {
+      return AVDTP_UNSUPPORTED_CONFIGURATION;
+  }
+
+  // Check the Vendor ID and Codec ID */
+  p_ie->vendorId = (*p_codec_info & 0x000000FF) |
+    (*(p_codec_info + 1) << 8 & 0x0000FF00) |
+    (*(p_codec_info + 2) << 16 & 0x00FF0000) |
+    (*(p_codec_info + 3) << 24 & 0xFF000000);
+  p_codec_info += 4;
+  p_ie->codecId =
+    (*p_codec_info & 0x00FF) | (*(p_codec_info + 1) << 8 & 0xFF00);
+  p_codec_info += 2;
+  log::info( " :Vendor(0x{:02x}), Codec(0x{:02x})", p_ie->vendorId, p_ie->codecId);
+  if (p_ie->vendorId != A2DP_LHDC_VENDOR_ID ||
+    p_ie->codecId != A2DP_LHDCV3_CODEC_ID) {
+    return AVDTP_UNSUPPORTED_CONFIGURATION;
+  }
+
+  p_ie->sampleRate = *p_codec_info & A2DP_LHDC_SAMPLING_FREQ_MASK;
+  if ((*p_codec_info & A2DP_LHDC_BIT_FMT_MASK) == 0) {
+    return AVDTP_UNSUPPORTED_CONFIGURATION;
+  }
+
+  p_ie->bits_per_sample = BTAV_A2DP_CODEC_BITS_PER_SAMPLE_NONE;
+  if (*p_codec_info & A2DP_LHDC_BIT_FMT_24)
+    p_ie->bits_per_sample |= BTAV_A2DP_CODEC_BITS_PER_SAMPLE_24;
+  if (*p_codec_info & A2DP_LHDC_BIT_FMT_16) {
+    p_ie->bits_per_sample |= BTAV_A2DP_CODEC_BITS_PER_SAMPLE_16;
+  }
+
+  p_ie->hasFeatureJAS = ((*p_codec_info & A2DP_LHDC_FEATURE_JAS) != 0) ? true : false;
+
+  p_ie->hasFeatureAR = ((*p_codec_info & A2DP_LHDC_FEATURE_AR) != 0) ? true : false;
+
+  p_codec_info += 1;
+
+  p_ie->version = (*p_codec_info) & A2DP_LHDC_VERSION_MASK;
+
+  p_ie->maxTargetBitrate = (*p_codec_info) & A2DP_LHDC_MAX_BIT_RATE_MASK;
+
+  p_ie->isLLSupported = ((*p_codec_info & A2DP_LHDC_LL_MASK) != 0)? true : false;
+
+  p_ie->hasFeatureLLAC = ((*p_codec_info & A2DP_LHDC_FEATURE_LLAC) != 0) ? true : false;
+
+  p_codec_info += 1;
+
+  p_ie->channelSplitMode = (*p_codec_info) & A2DP_LHDC_CH_SPLIT_MSK;
+
+  p_ie->hasFeatureMETA = ((*p_codec_info & A2DP_LHDC_FEATURE_META) != 0) ? true : false;
+
+  p_ie->hasFeatureMinBitrate = ((*p_codec_info & A2DP_LHDC_FEATURE_MIN_BR) != 0) ? true : false;
+
+  p_ie->hasFeatureLARC = ((*p_codec_info & A2DP_LHDC_FEATURE_LARC) != 0) ? true : false;
+
+  p_ie->hasFeatureLHDCV4 = ((*p_codec_info & A2DP_LHDC_FEATURE_LHDCV4) != 0) ? true : false;
+
+  log::info ( ":Has LL({}) JAS({}) AR({}) META({}) LLAC({}) MBR({}) LARC({}) V4({})",
+             p_ie->isLLSupported,
+             p_ie->hasFeatureJAS,
+             p_ie->hasFeatureAR,
+             p_ie->hasFeatureMETA,
+             p_ie->hasFeatureLLAC,
+             p_ie->hasFeatureMinBitrate,
+             p_ie->hasFeatureLARC,
+             p_ie->hasFeatureLHDCV4);
+
+  log::info ( ": codec info = [0]:0x{:02x}, [1]:0x{:02x}, [2]:0x{:02x}, [3]:0x{:02x}, [4]:0x{:02x}, [5]:0x{:02x}, [6]:0x{:02x}, [7]:0x{:02x}, [8]:0x{:02x}, [9]:0x{:02x}, [10]:0x{:02x}, [11]:0x{:02x}",
+             tmpInfo[0], tmpInfo[1], tmpInfo[2], tmpInfo[3], tmpInfo[4], tmpInfo[5], tmpInfo[6],
+             tmpInfo[7], tmpInfo[8], tmpInfo[9], tmpInfo[10], tmpInfo[11]);
+
+  if (is_capability) return A2DP_SUCCESS;
+
+  if (A2DP_BitsSet(p_ie->sampleRate) != A2DP_SET_ONE_BIT)
+    return A2DP_NOT_SUPPORTED_SAMPLING_FREQUENCY;
+
+  return A2DP_SUCCESS;
+}
+
+// Build the LHDC Media Payload Header.
+// |p_dst| points to the location where the header should be written to.
+// If |frag| is true, the media payload frame is fragmented.
+// |start| is true for the first packet of a fragmented frame.
+// |last| is true for the last packet of a fragmented frame.
+// If |frag| is false, |num| is the number of number of frames in the packet,
+// otherwise is the number of remaining fragments (including this one).
+/*
+static void A2DP_BuildMediaPayloadHeaderLhdc(uint8_t* p, uint16_t num) {
+  if (p == NULL) return;
+ *p = ( uint8_t)( num & 0xff);
+}
+ */
+
+bool A2DP_IsVendorSourceCodecValidLhdcV3(const uint8_t* p_codec_info) {
+  tA2DP_LHDC_CIE cfg_cie;
+
+  /* Use a liberal check when parsing the codec info */
+  return (A2DP_ParseInfoLhdcV3(&cfg_cie, p_codec_info, false) == A2DP_SUCCESS) ||
+      (A2DP_ParseInfoLhdcV3(&cfg_cie, p_codec_info, true) == A2DP_SUCCESS);
+}
+
+bool A2DP_IsVendorPeerSinkCodecValidLhdcV3(const uint8_t* p_codec_info) {
+  tA2DP_LHDC_CIE cfg_cie;
+
+  /* Use a liberal check when parsing the codec info */
+  return (A2DP_ParseInfoLhdcV3(&cfg_cie, p_codec_info, false) == A2DP_SUCCESS) ||
+      (A2DP_ParseInfoLhdcV3(&cfg_cie, p_codec_info, true) == A2DP_SUCCESS);
+}
+
+// Checks whether A2DP LHDC codec configuration matches with a device's codec
+// capabilities. |p_cap| is the LHDC codec configuration. |p_codec_info| is
+// the device's codec capabilities.
+// If |is_capability| is true, the byte sequence is codec capabilities,
+// otherwise is codec configuration.
+// |p_codec_info| contains the codec capabilities for a peer device that
+// is acting as an A2DP source.
+// Returns A2DP_SUCCESS if the codec configuration matches with capabilities,
+// otherwise the corresponding A2DP error status code.
+static tA2DP_STATUS A2DP_CodecInfoMatchesCapabilityLhdcV3(
+    const tA2DP_LHDC_CIE* p_cap, const uint8_t* p_codec_info,
+    bool is_capability) {
+  tA2DP_STATUS status;
+  tA2DP_LHDC_CIE cfg_cie;
+
+  /* parse configuration */
+  status = A2DP_ParseInfoLhdcV3(&cfg_cie, p_codec_info, is_capability);
+  if (status != A2DP_SUCCESS) {
+      log::error( " : parsing failed {}", status);
+      return status;
+  }
+
+  /* verify that each parameter is in range */
+
+  log::info ( ": FREQ peer: 0x{:02x}, capability 0x{:02x}",
+             cfg_cie.sampleRate, p_cap->sampleRate);
+
+  log::info( ": BIT_FMT peer: 0x{:02x}, capability 0x{:02x}",
+             cfg_cie.bits_per_sample, p_cap->bits_per_sample);
+
+  /* sampling frequency */
+  if ((cfg_cie.sampleRate & p_cap->sampleRate) == 0) return A2DP_NOT_SUPPORTED_SAMPLING_FREQUENCY;
+
+  /* bit per sample */
+  if ((cfg_cie.bits_per_sample & p_cap->bits_per_sample) == 0) return A2DP_NOT_SUPPORTED_CHANNEL_MODE;
+
+  return A2DP_SUCCESS;
+}
+
+bool A2DP_VendorUsesRtpHeaderLhdcV3(UNUSED_ATTR bool content_protection_enabled,
+                                    UNUSED_ATTR const uint8_t* p_codec_info) {
+  // TODO: Is this correct? The RTP header is always included?
+  return true;
+}
+
+const char* A2DP_VendorCodecNameLhdcV3(UNUSED_ATTR const uint8_t* p_codec_info) {
+  return "LHDC V3";
+}
+
+bool A2DP_VendorCodecTypeEqualsLhdcV3(const uint8_t* p_codec_info_a,
+                                      const uint8_t* p_codec_info_b) {
+  tA2DP_LHDC_CIE lhdc_cie_a;
+  tA2DP_LHDC_CIE lhdc_cie_b;
+
+  // Check whether the codec info contains valid data
+  tA2DP_STATUS a2dp_status =
+      A2DP_ParseInfoLhdcV3(&lhdc_cie_a, p_codec_info_a, true);
+  if (a2dp_status != A2DP_SUCCESS) {
+      log::error( " : cannot decode codec information: {}", 
+                 a2dp_status);
+      return false;
+  }
+  a2dp_status = A2DP_ParseInfoLhdcV3(&lhdc_cie_b, p_codec_info_b, true);
+  if (a2dp_status != A2DP_SUCCESS) {
+      log::error( " : cannot decode codec information: {}", 
+                 a2dp_status);
+      return false;
+  }
+
+  return true;
+}
+
+bool A2DP_VendorCodecEqualsLhdcV3(const uint8_t* p_codec_info_a,
+                                  const uint8_t* p_codec_info_b) {
+  tA2DP_LHDC_CIE lhdc_cie_a;
+  tA2DP_LHDC_CIE lhdc_cie_b;
+
+  // Check whether the codec info contains valid data
+  tA2DP_STATUS a2dp_status =
+      A2DP_ParseInfoLhdcV3(&lhdc_cie_a, p_codec_info_a, true);
+  if (a2dp_status != A2DP_SUCCESS) {
+      log::error( " : cannot decode codec information: {}", 
+                 a2dp_status);
+      return false;
+  }
+  a2dp_status = A2DP_ParseInfoLhdcV3(&lhdc_cie_b, p_codec_info_b, true);
+  if (a2dp_status != A2DP_SUCCESS) {
+      log::error( " : cannot decode codec information: {}", 
+                 a2dp_status);
+      return false;
+  }
+
+  return (lhdc_cie_a.sampleRate == lhdc_cie_b.sampleRate) &&
+      (lhdc_cie_a.bits_per_sample == lhdc_cie_b.bits_per_sample) &&
+      /*(lhdc_cie_a.supportedBitrate == lhdc_cie_b.supportedBitrate) &&*/
+      (lhdc_cie_a.hasFeatureLLAC == lhdc_cie_b.hasFeatureLLAC) &&
+      (lhdc_cie_a.hasFeatureLHDCV4 == lhdc_cie_b.hasFeatureLHDCV4) &&
+      (lhdc_cie_a.isLLSupported == lhdc_cie_b.isLLSupported);
+}
+
+// Savitech Patch - START  Offload
+int A2DP_VendorGetBitRateLhdcV3(UNUSED_ATTR const uint8_t* p_codec_info) {
+
+  A2dpCodecConfig* current_codec = bta_av_get_a2dp_current_codec();
+  btav_a2dp_codec_config_t codec_config_ = current_codec->getCodecConfig();
+  uint8_t bitRateIndex = 0;
+
+  if ((codec_config_.codec_specific_1 & A2DP_LHDC_VENDOR_CMD_MASK) ==
+    A2DP_LHDC_QUALITY_MAGIC_NUM) {
+    bitRateIndex = codec_config_.codec_specific_1 & A2DP_LHDC_QUALITY_MASK;
+    switch (bitRateIndex) {
+      case A2DP_LHDC_QUALITY_LOW0:
+        return 64000;
+      case A2DP_LHDC_QUALITY_LOW1:
+        return 128000;
+      case A2DP_LHDC_QUALITY_LOW2:
+        return 192000;
+      case A2DP_LHDC_QUALITY_LOW3:
+        return 256000;
+      case A2DP_LHDC_QUALITY_LOW4:
+        return 320000;
+      case A2DP_LHDC_QUALITY_LOW:
+        return 400000;
+      case A2DP_LHDC_QUALITY_MID:
+        return 500000;
+      case A2DP_LHDC_QUALITY_HIGH:
+        return 900000;
+      case A2DP_LHDC_QUALITY_ABR:
+        return 9999999;
+      case A2DP_LHDC_QUALITY_HIGH1:
+      default:
+        log::info(": non-supported bitrate index ({})", bitRateIndex);
+        return -1;
+    }
+  }
+  return 400000;
+}
+// Savitech Patch - END
+
+int A2DP_VendorGetTrackSampleRateLhdcV3(const uint8_t* p_codec_info) {
+  tA2DP_LHDC_CIE lhdc_cie;
+
+  // Check whether the codec info contains valid data
+  tA2DP_STATUS a2dp_status = A2DP_ParseInfoLhdcV3(&lhdc_cie, p_codec_info, false);
+  if (a2dp_status != A2DP_SUCCESS) {
+    log::error( " : cannot decode codec information: {}", 
+               a2dp_status);
+    return -1;
+  }
+
+  switch (lhdc_cie.sampleRate) {
+    case A2DP_LHDC_SAMPLING_FREQ_44100:
+      return 44100;
+    case A2DP_LHDC_SAMPLING_FREQ_48000:
+      return 48000;
+    case A2DP_LHDC_SAMPLING_FREQ_88200:
+      return 88200;
+    case A2DP_LHDC_SAMPLING_FREQ_96000:
+      return 96000;
+  }
+
+  return -1;
+}
+
+int A2DP_VendorGetTrackBitsPerSampleLhdcV3(const uint8_t* p_codec_info) {
+  tA2DP_LHDC_CIE lhdc_cie;
+
+  // Check whether the codec info contains valid data
+  tA2DP_STATUS a2dp_status = A2DP_ParseInfoLhdcV3(&lhdc_cie, p_codec_info, false);
+  if (a2dp_status != A2DP_SUCCESS) {
+    log::error( " : cannot decode codec information: {}", 
+               a2dp_status);
+    return -1;
+  }
+
+  switch (lhdc_cie.bits_per_sample) {
+    case BTAV_A2DP_CODEC_BITS_PER_SAMPLE_16:
+      return 16;
+    case BTAV_A2DP_CODEC_BITS_PER_SAMPLE_24:
+      return 24;
+    case BTAV_A2DP_CODEC_BITS_PER_SAMPLE_32:
+      return 32;
+    case BTAV_A2DP_CODEC_BITS_PER_SAMPLE_NONE:
+      return -1;
+  }
+}
+
+int A2DP_VendorGetTrackChannelCountLhdcV3(const uint8_t* p_codec_info) {
+  tA2DP_LHDC_CIE lhdc_cie;
+
+  // Check whether the codec info contains valid data
+  tA2DP_STATUS a2dp_status = A2DP_ParseInfoLhdcV3(&lhdc_cie, p_codec_info, false);
+  if (a2dp_status != A2DP_SUCCESS) {
+    log::error( " : cannot decode codec information: {}", 
+               a2dp_status);
+    return -1;
+  }
+  return 2;
+}
+
+int A2DP_VendorGetChannelModeCodeLhdcV3(const uint8_t* p_codec_info) {
+  tA2DP_LHDC_CIE lhdc_cie;
+
+  // Check whether the codec info contains valid data
+  tA2DP_STATUS a2dp_status = A2DP_ParseInfoLhdcV3(&lhdc_cie, p_codec_info, false);
+  if (a2dp_status != A2DP_SUCCESS) {
+    log::error( " : cannot decode codec information: {}", 
+               a2dp_status);
+    return -1;
+  }
+  return A2DP_LHDC_CHANNEL_MODE_STEREO;
+}
+
+bool A2DP_VendorGetPacketTimestampLhdcV3(UNUSED_ATTR const uint8_t* p_codec_info,
+                                         const uint8_t* p_data,
+                                         uint32_t* p_timestamp) {
+  // TODO: Is this function really codec-specific?
+  *p_timestamp = *(const uint32_t*)p_data;
+  return true;
+}
+
+int16_t A2DP_VendorGetMaxDatarateLhdcV3(const uint8_t* p_codec_info){
+  tA2DP_LHDC_CIE lhdc_cie;
+
+  // Check whether the codec info contains valid data
+  tA2DP_STATUS a2dp_status = A2DP_ParseInfoLhdcV3(&lhdc_cie, p_codec_info, true);
+  if (a2dp_status != A2DP_SUCCESS) {
+    log::error( " : cannot decode codec information: {}", 
+               a2dp_status);
+    return -1;
+  }
+
+  /*
+#define A2DP_LHDC_MAX_BIT_RATE_900K       0x00
+#define A2DP_LHDC_MAX_BIT_RATE_500K       0x10
+#define A2DP_LHDC_MAX_BIT_RATE_400K       0x20
+
+#define A2DP_LHDC_QUALITY_HIGH   7  // Equal to LHDCBT_EQMID_HQ 900kbps
+#define A2DP_LHDC_QUALITY_MID    6   // Equal to LHDCBT_EQMID_SQ 500/560kbps
+#define A2DP_LHDC_QUALITY_LOW    5   // Equal to LHDCBT_EQMID_MQ 400kbps
+   */
+  switch (lhdc_cie.maxTargetBitrate & A2DP_LHDC_MAX_BIT_RATE_MASK) {
+    case A2DP_LHDC_MAX_BIT_RATE_900K:
+      return A2DP_LHDC_QUALITY_HIGH;
+    case A2DP_LHDC_MAX_BIT_RATE_500K:
+      return A2DP_LHDC_QUALITY_MID;
+    case A2DP_LHDC_MAX_BIT_RATE_400K:
+      return A2DP_LHDC_QUALITY_LOW;
+  }
+  return -1;
+}
+
+bool A2DP_VendorGetLowLatencyStateLhdcV3(const uint8_t* p_codec_info){
+  tA2DP_LHDC_CIE lhdc_cie;
+
+  // Check whether the codec info contains valid data
+  tA2DP_STATUS a2dp_status = A2DP_ParseInfoLhdcV3(&lhdc_cie, p_codec_info, false);
+  if (a2dp_status != A2DP_SUCCESS) {
+    log::error( " : cannot decode codec information: {}", 
+               a2dp_status);
+    return -1;
+  }
+
+  log::info( ": isLLSupported ={}", lhdc_cie.isLLSupported);
+
+  return lhdc_cie.isLLSupported ? true : false;
+}
+
+
+
+
+//Always return newest version.
+uint8_t A2DP_VendorGetVersionLhdcV3(const uint8_t* p_codec_info){
+  tA2DP_LHDC_CIE lhdc_cie;
+  uint8_t result;
+
+  // Check whether the codec info contains valid data
+  tA2DP_STATUS a2dp_status = A2DP_ParseInfoLhdcV3(&lhdc_cie, p_codec_info, false);
+  if (a2dp_status != A2DP_SUCCESS) {
+    log::error( " : cannot decode codec information: {}", 
+               a2dp_status);
+    return -1;
+  }
+
+
+  for (result = 0x08; result != 0; ) {
+    if ((lhdc_cie.version & result) != 0) {
+      break;
+    }
+    result >>= 1;
+  }
+  //log::info( " : version = 0x{}, result = 0x{}", lhdc_cie.version, result);
+
+
+  switch (result) {
+    case A2DP_LHDC_VER3:
+      return 1;
+    case A2DP_LHDC_VER4:
+      return 2;
+    case A2DP_LHDC_VER5:
+      return 3;
+    case A2DP_LHDC_VER6:
+      return 4;
+    default:
+      return -1;
+  }
+}
+
+
+int8_t A2DP_VendorGetChannelSplitModeLhdcV3(const uint8_t* p_codec_info){
+  tA2DP_LHDC_CIE lhdc_cie;
+
+  // Check whether the codec info contains valid data
+  tA2DP_STATUS a2dp_status = A2DP_ParseInfoLhdcV3(&lhdc_cie, p_codec_info, false);
+  if (a2dp_status != A2DP_SUCCESS) {
+    log::error( " : cannot decode codec information: {}", 
+               a2dp_status);
+    return -1;
+  }
+
+  log::info( ": channelSplitMode ={}", lhdc_cie.channelSplitMode);
+
+  return lhdc_cie.channelSplitMode;
+
+}
+
+bool A2DP_VendorHasV4FlagLhdcV3(const uint8_t* p_codec_info) {
+  tA2DP_LHDC_CIE lhdc_cie;
+  if (A2DP_ParseInfoLhdcV3(&lhdc_cie, p_codec_info, false) != A2DP_SUCCESS)
+    return false;
+
+  return lhdc_cie.hasFeatureLHDCV4;
+}
+
+bool A2DP_VendorHasJASFlagLhdcV3(const uint8_t* p_codec_info) {
+  tA2DP_LHDC_CIE lhdc_cie;
+  if (A2DP_ParseInfoLhdcV3(&lhdc_cie, p_codec_info, false) != A2DP_SUCCESS)
+    return false;
+
+  return lhdc_cie.hasFeatureJAS;
+}
+
+bool A2DP_VendorHasARFlagLhdcV3(const uint8_t* p_codec_info) {
+  tA2DP_LHDC_CIE lhdc_cie;
+  if (A2DP_ParseInfoLhdcV3(&lhdc_cie, p_codec_info, false) != A2DP_SUCCESS)
+    return false;
+
+  return lhdc_cie.hasFeatureAR;
+}
+
+bool A2DP_VendorHasLLACFlagLhdcV3(const uint8_t* p_codec_info) {
+  tA2DP_LHDC_CIE lhdc_cie;
+  if (A2DP_ParseInfoLhdcV3(&lhdc_cie, p_codec_info, false) != A2DP_SUCCESS)
+    return false;
+
+  return lhdc_cie.hasFeatureLLAC;
+}
+
+bool A2DP_VendorHasMETAFlagLhdcV3(const uint8_t* p_codec_info) {
+  tA2DP_LHDC_CIE lhdc_cie;
+  if (A2DP_ParseInfoLhdcV3(&lhdc_cie, p_codec_info, false) != A2DP_SUCCESS)
+    return false;
+
+  return lhdc_cie.hasFeatureMETA;
+}
+
+bool A2DP_VendorHasMinBRFlagLhdcV3(const uint8_t* p_codec_info) {
+  tA2DP_LHDC_CIE lhdc_cie;
+  if (A2DP_ParseInfoLhdcV3(&lhdc_cie, p_codec_info, false) != A2DP_SUCCESS)
+    return false;
+
+  return lhdc_cie.hasFeatureMinBitrate;
+}
+
+bool A2DP_VendorHasLARCFlagLhdcV3(const uint8_t* p_codec_info) {
+  tA2DP_LHDC_CIE lhdc_cie;
+  if (A2DP_ParseInfoLhdcV3(&lhdc_cie, p_codec_info, false) != A2DP_SUCCESS)
+    return false;
+
+  return lhdc_cie.hasFeatureLARC;
+}
+
+bool A2DP_VendorBuildCodecHeaderLhdcV3(UNUSED_ATTR const uint8_t* p_codec_info,
+                                       BT_HDR* p_buf,
+                                       uint16_t frames_per_packet) {
+  uint8_t* p;
+
+  p_buf->offset -= A2DP_LHDC_MPL_HDR_LEN;
+  p = (uint8_t*)(p_buf + 1) + p_buf->offset;
+  p_buf->len += A2DP_LHDC_MPL_HDR_LEN;
+  p[0] = ( uint8_t)( frames_per_packet & 0xff);
+  p[1] = ( uint8_t)( ( frames_per_packet >> 8) & 0xff);
+  //A2DP_BuildMediaPayloadHeaderLhdc(p, frames_per_packet);
+  return true;
+}
+
+void A2DP_VendorDumpCodecInfoLhdcV3(const uint8_t* p_codec_info) {
+  tA2DP_STATUS a2dp_status;
+  tA2DP_LHDC_CIE lhdc_cie;
+
+  log::info(" ");
+
+  a2dp_status = A2DP_ParseInfoLhdcV3(&lhdc_cie, p_codec_info, true);
+  if (a2dp_status != A2DP_SUCCESS) {
+    log::error( " : A2DP_ParseInfoLhdcV3 fail:{}", a2dp_status);
+    return;
+  }
+
+  log::info( "\tsamp_freq: 0x{}", lhdc_cie.sampleRate);
+  if (lhdc_cie.sampleRate & A2DP_LHDC_SAMPLING_FREQ_44100) {
+    log::info( "\tsamp_freq: (44100)");
+  }
+  if (lhdc_cie.sampleRate & A2DP_LHDC_SAMPLING_FREQ_48000) {
+    log::info( "\tsamp_freq: (48000)");
+  }
+  if (lhdc_cie.sampleRate & A2DP_LHDC_SAMPLING_FREQ_88200) {
+    log::info( "\tsamp_freq: (88200)");
+  }
+  if (lhdc_cie.sampleRate & A2DP_LHDC_SAMPLING_FREQ_96000) {
+    log::info( "\tsamp_freq: (96000)");
+  }
+}
+
+std::string A2DP_VendorCodecInfoStringLhdcV3(const uint8_t* p_codec_info) {
+  std::stringstream res;
+  std::string field;
+  tA2DP_STATUS a2dp_status;
+  tA2DP_LHDC_CIE lhdc_cie;
+
+  a2dp_status = A2DP_ParseInfoLhdcV3(&lhdc_cie, p_codec_info, true);
+  if (a2dp_status != A2DP_SUCCESS) {
+    res << "A2DP_ParseInfoLhdcV3 fail: " <<  loghex(static_cast<uint8_t>(a2dp_status));
+    return res.str();
+  }
+
+  res << "\tname: LHDC\n";
+
+  // Sample frequency
+  field.clear();
+  AppendField(&field, (lhdc_cie.sampleRate == 0), "NONE");
+  AppendField(&field, (lhdc_cie.sampleRate & A2DP_LHDC_SAMPLING_FREQ_44100),
+              "44100");
+  AppendField(&field, (lhdc_cie.sampleRate & A2DP_LHDC_SAMPLING_FREQ_48000),
+              "48000");
+  AppendField(&field, (lhdc_cie.sampleRate & A2DP_LHDC_SAMPLING_FREQ_88200),
+              "88200");
+  AppendField(&field, (lhdc_cie.sampleRate & A2DP_LHDC_SAMPLING_FREQ_96000),
+              "96000");
+  res << "\tsamp_freq: " << field << " (" << loghex(lhdc_cie.sampleRate)
+          << ")\n";
+
+  // Channel mode
+  field.clear();
+  AppendField(&field, 1,
+              "Stereo");
+  res << "\tch_mode: " << field << " (" << "Only support stereo."
+      << ")\n";
+
+  // bits per sample
+  field.clear();
+  AppendField(&field, (lhdc_cie.bits_per_sample & BTAV_A2DP_CODEC_BITS_PER_SAMPLE_16),
+              "16");
+  AppendField(&field, (lhdc_cie.bits_per_sample & BTAV_A2DP_CODEC_BITS_PER_SAMPLE_24),
+              "24");
+  res << "\tbits_depth: " << field << " bits (" << loghex((int)lhdc_cie.bits_per_sample)
+          << ")\n";
+
+  // Max data rate...
+  field.clear();
+  AppendField(&field, ((lhdc_cie.maxTargetBitrate & A2DP_LHDC_MAX_BIT_RATE_MASK) == A2DP_LHDC_MAX_BIT_RATE_900K),
+              "900Kbps");
+  AppendField(&field, ((lhdc_cie.maxTargetBitrate & A2DP_LHDC_MAX_BIT_RATE_MASK) == A2DP_LHDC_MAX_BIT_RATE_500K),
+              "500Kbps");
+  AppendField(&field, ((lhdc_cie.maxTargetBitrate & A2DP_LHDC_MAX_BIT_RATE_MASK) == A2DP_LHDC_MAX_BIT_RATE_400K),
+              "400Kbps");
+  res << "\tMax target-rate: " << field << " (" << loghex((lhdc_cie.maxTargetBitrate & A2DP_LHDC_MAX_BIT_RATE_MASK))
+          << ")\n";
+
+  // Version
+  field.clear();
+  AppendField(&field, (lhdc_cie.version == A2DP_LHDC_VER3),
+              "LHDC V3");
+  res << "\tversion: " << field << " (" << loghex(lhdc_cie.version)
+          << ")\n";
+
+
+  /*
+  field.clear();
+  AppendField(&field, 0, "NONE");
+  AppendField(&field, 0,
+              "Mono");
+  AppendField(&field, 0,
+              "Dual");
+  AppendField(&field, 1,
+              "Stereo");
+  res << "\tch_mode: " << field << " (" << loghex(lhdc_cie.channelMode)
+      << ")\n";
+   */
+  return res.str();
+}
+
+const tA2DP_ENCODER_INTERFACE* A2DP_VendorGetEncoderInterfaceLhdcV3(
+    const uint8_t* p_codec_info) {
+  if (!A2DP_IsVendorSourceCodecValidLhdcV3(p_codec_info)) return NULL;
+
+  return &a2dp_encoder_interface_lhdcv3;
+}
+
+bool A2DP_VendorAdjustCodecLhdcV3(uint8_t* p_codec_info) {
+  tA2DP_LHDC_CIE cfg_cie;
+
+  // Nothing to do: just verify the codec info is valid
+  if (A2DP_ParseInfoLhdcV3(&cfg_cie, p_codec_info, true) != A2DP_SUCCESS)
+    return false;
+
+  return true;
+}
+
+btav_a2dp_codec_index_t A2DP_VendorSourceCodecIndexLhdcV3(
+    UNUSED_ATTR const uint8_t* p_codec_info) {
+  return BTAV_A2DP_CODEC_INDEX_SOURCE_LHDCV3;
+}
+
+const char* A2DP_VendorCodecIndexStrLhdcV3(void) { return "LHDC V3"; }
+
+bool A2DP_VendorInitCodecConfigLhdcV3(AvdtpSepConfig* p_cfg) {
+  if (A2DP_BuildInfoLhdcV3(AVDT_MEDIA_TYPE_AUDIO, &a2dp_lhdc_source_caps,
+                           p_cfg->codec_info) != A2DP_SUCCESS) {
+    return false;
+  }
+
+#if (BTA_AV_CO_CP_SCMS_T == TRUE)
+  /* Content protection info - support SCMS-T */
+  uint8_t* p = p_cfg->protect_info;
+  *p++ = AVDT_CP_LOSC;
+  UINT16_TO_STREAM(p, AVDT_CP_SCMS_T_ID);
+  p_cfg->num_protect = 1;
+#endif
+
+  return true;
+}
+
+UNUSED_ATTR static void build_codec_config(const tA2DP_LHDC_CIE& config_cie,
+                                           btav_a2dp_codec_config_t* result) {
+  if (config_cie.sampleRate & A2DP_LHDC_SAMPLING_FREQ_44100)
+    result->sample_rate |= BTAV_A2DP_CODEC_SAMPLE_RATE_44100;
+  if (config_cie.sampleRate & A2DP_LHDC_SAMPLING_FREQ_48000)
+    result->sample_rate |= BTAV_A2DP_CODEC_SAMPLE_RATE_48000;
+  if (config_cie.sampleRate & A2DP_LHDC_SAMPLING_FREQ_88200)
+    result->sample_rate |= BTAV_A2DP_CODEC_SAMPLE_RATE_88200;
+  if (config_cie.sampleRate & A2DP_LHDC_SAMPLING_FREQ_96000)
+    result->sample_rate |= BTAV_A2DP_CODEC_SAMPLE_RATE_96000;
+
+  result->bits_per_sample = config_cie.bits_per_sample;
+
+  result->channel_mode |= BTAV_A2DP_CODEC_CHANNEL_MODE_STEREO;
+}
+
+A2dpCodecConfigLhdcV3::A2dpCodecConfigLhdcV3(
+    btav_a2dp_codec_priority_t codec_priority)
+    : A2dpCodecConfig(BTAV_A2DP_CODEC_INDEX_SOURCE_LHDCV3, A2DP_CODEC_ID_LHDCV3,
+                      A2DP_VendorCodecIndexStrLhdcV3(),
+                      codec_priority) {
+  // Compute the local capability        
+
+  // Compute the local capability
+  if (a2dp_lhdc_source_caps.sampleRate & A2DP_LHDC_SAMPLING_FREQ_44100) {
+    codec_local_capability_.sample_rate |= BTAV_A2DP_CODEC_SAMPLE_RATE_44100;
+  }
+  if (a2dp_lhdc_source_caps.sampleRate & A2DP_LHDC_SAMPLING_FREQ_48000) {
+    codec_local_capability_.sample_rate |= BTAV_A2DP_CODEC_SAMPLE_RATE_48000;
+  }
+  if (a2dp_lhdc_source_caps.sampleRate & A2DP_LHDC_SAMPLING_FREQ_88200) {
+    codec_local_capability_.sample_rate |= BTAV_A2DP_CODEC_SAMPLE_RATE_88200;
+  }
+  if (a2dp_lhdc_source_caps.sampleRate & A2DP_LHDC_SAMPLING_FREQ_96000) {
+    codec_local_capability_.sample_rate |= BTAV_A2DP_CODEC_SAMPLE_RATE_96000;
+  }
+  codec_local_capability_.bits_per_sample = a2dp_lhdc_source_caps.bits_per_sample;
+
+  codec_local_capability_.channel_mode |= BTAV_A2DP_CODEC_CHANNEL_MODE_STEREO;
+}
+
+A2dpCodecConfigLhdcV3::~A2dpCodecConfigLhdcV3() {}
+
+bool A2dpCodecConfigLhdcV3::init() {
+  // Load the encoder
+  if (!A2DP_VendorLoadEncoderLhdcV3()) {
+    log::error( " : cannot load the encoder");
+    return false;
+  }
+
+  return true;
+}
+
+bool A2dpCodecConfigLhdcV3::useRtpHeaderMarkerBit() const { return false; }
+
+//
+// Selects the best sample rate from |sampleRate|.
+// The result is stored in |p_result| and |p_codec_config|.
+// Returns true if a selection was made, otherwise false.
+//
+static bool select_best_sample_rate(uint8_t sampleRate,
+                                    tA2DP_LHDC_CIE* p_result,
+                                    btav_a2dp_codec_config_t* p_codec_config) {
+  if (sampleRate & A2DP_LHDC_SAMPLING_FREQ_96000) {
+    p_result->sampleRate = A2DP_LHDC_SAMPLING_FREQ_96000;
+    p_codec_config->sample_rate = BTAV_A2DP_CODEC_SAMPLE_RATE_96000;
+    return true;
+  }
+  if (sampleRate & A2DP_LHDC_SAMPLING_FREQ_88200) {
+    p_result->sampleRate = A2DP_LHDC_SAMPLING_FREQ_88200;
+    p_codec_config->sample_rate = BTAV_A2DP_CODEC_SAMPLE_RATE_88200;
+    return true;
+  }
+  if (sampleRate & A2DP_LHDC_SAMPLING_FREQ_48000) {
+    p_result->sampleRate = A2DP_LHDC_SAMPLING_FREQ_48000;
+    p_codec_config->sample_rate = BTAV_A2DP_CODEC_SAMPLE_RATE_48000;
+    return true;
+  }
+  if (sampleRate & A2DP_LHDC_SAMPLING_FREQ_44100) {
+    p_result->sampleRate = A2DP_LHDC_SAMPLING_FREQ_44100;
+    p_codec_config->sample_rate = BTAV_A2DP_CODEC_SAMPLE_RATE_44100;
+    return true;
+  }
+  return false;
+}
+
+//
+// Selects the audio sample rate from |p_codec_audio_config|.
+// |sampleRate| contains the capability.
+// The result is stored in |p_result| and |p_codec_config|.
+// Returns true if a selection was made, otherwise false.
+//
+static bool select_audio_sample_rate(
+    const btav_a2dp_codec_config_t* p_codec_audio_config, uint8_t sampleRate,
+    tA2DP_LHDC_CIE* p_result, btav_a2dp_codec_config_t* p_codec_config) {
+  switch (p_codec_audio_config->sample_rate) {
+    case BTAV_A2DP_CODEC_SAMPLE_RATE_44100:
+      if (sampleRate & A2DP_LHDC_SAMPLING_FREQ_44100) {
+        p_result->sampleRate = A2DP_LHDC_SAMPLING_FREQ_44100;
+        p_codec_config->sample_rate = BTAV_A2DP_CODEC_SAMPLE_RATE_44100;
+        return true;
+      }
+      break;
+    case BTAV_A2DP_CODEC_SAMPLE_RATE_48000:
+      if (sampleRate & A2DP_LHDC_SAMPLING_FREQ_48000) {
+        p_result->sampleRate = A2DP_LHDC_SAMPLING_FREQ_48000;
+        p_codec_config->sample_rate = BTAV_A2DP_CODEC_SAMPLE_RATE_48000;
+        return true;
+      }
+      break;
+    case BTAV_A2DP_CODEC_SAMPLE_RATE_88200:
+      if (sampleRate & A2DP_LHDC_SAMPLING_FREQ_88200) {
+        p_result->sampleRate = A2DP_LHDC_SAMPLING_FREQ_88200;
+        p_codec_config->sample_rate = BTAV_A2DP_CODEC_SAMPLE_RATE_88200;
+        return true;
+      }
+      break;
+    case BTAV_A2DP_CODEC_SAMPLE_RATE_96000:
+      if (sampleRate & A2DP_LHDC_SAMPLING_FREQ_96000) {
+        p_result->sampleRate = A2DP_LHDC_SAMPLING_FREQ_96000;
+        p_codec_config->sample_rate = BTAV_A2DP_CODEC_SAMPLE_RATE_96000;
+        return true;
+      }
+      break;
+    case BTAV_A2DP_CODEC_SAMPLE_RATE_16000:
+    case BTAV_A2DP_CODEC_SAMPLE_RATE_24000:
+    case BTAV_A2DP_CODEC_SAMPLE_RATE_176400:
+    case BTAV_A2DP_CODEC_SAMPLE_RATE_192000:
+    case BTAV_A2DP_CODEC_SAMPLE_RATE_NONE:
+      break;
+  }
+  return false;
+}
+
+//
+// Selects the best bits per sample from |bits_per_sample|.
+// |bits_per_sample| contains the capability.
+// The result is stored in |p_result| and |p_codec_config|.
+// Returns true if a selection was made, otherwise false.
+//
+static bool select_best_bits_per_sample(
+    btav_a2dp_codec_bits_per_sample_t bits_per_sample, tA2DP_LHDC_CIE* p_result,
+    btav_a2dp_codec_config_t* p_codec_config) {
+  if (bits_per_sample & BTAV_A2DP_CODEC_BITS_PER_SAMPLE_24) {
+    p_codec_config->bits_per_sample = BTAV_A2DP_CODEC_BITS_PER_SAMPLE_24;
+    p_result->bits_per_sample = BTAV_A2DP_CODEC_BITS_PER_SAMPLE_24;
+    return true;
+  }
+  if (bits_per_sample & BTAV_A2DP_CODEC_BITS_PER_SAMPLE_16) {
+    p_codec_config->bits_per_sample = BTAV_A2DP_CODEC_BITS_PER_SAMPLE_16;
+    p_result->bits_per_sample = BTAV_A2DP_CODEC_BITS_PER_SAMPLE_16;
+    return true;
+  }
+  return false;
+}
+
+//
+// Selects the audio bits per sample from |p_codec_audio_config|.
+// |bits_per_sample| contains the capability.
+// The result is stored in |p_result| and |p_codec_config|.
+// Returns true if a selection was made, otherwise false.
+//
+static bool select_audio_bits_per_sample(
+    const btav_a2dp_codec_config_t* p_codec_audio_config,
+    btav_a2dp_codec_bits_per_sample_t bits_per_sample, tA2DP_LHDC_CIE* p_result,
+    btav_a2dp_codec_config_t* p_codec_config) {
+  switch (p_codec_audio_config->bits_per_sample) {
+    case BTAV_A2DP_CODEC_BITS_PER_SAMPLE_16:
+      if (bits_per_sample & BTAV_A2DP_CODEC_BITS_PER_SAMPLE_16) {
+        p_codec_config->bits_per_sample = BTAV_A2DP_CODEC_BITS_PER_SAMPLE_16;
+        p_result->bits_per_sample = BTAV_A2DP_CODEC_BITS_PER_SAMPLE_16;
+        return true;
+      }
+      break;
+    case BTAV_A2DP_CODEC_BITS_PER_SAMPLE_24:
+      if (bits_per_sample & BTAV_A2DP_CODEC_BITS_PER_SAMPLE_24) {
+        p_codec_config->bits_per_sample = BTAV_A2DP_CODEC_BITS_PER_SAMPLE_24;
+        p_result->bits_per_sample = BTAV_A2DP_CODEC_BITS_PER_SAMPLE_24;
+        return true;
+      }
+      break;
+    case BTAV_A2DP_CODEC_BITS_PER_SAMPLE_32:
+    case BTAV_A2DP_CODEC_BITS_PER_SAMPLE_NONE:
+      break;
+  }
+  return false;
+}
+
+static std::string lhdcV3_sampleRate_toString(uint8_t value) {
+  switch((int)value)
+  {
+    case A2DP_LHDC_SAMPLING_FREQ_44100:
+      return "44100";
+    case A2DP_LHDC_SAMPLING_FREQ_48000:
+      return "48000";
+    case A2DP_LHDC_SAMPLING_FREQ_96000:
+      return "96000";
+    default:
+      return "Unknown Sample Rate";
+  }
+}
+
+static std::string lhdcV3_bitPerSample_toString(uint8_t value) {
+  switch((int)value)
+  {
+    case BTAV_A2DP_CODEC_BITS_PER_SAMPLE_16:
+      return "16";
+    case BTAV_A2DP_CODEC_BITS_PER_SAMPLE_24:
+      return "24";
+    default:
+      return "Unknown Bit Per Sample";
+  }
+}
+
+bool A2dpCodecConfigLhdcV3::copySinkCapability(uint8_t * codec_info){
+  std::lock_guard<std::recursive_mutex> lock(codec_mutex_);
+  memcpy(codec_info, ota_codec_peer_capability_, AVDT_CODEC_SIZE);
+  return true;
+}
+
+static bool A2DP_IsFeatureInUserConfigLhdcV3(tA2DP_CODEC_CONFIGS_PACK* cfgsPtr, uint8_t featureCode)
+{
+  switch(featureCode)
+  {
+    case LHDC_EXTEND_FUNC_A2DP_LHDC_JAS_CODE:
+      {
+        CHECK_IN_A2DP_SPEC(cfgsPtr->_codec_user_config_, a2dp_lhdc_source_caps_JAS.inSpecBank, A2DP_LHDC_JAS_ENABLED);
+      }
+      break;
+    case LHDC_EXTEND_FUNC_A2DP_LHDC_AR_CODE:
+      {
+        CHECK_IN_A2DP_SPEC(cfgsPtr->_codec_user_config_, a2dp_lhdc_source_caps_AR.inSpecBank, A2DP_LHDC_AR_ENABLED);
+      }
+      break;
+    case LHDC_EXTEND_FUNC_A2DP_LHDC_META_CODE:
+      {
+        CHECK_IN_A2DP_SPEC(cfgsPtr->_codec_user_config_, a2dp_lhdc_source_caps_META.inSpecBank, A2DP_LHDC_META_ENABLED);
+      }
+      break;
+    case LHDC_EXTEND_FUNC_A2DP_LHDC_LLAC_CODE:
+      {
+        CHECK_IN_A2DP_SPEC(cfgsPtr->_codec_user_config_, a2dp_lhdc_source_caps_LLAC.inSpecBank, A2DP_LHDC_LLAC_ENABLED);
+      }
+      break;
+    case LHDC_EXTEND_FUNC_A2DP_LHDC_MBR_CODE:
+      {
+        CHECK_IN_A2DP_SPEC(cfgsPtr->_codec_user_config_, a2dp_lhdc_source_caps_MBR.inSpecBank, A2DP_LHDC_MBR_ENABLED);
+      }
+      break;
+    case LHDC_EXTEND_FUNC_A2DP_LHDC_LARC_CODE:
+      {
+        CHECK_IN_A2DP_SPEC(cfgsPtr->_codec_user_config_, a2dp_lhdc_source_caps_LARC.inSpecBank, A2DP_LHDC_LARC_ENABLED);
+      }
+      break;
+    case LHDC_EXTEND_FUNC_A2DP_LHDC_V4_CODE:
+      {
+        CHECK_IN_A2DP_SPEC(cfgsPtr->_codec_user_config_, a2dp_lhdc_source_caps_LHDCV4.inSpecBank, A2DP_LHDC_V4_ENABLED);
+      }
+      break;
+
+    default:
+      break;
+  }
+
+  return false;
+}
+static bool A2DP_IsFeatureInCodecConfigLhdcV3(tA2DP_CODEC_CONFIGS_PACK* cfgsPtr, uint8_t featureCode)
+{
+  switch(featureCode)
+  {
+    case LHDC_EXTEND_FUNC_A2DP_LHDC_JAS_CODE:
+      {
+        CHECK_IN_A2DP_SPEC(cfgsPtr->_codec_config_, a2dp_lhdc_source_caps_JAS.inSpecBank, A2DP_LHDC_JAS_ENABLED);
+      }
+      break;
+    case LHDC_EXTEND_FUNC_A2DP_LHDC_AR_CODE:
+      {
+        CHECK_IN_A2DP_SPEC(cfgsPtr->_codec_config_, a2dp_lhdc_source_caps_AR.inSpecBank, A2DP_LHDC_AR_ENABLED);
+      }
+      break;
+    case LHDC_EXTEND_FUNC_A2DP_LHDC_META_CODE:
+      {
+        CHECK_IN_A2DP_SPEC(cfgsPtr->_codec_config_, a2dp_lhdc_source_caps_META.inSpecBank, A2DP_LHDC_META_ENABLED);
+      }
+      break;
+    case LHDC_EXTEND_FUNC_A2DP_LHDC_LLAC_CODE:
+      {
+        CHECK_IN_A2DP_SPEC(cfgsPtr->_codec_config_, a2dp_lhdc_source_caps_LLAC.inSpecBank, A2DP_LHDC_LLAC_ENABLED);
+      }
+      break;
+    case LHDC_EXTEND_FUNC_A2DP_LHDC_MBR_CODE:
+      {
+        CHECK_IN_A2DP_SPEC(cfgsPtr->_codec_config_, a2dp_lhdc_source_caps_MBR.inSpecBank, A2DP_LHDC_MBR_ENABLED);
+      }
+      break;
+    case LHDC_EXTEND_FUNC_A2DP_LHDC_LARC_CODE:
+      {
+        CHECK_IN_A2DP_SPEC(cfgsPtr->_codec_config_, a2dp_lhdc_source_caps_LARC.inSpecBank, A2DP_LHDC_LARC_ENABLED);
+      }
+      break;
+    case LHDC_EXTEND_FUNC_A2DP_LHDC_V4_CODE:
+      {
+        CHECK_IN_A2DP_SPEC(cfgsPtr->_codec_config_, a2dp_lhdc_source_caps_LHDCV4.inSpecBank, A2DP_LHDC_V4_ENABLED);
+      }
+      break;
+
+    default:
+      break;
+  }
+
+  return false;
+}
+
+static void A2DP_UpdateFeatureToSpecLhdcV3(tA2DP_CODEC_CONFIGS_PACK* cfgsPtr,
+                                           uint16_t toCodecCfg, bool hasFeature, uint8_t toSpec, int64_t value)
+{
+  if(toCodecCfg & A2DP_LHDC_TO_A2DP_CODEC_CONFIG_)
+    {
+      SETUP_A2DP_SPEC(cfgsPtr->_codec_config_, toSpec, hasFeature, value);
+    }
+  if(toCodecCfg & A2DP_LHDC_TO_A2DP_CODEC_CAP_)
+    {
+      SETUP_A2DP_SPEC(cfgsPtr->_codec_capability_, toSpec, hasFeature, value);
+    }
+  if(toCodecCfg & A2DP_LHDC_TO_A2DP_CODEC_LOCAL_CAP_)
+    {
+      SETUP_A2DP_SPEC(cfgsPtr->_codec_local_capability_, toSpec, hasFeature, value);
+    }
+  if(toCodecCfg & A2DP_LHDC_TO_A2DP_CODEC_SELECT_CAP_)
+    {
+      SETUP_A2DP_SPEC(cfgsPtr->_codec_selectable_capability_, toSpec, hasFeature, value);
+    }
+  if(toCodecCfg & A2DP_LHDC_TO_A2DP_CODEC_USER_)
+    {
+      SETUP_A2DP_SPEC(cfgsPtr->_codec_user_config_, toSpec, hasFeature, value);
+    }
+  if(toCodecCfg & A2DP_LHDC_TO_A2DP_CODEC_AUDIO_)
+    {
+      SETUP_A2DP_SPEC(cfgsPtr->_codec_audio_config_, toSpec, hasFeature, value);
+    }
+}
+
+static void A2DP_UpdateFeatureToA2dpConfigLhdcV3(tA2DP_CODEC_CONFIGS_PACK *cfgsPtr,
+                                                 uint8_t featureCode,  uint16_t toCodecCfg, bool hasFeature)
+{
+
+  //log::info( ": featureCode:0x{} toCfgs:0x%04X, toSet:{}", featureCode, toCodecCfg, hasFeature);
+
+  switch(featureCode)
+  {
+    case LHDC_EXTEND_FUNC_A2DP_LHDC_JAS_CODE:
+      A2DP_UpdateFeatureToSpecLhdcV3(cfgsPtr, toCodecCfg, hasFeature,
+                                     a2dp_lhdc_source_caps_JAS.inSpecBank, A2DP_LHDC_JAS_ENABLED);
+      break;
+    case LHDC_EXTEND_FUNC_A2DP_LHDC_AR_CODE:
+      A2DP_UpdateFeatureToSpecLhdcV3(cfgsPtr, toCodecCfg, hasFeature,
+                                     a2dp_lhdc_source_caps_AR.inSpecBank, A2DP_LHDC_AR_ENABLED);
+      break;
+    case LHDC_EXTEND_FUNC_A2DP_LHDC_META_CODE:
+      A2DP_UpdateFeatureToSpecLhdcV3(cfgsPtr, toCodecCfg, hasFeature,
+                                     a2dp_lhdc_source_caps_META.inSpecBank, A2DP_LHDC_META_ENABLED);
+      break;
+    case LHDC_EXTEND_FUNC_A2DP_LHDC_LLAC_CODE:
+      A2DP_UpdateFeatureToSpecLhdcV3(cfgsPtr, toCodecCfg, hasFeature,
+                                     a2dp_lhdc_source_caps_LLAC.inSpecBank, A2DP_LHDC_LLAC_ENABLED);
+      break;
+    case LHDC_EXTEND_FUNC_A2DP_LHDC_MBR_CODE:
+      A2DP_UpdateFeatureToSpecLhdcV3(cfgsPtr, toCodecCfg, hasFeature,
+                                     a2dp_lhdc_source_caps_MBR.inSpecBank, A2DP_LHDC_MBR_ENABLED);
+      break;
+    case LHDC_EXTEND_FUNC_A2DP_LHDC_LARC_CODE:
+      A2DP_UpdateFeatureToSpecLhdcV3(cfgsPtr, toCodecCfg, hasFeature,
+                                     a2dp_lhdc_source_caps_LARC.inSpecBank, A2DP_LHDC_LARC_ENABLED);
+      break;
+    case LHDC_EXTEND_FUNC_A2DP_LHDC_V4_CODE:
+      A2DP_UpdateFeatureToSpecLhdcV3(cfgsPtr, toCodecCfg, hasFeature,
+                                     a2dp_lhdc_source_caps_LHDCV4.inSpecBank, A2DP_LHDC_V4_ENABLED);
+      break;
+
+    default:
+      break;
+  }
+}
+
+
+static uint32_t A2DP_MaxBitRatetoQualityLevelLhdcV3(uint8_t maxTargetBitrate)
+{
+  switch (maxTargetBitrate & A2DP_LHDC_MAX_BIT_RATE_MASK)
+  {
+    case A2DP_LHDC_MAX_BIT_RATE_900K:
+      return A2DP_LHDC_QUALITY_HIGH;
+    case A2DP_LHDC_MAX_BIT_RATE_500K:
+      return A2DP_LHDC_QUALITY_MID;
+    case A2DP_LHDC_MAX_BIT_RATE_400K:
+      return A2DP_LHDC_QUALITY_LOW;
+    default:
+      return (0xFF);
+  }
+}
+
+
+tA2DP_STATUS A2dpCodecConfigLhdcV3::setCodecConfig(const uint8_t* p_peer_codec_info,
+                                           bool is_capability,
+                                           uint8_t* p_result_codec_config) {
+  std::lock_guard<std::recursive_mutex> lock(codec_mutex_);
+  tA2DP_LHDC_CIE sink_info_cie;
+  tA2DP_LHDC_CIE result_config_cie;
+  uint8_t sampleRate;
+  bool isLLEnabled;
+  bool hasFeature = false;
+  bool hasUserSet = false;
+  uint32_t quality_mode, maxBitRate_Qmode;
+  //uint8_t supportedBitrate;
+  btav_a2dp_codec_bits_per_sample_t bits_per_sample;
+
+  // Save the internal state
+  btav_a2dp_codec_config_t saved_codec_config = codec_config_;
+  btav_a2dp_codec_config_t saved_codec_capability = codec_capability_;
+  btav_a2dp_codec_config_t saved_codec_selectable_capability =
+      codec_selectable_capability_;
+  btav_a2dp_codec_config_t saved_codec_user_config = codec_user_config_;
+  btav_a2dp_codec_config_t saved_codec_audio_config = codec_audio_config_;
+  uint8_t saved_ota_codec_config[AVDT_CODEC_SIZE];
+  uint8_t saved_ota_codec_peer_capability[AVDT_CODEC_SIZE];
+  uint8_t saved_ota_codec_peer_config[AVDT_CODEC_SIZE];
+  memcpy(saved_ota_codec_config, ota_codec_config_, sizeof(ota_codec_config_));
+  memcpy(saved_ota_codec_peer_capability, ota_codec_peer_capability_,
+         sizeof(ota_codec_peer_capability_));
+  memcpy(saved_ota_codec_peer_config, ota_codec_peer_config_,
+         sizeof(ota_codec_peer_config_));
+
+  tA2DP_CODEC_CONFIGS_PACK allCfgPack;
+  allCfgPack._codec_config_ = &codec_config_;
+  allCfgPack._codec_capability_ = &codec_capability_;
+  allCfgPack._codec_local_capability_ = &codec_local_capability_;
+  allCfgPack._codec_selectable_capability_ = &codec_selectable_capability_;
+  allCfgPack._codec_user_config_ = &codec_user_config_;
+  allCfgPack._codec_audio_config_ = &codec_audio_config_;
+
+  tA2DP_STATUS status =
+      A2DP_ParseInfoLhdcV3(&sink_info_cie, p_peer_codec_info, is_capability);
+  if (status != A2DP_SUCCESS) {
+    log::error( " : can't parse peer's Sink capabilities: error = {}",
+               status);
+    goto fail;
+  }
+
+  //
+  // Build the preferred configuration
+  //
+  memset(&result_config_cie, 0, sizeof(result_config_cie));
+  result_config_cie.vendorId = a2dp_lhdc_source_caps.vendorId;
+  result_config_cie.codecId = a2dp_lhdc_source_caps.codecId;
+
+
+  log::info( ": incoming version: peer(0x{:02x}), host(0x{:02x})",sink_info_cie.version, a2dp_lhdc_source_caps.version);
+
+  // 2021/08/19: when sink's version is "V3_NotComapatible(version == A2DP_LHDC_VER6(0x8))",
+  //				wrap it to A2DP_LHDC_VER3 to accept and treat as an A2DP_LHDC_VER3 device.
+  if(sink_info_cie.version == A2DP_LHDC_VER6) {
+    sink_info_cie.version = A2DP_LHDC_VER3;
+    log::info( ": wrap V3_NotComapatible sink version to A2DP_LHDC_VER3");
+  }
+
+  if ((sink_info_cie.version & a2dp_lhdc_source_caps.version) == 0) {
+    log::error( " : Sink versoin unsupported! peer(0x{:02x}), host(0x{:02x})",
+               sink_info_cie.version, a2dp_lhdc_source_caps.version);
+      goto fail;
+  }
+  result_config_cie.version = sink_info_cie.version;
+
+  /*******************************************
+   * Update Capabilities: LHDC Low Latency
+   * to A2DP specifics 2
+   *******************************************/
+  isLLEnabled = (a2dp_lhdc_source_caps.isLLSupported & sink_info_cie.isLLSupported);
+  result_config_cie.isLLSupported = false;
+  switch (codec_user_config_.codec_specific_2 & A2DP_LHDC_LL_ENABLED) {
+    case A2DP_LHDC_LL_ENABLE:
+      if (isLLEnabled) {
+        result_config_cie.isLLSupported = true;
+        codec_config_.codec_specific_2 |= A2DP_LHDC_LL_ENABLED;
+      }
+      break;
+    case A2DP_LHDC_LL_DISABLE:
+      if (!isLLEnabled) {
+        result_config_cie.isLLSupported = false;
+        codec_config_.codec_specific_2 &= ~A2DP_LHDC_LL_ENABLED;
+      }
+      break;
+  }
+  if (isLLEnabled) {
+    codec_selectable_capability_.codec_specific_2 |= A2DP_LHDC_LL_ENABLED;
+    codec_capability_.codec_specific_2 |= A2DP_LHDC_LL_ENABLED;
+  }
+  //result_config_cie.isLLSupported = sink_info_cie.isLLSupported;
+  log::info( " : isLLSupported, Sink(0x{:02x}) Set(0x{:02x}), result(0x{:02x})",
+            sink_info_cie.isLLSupported,
+             (uint32_t)codec_user_config_.codec_specific_2,
+            result_config_cie.isLLSupported);
+
+  //
+  // Select the sample frequency
+  //
+  sampleRate = a2dp_lhdc_source_caps.sampleRate & sink_info_cie.sampleRate;
+  log::info(" : sampleRate:peer:0x{:02x} local:0x{:02x} cap:0x{:02x} user:0x{:02x}",
+             sink_info_cie.sampleRate, a2dp_lhdc_source_caps.sampleRate,
+            sampleRate, codec_user_config_.sample_rate);
+
+  codec_config_.sample_rate = BTAV_A2DP_CODEC_SAMPLE_RATE_NONE;
+  switch (codec_user_config_.sample_rate) {
+    case BTAV_A2DP_CODEC_SAMPLE_RATE_44100:
+      if (sampleRate & A2DP_LHDC_SAMPLING_FREQ_44100) {
+        result_config_cie.sampleRate = A2DP_LHDC_SAMPLING_FREQ_44100;
+        codec_capability_.sample_rate = codec_user_config_.sample_rate;
+        codec_config_.sample_rate = codec_user_config_.sample_rate;
+      }
+      break;
+    case BTAV_A2DP_CODEC_SAMPLE_RATE_48000:
+      if (sampleRate & A2DP_LHDC_SAMPLING_FREQ_48000) {
+        result_config_cie.sampleRate = A2DP_LHDC_SAMPLING_FREQ_48000;
+        codec_capability_.sample_rate = codec_user_config_.sample_rate;
+        codec_config_.sample_rate = codec_user_config_.sample_rate;
+      }
+      break;
+    case BTAV_A2DP_CODEC_SAMPLE_RATE_88200:
+      if (sampleRate & A2DP_LHDC_SAMPLING_FREQ_88200) {
+        result_config_cie.sampleRate = A2DP_LHDC_SAMPLING_FREQ_88200;
+        codec_capability_.sample_rate = codec_user_config_.sample_rate;
+        codec_config_.sample_rate = codec_user_config_.sample_rate;
+      }
+      break;
+    case BTAV_A2DP_CODEC_SAMPLE_RATE_96000:
+      if (sampleRate & A2DP_LHDC_SAMPLING_FREQ_96000) {
+        result_config_cie.sampleRate = A2DP_LHDC_SAMPLING_FREQ_96000;
+        codec_capability_.sample_rate = codec_user_config_.sample_rate;
+        codec_config_.sample_rate = codec_user_config_.sample_rate;
+      }
+      break;
+    case BTAV_A2DP_CODEC_SAMPLE_RATE_16000:
+    case BTAV_A2DP_CODEC_SAMPLE_RATE_24000:
+    case BTAV_A2DP_CODEC_SAMPLE_RATE_176400:
+    case BTAV_A2DP_CODEC_SAMPLE_RATE_192000:
+    case BTAV_A2DP_CODEC_SAMPLE_RATE_NONE:
+      codec_capability_.sample_rate = BTAV_A2DP_CODEC_SAMPLE_RATE_NONE;
+      codec_config_.sample_rate = BTAV_A2DP_CODEC_SAMPLE_RATE_NONE;
+      break;
+  }
+
+  // Select the sample frequency if there is no user preference
+  do {
+      // Compute the selectable capability
+      if (sampleRate & A2DP_LHDC_SAMPLING_FREQ_44100) {
+        codec_selectable_capability_.sample_rate |=
+            BTAV_A2DP_CODEC_SAMPLE_RATE_44100;
+      }
+      if (sampleRate & A2DP_LHDC_SAMPLING_FREQ_48000) {
+        codec_selectable_capability_.sample_rate |=
+            BTAV_A2DP_CODEC_SAMPLE_RATE_48000;
+      }
+      if (sampleRate & A2DP_LHDC_SAMPLING_FREQ_88200) {
+        codec_selectable_capability_.sample_rate |=
+            BTAV_A2DP_CODEC_SAMPLE_RATE_88200;
+      }
+      if (sampleRate & A2DP_LHDC_SAMPLING_FREQ_96000) {
+        codec_selectable_capability_.sample_rate |=
+            BTAV_A2DP_CODEC_SAMPLE_RATE_96000;
+      }
+
+      //Above Parts: if codec_config is setup successfully(ie., sampleRate in codec_user_config_ is valid), ignore following parts.
+      if (codec_config_.sample_rate != BTAV_A2DP_CODEC_SAMPLE_RATE_NONE) {
+        log::info( " : setup sample_rate:0x{:02x} from user_config", codec_config_.sample_rate);
+        break;
+      }
+      //Below Parts: if codec_config is still not setup successfully, test default sample rate or use the best match
+
+      // Compute the common capability
+      if (sampleRate & A2DP_LHDC_SAMPLING_FREQ_44100)
+        codec_capability_.sample_rate |= BTAV_A2DP_CODEC_SAMPLE_RATE_44100;
+      if (sampleRate & A2DP_LHDC_SAMPLING_FREQ_48000)
+        codec_capability_.sample_rate |= BTAV_A2DP_CODEC_SAMPLE_RATE_48000;
+      if (sampleRate & A2DP_LHDC_SAMPLING_FREQ_88200)
+        codec_capability_.sample_rate |= BTAV_A2DP_CODEC_SAMPLE_RATE_88200;
+      if (sampleRate & A2DP_LHDC_SAMPLING_FREQ_96000)
+        codec_capability_.sample_rate |= BTAV_A2DP_CODEC_SAMPLE_RATE_96000;
+
+      // No user preference - try the codec audio config
+      if (select_audio_sample_rate(&codec_audio_config_, sampleRate,
+                                   &result_config_cie, &codec_config_)) {
+          log::info( " : select audio sample rate:(0x{:02x})", result_config_cie.sampleRate);
+          break;
+      }
+
+      // No user preference - try the default config
+      if (sink_info_cie.hasFeatureLLAC) {
+        if (select_best_sample_rate(
+          a2dp_lhdc_default_config.llac_sampleRate & sink_info_cie.sampleRate,
+          &result_config_cie, &codec_config_)) {
+          log::info( " : select best sample rate(LLAC default):0x{:02x}", result_config_cie.sampleRate);
+          break;
+        }
+      } else {
+        if (select_best_sample_rate(
+          a2dp_lhdc_default_config.sampleRate & sink_info_cie.sampleRate,
+          &result_config_cie, &codec_config_)) {
+          log::info( " : select best sample rate(LHDC default):0x{:02x}", result_config_cie.sampleRate);
+          break;
+        }
+      }
+
+      // No user preference - use the best match
+      if (select_best_sample_rate(sampleRate, &result_config_cie,
+                                  &codec_config_)) {
+        log::info( " : select best sample rate(best):0x{:02x}", result_config_cie.sampleRate);
+        break;
+      }
+  } while (false);
+  if (codec_config_.sample_rate == BTAV_A2DP_CODEC_SAMPLE_RATE_NONE) {
+    log::error(
+        " : cannot match sample frequency: source caps = 0x{:02x} "
+        "sink info = 0x{:02x}",
+        a2dp_lhdc_source_caps.sampleRate, sink_info_cie.sampleRate);
+    goto fail;
+  } 
+  codec_user_config_.sample_rate = codec_config_.sample_rate;
+  log::info( " : => sample rate(0x{:02x}) = {} ",
+             result_config_cie.sampleRate,
+             lhdcV3_sampleRate_toString(result_config_cie.sampleRate).c_str());
+
+  ///
+  // Select the bits per sample
+  //
+  // NOTE: this information is NOT included in the LHDC A2DP codec description
+  // that is sent OTA.
+  bits_per_sample = a2dp_lhdc_source_caps.bits_per_sample & sink_info_cie.bits_per_sample;
+  log::info("bits_per_sample:peer:0x{:02x} local:0x{:02x} cap:0x{:02x} user:0x{:02x}",
+           sink_info_cie.bits_per_sample, a2dp_lhdc_source_caps.bits_per_sample,
+            bits_per_sample, codec_user_config_.bits_per_sample);
+  codec_config_.bits_per_sample = BTAV_A2DP_CODEC_BITS_PER_SAMPLE_NONE;
+  switch (codec_user_config_.bits_per_sample) {
+    case BTAV_A2DP_CODEC_BITS_PER_SAMPLE_16:
+      if (bits_per_sample & BTAV_A2DP_CODEC_BITS_PER_SAMPLE_16) {
+        result_config_cie.bits_per_sample = BTAV_A2DP_CODEC_BITS_PER_SAMPLE_16;
+        codec_capability_.bits_per_sample = codec_user_config_.bits_per_sample;
+        codec_config_.bits_per_sample = codec_user_config_.bits_per_sample;
+      }
+      break;
+    case BTAV_A2DP_CODEC_BITS_PER_SAMPLE_24:
+      if (bits_per_sample & BTAV_A2DP_CODEC_BITS_PER_SAMPLE_24) {
+        result_config_cie.bits_per_sample = BTAV_A2DP_CODEC_BITS_PER_SAMPLE_24;
+        codec_capability_.bits_per_sample = codec_user_config_.bits_per_sample;
+        codec_config_.bits_per_sample = codec_user_config_.bits_per_sample;
+      }
+      break;
+    case BTAV_A2DP_CODEC_BITS_PER_SAMPLE_32:
+    case BTAV_A2DP_CODEC_BITS_PER_SAMPLE_NONE:
+      result_config_cie.bits_per_sample = BTAV_A2DP_CODEC_BITS_PER_SAMPLE_NONE;
+      codec_capability_.bits_per_sample = BTAV_A2DP_CODEC_BITS_PER_SAMPLE_NONE;
+      codec_config_.bits_per_sample = BTAV_A2DP_CODEC_BITS_PER_SAMPLE_NONE;
+      break;
+  }
+
+  // Select the bits per sample if there is no user preference
+  do {
+      // Compute the selectable capability
+      // Compute the selectable capability
+      if (bits_per_sample & BTAV_A2DP_CODEC_BITS_PER_SAMPLE_16)
+        codec_selectable_capability_.bits_per_sample |= BTAV_A2DP_CODEC_BITS_PER_SAMPLE_16;
+      if (bits_per_sample & BTAV_A2DP_CODEC_BITS_PER_SAMPLE_24)
+        codec_selectable_capability_.bits_per_sample |= BTAV_A2DP_CODEC_BITS_PER_SAMPLE_24;
+
+      if (codec_config_.bits_per_sample != BTAV_A2DP_CODEC_BITS_PER_SAMPLE_NONE){
+        log::info( " : setup bit_per_sample:0x{:02x} user_config", codec_config_.bits_per_sample);
+        break;
+      }
+
+      // Compute the common capability
+      if (bits_per_sample & BTAV_A2DP_CODEC_BITS_PER_SAMPLE_16)
+        codec_capability_.bits_per_sample |= BTAV_A2DP_CODEC_BITS_PER_SAMPLE_16;
+      if (bits_per_sample & BTAV_A2DP_CODEC_BITS_PER_SAMPLE_24)
+        codec_capability_.bits_per_sample |= BTAV_A2DP_CODEC_BITS_PER_SAMPLE_24;
+
+      // No user preference - the the codec audio config
+      if (select_audio_bits_per_sample(&codec_audio_config_, bits_per_sample,
+                                       &result_config_cie, &codec_config_)) {
+        log::info( " : select audio bits_per_sample:0x{:02x}", result_config_cie.bits_per_sample);
+        break;
+      }
+
+      // No user preference - try the default config
+      if (select_best_bits_per_sample(a2dp_lhdc_default_config.bits_per_sample & sink_info_cie.bits_per_sample,
+                                      &result_config_cie, &codec_config_)) {
+        log::info( " : select best bits_per_sample(default):0x{:02x}", result_config_cie.bits_per_sample);
+        break;
+      }
+
+      // No user preference - use the best match
+      if (select_best_bits_per_sample(bits_per_sample,
+                                      &result_config_cie, &codec_config_)) {
+        log::info( " : select best bits_per_sample(best):0x{:02x}", result_config_cie.bits_per_sample);
+        break;
+      }
+  } while (false);
+  if (codec_config_.bits_per_sample == BTAV_A2DP_CODEC_BITS_PER_SAMPLE_NONE) {
+    log::error(
+        " : cannot match bits per sample: default = 0x{:02x} "
+        "user preference = 0x{:02x}",
+        a2dp_lhdc_default_config.bits_per_sample,
+        codec_user_config_.bits_per_sample);
+    goto fail;
+  }
+  codec_user_config_.bits_per_sample = codec_config_.bits_per_sample;
+  log::info( " : => bit per sample(0x{:02x}) = {}",
+             result_config_cie.bits_per_sample,
+             lhdcV3_bitPerSample_toString(result_config_cie.bits_per_sample).c_str());
+
+  //
+  // Select the channel mode
+  //
+  log::info( " : channelMode = Only supported stereo");
+  codec_config_.channel_mode = BTAV_A2DP_CODEC_CHANNEL_MODE_NONE;
+  switch (codec_user_config_.channel_mode) {
+    case BTAV_A2DP_CODEC_CHANNEL_MODE_STEREO:
+      codec_capability_.channel_mode = codec_user_config_.channel_mode;
+      codec_config_.channel_mode = codec_user_config_.channel_mode;
+      break;
+    case BTAV_A2DP_CODEC_CHANNEL_MODE_MONO:
+    case BTAV_A2DP_CODEC_CHANNEL_MODE_NONE:
+      codec_capability_.channel_mode = BTAV_A2DP_CODEC_CHANNEL_MODE_NONE;
+      codec_config_.channel_mode = BTAV_A2DP_CODEC_CHANNEL_MODE_NONE;
+      break;
+  }
+  codec_selectable_capability_.channel_mode = BTAV_A2DP_CODEC_CHANNEL_MODE_STEREO;
+  codec_capability_.channel_mode = BTAV_A2DP_CODEC_CHANNEL_MODE_STEREO;
+  codec_config_.channel_mode = BTAV_A2DP_CODEC_CHANNEL_MODE_STEREO;
+  if (codec_config_.channel_mode == BTAV_A2DP_CODEC_CHANNEL_MODE_NONE) {
+    log::error(" : codec_config_.channel_mode != BTAV_A2DP_CODEC_CHANNEL_MODE_NONE or BTAV_A2DP_CODEC_CHANNEL_MODE_STEREO"
+        );
+    goto fail;
+  }
+
+  /*******************************************
+   * Update maxTargetBitrate
+   *
+   *******************************************/
+  result_config_cie.maxTargetBitrate = sink_info_cie.maxTargetBitrate;
+
+  log::info( " : Config Max bitrate result(0x{:02x})", result_config_cie.maxTargetBitrate);
+
+  /*******************************************
+   * Update channelSplitMode
+   *
+   *******************************************/
+  result_config_cie.channelSplitMode = sink_info_cie.channelSplitMode;
+  log::info(" : channelSplitMode = {}", result_config_cie.channelSplitMode);
+
+
+  /*******************************************
+   * quality mode: magic num check and reconfigure
+   * to specific 1
+   *******************************************/
+  if ((codec_user_config_.codec_specific_1 & A2DP_LHDC_VENDOR_CMD_MASK) != A2DP_LHDC_QUALITY_MAGIC_NUM) {
+    codec_user_config_.codec_specific_1 &= ~(A2DP_LHDC_VENDOR_CMD_MASK | A2DP_LHDC_QUALITY_MASK);
+    codec_user_config_.codec_specific_1 |= (A2DP_LHDC_QUALITY_MAGIC_NUM | A2DP_LHDC_QUALITY_ABR);
+    log::info(" : tag not match, use default Quality Mode: ABR");
+  }
+  quality_mode = codec_user_config_.codec_specific_1 & A2DP_LHDC_QUALITY_MASK;
+
+  // bitrate 1000Kbps is not supported in LHDCV3, change to lower 900Kbps
+  if (quality_mode == A2DP_LHDC_QUALITY_HIGH1) {
+    codec_user_config_.codec_specific_1 &= ~(A2DP_LHDC_VENDOR_CMD_MASK | A2DP_LHDC_QUALITY_MASK);
+    codec_user_config_.codec_specific_1 |= (A2DP_LHDC_QUALITY_MAGIC_NUM | A2DP_LHDC_QUALITY_HIGH);
+    quality_mode = A2DP_LHDC_QUALITY_HIGH;
+    log::info(" : reset non-supported quality_mode to  ",
+              lhdcV3_QualityModeBitRate_toString(quality_mode).c_str());
+  }
+
+  /*******************************************
+   * LHDC features: safety tag check
+   * to specific 3
+   *******************************************/
+  if ((codec_user_config_.codec_specific_3 & A2DP_LHDC_VENDOR_FEATURE_MASK) != A2DP_LHDC_FEATURE_MAGIC_NUM) {
+    log::info( " : LHDC feature tag not matched! use old feature settings");
+
+    /* *
+     * Magic num does not match:
+     * 1. add tag
+     * 2. Re-adjust previous feature(which refers to codec_user_config)'s state(in codec_config_) to codec_user_config_:
+     * 	AR(has UI)
+     * */
+    // clean entire specific and set safety tag
+    codec_user_config_.codec_specific_3 = A2DP_LHDC_FEATURE_MAGIC_NUM;
+
+    // Feature: AR
+    hasUserSet = A2DP_IsFeatureInCodecConfigLhdcV3(&allCfgPack, LHDC_EXTEND_FUNC_A2DP_LHDC_AR_CODE);
+    A2DP_UpdateFeatureToA2dpConfigLhdcV3(
+        &allCfgPack,
+        LHDC_EXTEND_FUNC_A2DP_LHDC_AR_CODE,
+        A2DP_LHDC_TO_A2DP_CODEC_USER_,
+        (hasUserSet?true:false));
+    log::info( " : LHDC features tag check fail, reset UI status[AR] =>  {}", hasUserSet?"true":"false");
+  }
+
+  /*******************************************
+   *  LLAC: caps-control enabling
+   *******************************************/
+  {
+    hasFeature = (a2dp_lhdc_source_caps.hasFeatureLLAC & sink_info_cie.hasFeatureLLAC);
+    result_config_cie.hasFeatureLLAC = false;
+    hasUserSet = true;  //caps-control enabling case => always true
+
+    A2DP_UpdateFeatureToA2dpConfigLhdcV3(
+        &allCfgPack,
+        LHDC_EXTEND_FUNC_A2DP_LHDC_LLAC_CODE,
+        (A2DP_LHDC_TO_A2DP_CODEC_CONFIG_| A2DP_LHDC_TO_A2DP_CODEC_CAP_ |
+            A2DP_LHDC_TO_A2DP_CODEC_SELECT_CAP_ | A2DP_LHDC_TO_A2DP_CODEC_USER_),
+            false);
+
+    if (hasFeature && hasUserSet) {
+      result_config_cie.hasFeatureLLAC = true;
+      A2DP_UpdateFeatureToA2dpConfigLhdcV3(
+          &allCfgPack,
+          LHDC_EXTEND_FUNC_A2DP_LHDC_LLAC_CODE,
+          (A2DP_LHDC_TO_A2DP_CODEC_CAP_ |
+              A2DP_LHDC_TO_A2DP_CODEC_SELECT_CAP_ | A2DP_LHDC_TO_A2DP_CODEC_USER_),
+              true);
+    }
+    log::info("featureLLAC: enabled? <{}> Peer:0x{:02x} Local:0x{:02x}",
+               (result_config_cie.hasFeatureLLAC?"Y":"N"),
+               sink_info_cie.hasFeatureLLAC,
+               a2dp_lhdc_source_caps.hasFeatureLLAC);
+  }
+
+  /*******************************************
+   *  LHDCV4: caps-control enabling
+   *******************************************/
+  {
+    hasFeature = (a2dp_lhdc_source_caps.hasFeatureLHDCV4 & sink_info_cie.hasFeatureLHDCV4);
+    result_config_cie.hasFeatureLHDCV4 = false;
+    hasUserSet = true;  //caps-control enabling case => always true
+
+    A2DP_UpdateFeatureToA2dpConfigLhdcV3(
+        &allCfgPack,
+        LHDC_EXTEND_FUNC_A2DP_LHDC_V4_CODE,
+        (A2DP_LHDC_TO_A2DP_CODEC_CONFIG_| A2DP_LHDC_TO_A2DP_CODEC_CAP_ |
+            A2DP_LHDC_TO_A2DP_CODEC_SELECT_CAP_ | A2DP_LHDC_TO_A2DP_CODEC_USER_),
+            false);
+
+    if (hasFeature && hasUserSet) {
+      result_config_cie.hasFeatureLHDCV4 = true;
+      A2DP_UpdateFeatureToA2dpConfigLhdcV3(
+          &allCfgPack,
+          LHDC_EXTEND_FUNC_A2DP_LHDC_V4_CODE,
+          (A2DP_LHDC_TO_A2DP_CODEC_CAP_ |
+              A2DP_LHDC_TO_A2DP_CODEC_SELECT_CAP_ | A2DP_LHDC_TO_A2DP_CODEC_USER_),
+              true);
+    }
+    log::info("featureV4: enabled? <{}> Peer:0x{:02x} Local:0x{:02x}",
+               (result_config_cie.hasFeatureLHDCV4?"Y":"N"),
+               sink_info_cie.hasFeatureLHDCV4,
+               a2dp_lhdc_source_caps.hasFeatureLHDCV4);
+  }
+
+  /*******************************************
+   *  JAS: caps-control enabling
+   *******************************************/
+  {
+    //result_config_cie.hasFeatureJAS = sink_info_cie.hasFeatureJAS;
+    hasFeature = (a2dp_lhdc_source_caps.hasFeatureJAS & sink_info_cie.hasFeatureJAS);
+    result_config_cie.hasFeatureJAS = false;
+    hasUserSet = true;  //caps-control enabling case => always true
+
+    A2DP_UpdateFeatureToA2dpConfigLhdcV3(
+        &allCfgPack,
+        LHDC_EXTEND_FUNC_A2DP_LHDC_JAS_CODE,
+        (A2DP_LHDC_TO_A2DP_CODEC_CONFIG_| A2DP_LHDC_TO_A2DP_CODEC_CAP_ |
+            A2DP_LHDC_TO_A2DP_CODEC_SELECT_CAP_ | A2DP_LHDC_TO_A2DP_CODEC_USER_),
+            false);
+
+    if (hasFeature && hasUserSet) {
+      result_config_cie.hasFeatureJAS = true;
+      A2DP_UpdateFeatureToA2dpConfigLhdcV3(
+          &allCfgPack,
+          LHDC_EXTEND_FUNC_A2DP_LHDC_JAS_CODE,
+          (A2DP_LHDC_TO_A2DP_CODEC_CAP_ |
+              A2DP_LHDC_TO_A2DP_CODEC_SELECT_CAP_ | A2DP_LHDC_TO_A2DP_CODEC_USER_),
+              true);
+    }
+   log::info("featureJAS: enabled? <{}> Peer:0x{:02x} Local:0x{:02x}",
+               (result_config_cie.hasFeatureJAS?"Y":"N"),
+               sink_info_cie.hasFeatureJAS,
+               a2dp_lhdc_source_caps.hasFeatureJAS);
+  }
+
+  /*******************************************
+   * AR: user-control control enabling
+   *******************************************/
+  {
+    hasFeature = (a2dp_lhdc_source_caps.hasFeatureAR & sink_info_cie.hasFeatureAR);
+    result_config_cie.hasFeatureAR = false;
+    hasUserSet = A2DP_IsFeatureInUserConfigLhdcV3(&allCfgPack, LHDC_EXTEND_FUNC_A2DP_LHDC_AR_CODE);
+
+    A2DP_UpdateFeatureToA2dpConfigLhdcV3(
+        &allCfgPack,
+        LHDC_EXTEND_FUNC_A2DP_LHDC_AR_CODE,
+        (A2DP_LHDC_TO_A2DP_CODEC_CONFIG_ | A2DP_LHDC_TO_A2DP_CODEC_CAP_ |
+            A2DP_LHDC_TO_A2DP_CODEC_SELECT_CAP_ | A2DP_LHDC_TO_A2DP_CODEC_USER_),
+            false);
+
+    if (hasFeature && hasUserSet) {
+      result_config_cie.hasFeatureAR = true;
+      A2DP_UpdateFeatureToA2dpConfigLhdcV3(
+          &allCfgPack,
+          LHDC_EXTEND_FUNC_A2DP_LHDC_AR_CODE,
+          (A2DP_LHDC_TO_A2DP_CODEC_CAP_ |
+              A2DP_LHDC_TO_A2DP_CODEC_SELECT_CAP_ | A2DP_LHDC_TO_A2DP_CODEC_USER_),
+              true);
+
+      /* Special Rule: AR only enable at the the sample rate of 48KHz */
+      if(codec_user_config_.sample_rate > BTAV_A2DP_CODEC_SAMPLE_RATE_48000) {
+          log::info( " : AR ON, adjust sample rate to 48KHz  ");
+          codec_config_.sample_rate = BTAV_A2DP_CODEC_SAMPLE_RATE_48000;
+          codec_user_config_.sample_rate = BTAV_A2DP_CODEC_SAMPLE_RATE_48000;
+          result_config_cie.sampleRate = A2DP_LHDC_SAMPLING_FREQ_48000;
+      }
+    }
+    log::info(":featureAR: enabled? <{}> Peer:0x{:02x} Local:0x{:02x} User:{}",
+               (result_config_cie.hasFeatureAR?"Y":"N"),
+               sink_info_cie.hasFeatureAR,
+               a2dp_lhdc_source_caps.hasFeatureAR,
+               (hasUserSet?"Y":"N"));
+  }
+
+  /*******************************************
+   * META: caps-control enabling
+   *******************************************/
+  {
+    hasFeature = (a2dp_lhdc_source_caps.hasFeatureMETA & sink_info_cie.hasFeatureMETA);
+    result_config_cie.hasFeatureMETA = false;
+    hasUserSet = true;  //caps-control enabling, always true
+
+    A2DP_UpdateFeatureToA2dpConfigLhdcV3(
+        &allCfgPack,
+        LHDC_EXTEND_FUNC_A2DP_LHDC_META_CODE,
+        (A2DP_LHDC_TO_A2DP_CODEC_CONFIG_ | A2DP_LHDC_TO_A2DP_CODEC_CAP_ |
+            A2DP_LHDC_TO_A2DP_CODEC_SELECT_CAP_ | A2DP_LHDC_TO_A2DP_CODEC_USER_),
+            false);
+    // update
+    if (hasFeature && hasUserSet) {
+      result_config_cie.hasFeatureMETA = true;
+      A2DP_UpdateFeatureToA2dpConfigLhdcV3(
+          &allCfgPack,
+          LHDC_EXTEND_FUNC_A2DP_LHDC_META_CODE,
+          (A2DP_LHDC_TO_A2DP_CODEC_CAP_ |
+              A2DP_LHDC_TO_A2DP_CODEC_SELECT_CAP_ | A2DP_LHDC_TO_A2DP_CODEC_USER_),
+              true);
+    }
+   log::info("featureMETA: enabled? <{}> Peer:0x{:02x} Local:0x{:02x}",
+               (result_config_cie.hasFeatureMETA?"Y":"N"),
+               sink_info_cie.hasFeatureMETA,
+               a2dp_lhdc_source_caps.hasFeatureMETA);
+  }
+
+  /*******************************************
+   * Min BitRate (MBR): caps-control enabling
+   *******************************************/
+  {
+    hasFeature = (a2dp_lhdc_source_caps.hasFeatureMinBitrate & sink_info_cie.hasFeatureMinBitrate);
+    result_config_cie.hasFeatureMinBitrate = false;
+    hasUserSet = true;  //caps-control enabling, always true
+
+    A2DP_UpdateFeatureToA2dpConfigLhdcV3(
+        &allCfgPack,
+        LHDC_EXTEND_FUNC_A2DP_LHDC_MBR_CODE,
+        (A2DP_LHDC_TO_A2DP_CODEC_CONFIG_ | A2DP_LHDC_TO_A2DP_CODEC_CAP_ |
+            A2DP_LHDC_TO_A2DP_CODEC_SELECT_CAP_ | A2DP_LHDC_TO_A2DP_CODEC_USER_),
+            false);
+    // update
+    if (hasFeature && hasUserSet) {
+      result_config_cie.hasFeatureMinBitrate = true;
+      A2DP_UpdateFeatureToA2dpConfigLhdcV3(
+          &allCfgPack,
+          LHDC_EXTEND_FUNC_A2DP_LHDC_MBR_CODE,
+          (A2DP_LHDC_TO_A2DP_CODEC_CAP_ |
+              A2DP_LHDC_TO_A2DP_CODEC_SELECT_CAP_ | A2DP_LHDC_TO_A2DP_CODEC_USER_),
+              true);
+    }
+    log::info("featureMBR: enabled? <{}> Peer:0x{:02x} Local:0x{:02x}",
+               (result_config_cie.hasFeatureMinBitrate?"Y":"N"),
+               sink_info_cie.hasFeatureMinBitrate,
+               a2dp_lhdc_source_caps.hasFeatureMinBitrate);
+  }
+
+  /*******************************************
+   * Update Feature/Capabilities: LARC
+   * to A2DP specifics
+   *******************************************/
+  // LARC is not supported
+
+  log::info(" : current quality_mode = 0x{:02x}", quality_mode);
+  log::info(" : current peer max bitrate = 0x{:02x}", result_config_cie.maxTargetBitrate);
+
+  /*******************************************
+   * quality mode: re-adjust according to maxTargetBitrate(smaller one adopted)
+   *******************************************/
+  if ((result_config_cie.hasFeatureLHDCV4) &&
+      (result_config_cie.sampleRate == A2DP_LHDC_SAMPLING_FREQ_96000)) {
+      // special case: if V4 and 96KHz, max bitrate becomes not effective
+      result_config_cie.maxTargetBitrate = A2DP_LHDC_MAX_BIT_RATE_900K;
+      log::info(" : [V4]: 96KHz, disable effect of max bitrate");
+  } else {
+    // normal case: bitrate configuration will be limited by peer max bitrate
+    maxBitRate_Qmode = A2DP_MaxBitRatetoQualityLevelLhdcV3(result_config_cie.maxTargetBitrate);
+    if(maxBitRate_Qmode != 0xff) {
+      if(quality_mode != A2DP_LHDC_QUALITY_ABR && quality_mode > maxBitRate_Qmode) {
+          log::info(" : adjust quality_mode:0x{:02x} to 0x{:02x} by maxTargetBitrate:0x{:02x}",
+                    quality_mode, maxBitRate_Qmode, result_config_cie.maxTargetBitrate);
+          quality_mode = maxBitRate_Qmode;
+          codec_user_config_.codec_specific_1 &= ~(A2DP_LHDC_VENDOR_CMD_MASK | A2DP_LHDC_QUALITY_MASK);
+          codec_user_config_.codec_specific_1 |= (A2DP_LHDC_QUALITY_MAGIC_NUM | quality_mode);
+      }
+    }
+  }
+
+
+  /*******************************************
+   * Update LHDC Peer Max Bitrate Index to specific 1
+   *******************************************/
+  // store peer cap: max target bitrate index for UI reference
+  codec_user_config_.codec_specific_1 &= ~(A2DP_LHDC_PEER_MAX_BITRATE_MASK);
+  switch(result_config_cie.maxTargetBitrate)
+  {
+    case A2DP_LHDC_MAX_BIT_RATE_400K:
+      {
+        codec_user_config_.codec_specific_1 |= (A2DP_LHDC_MAX_BIT_RATE_400K << 4);
+        break;
+      }
+    case A2DP_LHDC_MAX_BIT_RATE_500K:
+      {
+        codec_user_config_.codec_specific_1 |= (A2DP_LHDC_MAX_BIT_RATE_500K << 4);
+        break;
+      }
+    case A2DP_LHDC_MAX_BIT_RATE_900K:
+      {
+        codec_user_config_.codec_specific_1 |= (A2DP_LHDC_MAX_BIT_RATE_900K << 4);
+        break;
+      }
+  }
+
+  /*******************************************
+   * Update LHDC Peer Min Bitrate ON/OFF to specific 1
+   *******************************************/
+  // store peer cap: min bitrate mode on/off for UI reference
+  codec_user_config_.codec_specific_1 &= ~(A2DP_LHDC_PEER_MIN_BITRATE_MASK);
+  if (result_config_cie.hasFeatureMinBitrate == true) {
+    codec_user_config_.codec_specific_1 |= A2DP_LHDC_PEER_MIN_BITRATE_ON;
+  }
+
+  /*******************************************
+   * Update capabilities: V4, LLAC to specific 1
+   *******************************************/
+  // store peer cap: max target bitrate index for UI reference
+  codec_user_config_.codec_specific_1 &= ~(A2DP_LHDC_CAP_V4_LLAC_MASK);
+  if (result_config_cie.hasFeatureLLAC && result_config_cie.hasFeatureLHDCV4) {
+    codec_user_config_.codec_specific_1 |= A2DP_LHDC_CAP_V4_LLAC;
+  } else if (!result_config_cie.hasFeatureLLAC && result_config_cie.hasFeatureLHDCV4) {
+    codec_user_config_.codec_specific_1 |= A2DP_LHDC_CAP_V4_ONLY;
+  } else if (result_config_cie.hasFeatureLLAC && !result_config_cie.hasFeatureLHDCV4) {
+    codec_user_config_.codec_specific_1 |= A2DP_LHDC_CAP_LLAC_ONLY;
+  } else {
+    codec_user_config_.codec_specific_1 |= A2DP_LHDC_CAP_V3_ONLY;
+  }
+
+
+  /*
+   * Final Custom Rules of resolving conflict between capabilities and version
+   */
+  if (result_config_cie.hasFeatureLLAC && result_config_cie.hasFeatureLHDCV4) {
+    //LHDCV4 + LLAC
+    if (result_config_cie.sampleRate == A2DP_LHDC_SAMPLING_FREQ_96000) {
+      // V4 96KHz does not support ABR, quality mode must be fixed bitrate
+      // 1. if ABR is selected, change it to the fixed bitrate LOW
+      if (quality_mode == A2DP_LHDC_QUALITY_ABR) {
+        codec_user_config_.codec_specific_1 &= ~(A2DP_LHDC_VENDOR_CMD_MASK | A2DP_LHDC_QUALITY_MASK);
+        codec_user_config_.codec_specific_1 |= (A2DP_LHDC_QUALITY_MAGIC_NUM | A2DP_LHDC_QUALITY_LOW);
+        quality_mode = A2DP_LHDC_QUALITY_LOW;
+      }
+
+      // 2. up-leveling by peer min bitrate
+      if (result_config_cie.hasFeatureMinBitrate) {
+        if (quality_mode < A2DP_LHDC_QUALITY_MID) {
+          codec_user_config_.codec_specific_1 &= ~(A2DP_LHDC_VENDOR_CMD_MASK | A2DP_LHDC_QUALITY_MASK);
+          codec_user_config_.codec_specific_1 |= (A2DP_LHDC_QUALITY_MAGIC_NUM | A2DP_LHDC_QUALITY_MID);
+          quality_mode = A2DP_LHDC_QUALITY_MID;
+        }
+      } else {
+        if (quality_mode < A2DP_LHDC_QUALITY_LOW) {
+          codec_user_config_.codec_specific_1 &= ~(A2DP_LHDC_VENDOR_CMD_MASK | A2DP_LHDC_QUALITY_MASK);
+          codec_user_config_.codec_specific_1 |= (A2DP_LHDC_QUALITY_MAGIC_NUM | A2DP_LHDC_QUALITY_LOW);
+          quality_mode = A2DP_LHDC_QUALITY_LOW;
+        }
+      }
+
+      // 3. down-leveling by peer max bitrate
+      if (result_config_cie.maxTargetBitrate == A2DP_LHDC_MAX_BIT_RATE_500K) {
+        //maxTargetBitrate == 500kbps
+        if (quality_mode > A2DP_LHDC_QUALITY_MID) {
+          codec_user_config_.codec_specific_1 &= ~(A2DP_LHDC_VENDOR_CMD_MASK | A2DP_LHDC_QUALITY_MASK);
+          codec_user_config_.codec_specific_1 |= (A2DP_LHDC_QUALITY_MAGIC_NUM | A2DP_LHDC_QUALITY_MID);
+          quality_mode = A2DP_LHDC_QUALITY_MID;
+        }
+      } else if (result_config_cie.maxTargetBitrate == A2DP_LHDC_MAX_BIT_RATE_400K) {
+        //maxTargetBitrate == 400kbps
+        if (quality_mode > A2DP_LHDC_QUALITY_LOW) {
+          codec_user_config_.codec_specific_1 &= ~(A2DP_LHDC_VENDOR_CMD_MASK | A2DP_LHDC_QUALITY_MASK);
+          codec_user_config_.codec_specific_1 |= (A2DP_LHDC_QUALITY_MAGIC_NUM | A2DP_LHDC_QUALITY_LOW);
+          quality_mode = A2DP_LHDC_QUALITY_LOW;
+        }
+      } else {
+        // 900kbps dont'care
+      }
+
+      result_config_cie.hasFeatureLLAC = false;
+      codec_config_.codec_specific_3 &= ~A2DP_LHDC_LLAC_ENABLED;
+
+      log::info(" : [LLAC + LHDC V4]: LHDCV4, SR(0x{:02x}) Qmode(0x{:02x})", result_config_cie.sampleRate, quality_mode);
+    } else if (
+        (result_config_cie.sampleRate == A2DP_LHDC_SAMPLING_FREQ_48000 && (quality_mode > A2DP_LHDC_QUALITY_LOW && quality_mode != A2DP_LHDC_QUALITY_ABR)) ||
+        (result_config_cie.sampleRate == A2DP_LHDC_SAMPLING_FREQ_44100 && (quality_mode > A2DP_LHDC_QUALITY_LOW && quality_mode != A2DP_LHDC_QUALITY_ABR))
+    ) {
+      result_config_cie.hasFeatureLLAC = false;
+      codec_config_.codec_specific_3 &= ~A2DP_LHDC_LLAC_ENABLED;
+      log::info(" : [LLAC + LHDC V4]: LHDCV4, SR(0x{:02x}) Qmode(0x{:02x})", result_config_cie.sampleRate, quality_mode);
+    } else if (
+        (result_config_cie.sampleRate == A2DP_LHDC_SAMPLING_FREQ_48000 && (quality_mode <= A2DP_LHDC_QUALITY_LOW || quality_mode == A2DP_LHDC_QUALITY_ABR)) ||
+        (result_config_cie.sampleRate == A2DP_LHDC_SAMPLING_FREQ_44100 && (quality_mode <= A2DP_LHDC_QUALITY_LOW || quality_mode == A2DP_LHDC_QUALITY_ABR))
+    ) {
+      result_config_cie.hasFeatureLHDCV4 = false;
+      codec_config_.codec_specific_3 &= ~A2DP_LHDC_V4_ENABLED;
+
+      /* LLAC: prevent quality mode using 64kbps */
+      if (result_config_cie.hasFeatureMinBitrate) {
+        if (quality_mode < A2DP_LHDC_QUALITY_LOW1) {
+          codec_user_config_.codec_specific_1 &= ~(A2DP_LHDC_VENDOR_CMD_MASK | A2DP_LHDC_QUALITY_MASK);
+          codec_user_config_.codec_specific_1 |= (A2DP_LHDC_QUALITY_MAGIC_NUM | A2DP_LHDC_QUALITY_LOW1);
+          quality_mode = A2DP_LHDC_QUALITY_LOW1;
+        }
+      }
+      log::info(" : [LLAC + LHDC V4]: LLAC, SR(0x{:02x}) Qmode(0x{:02x})", result_config_cie.sampleRate, quality_mode);
+    } else {
+      log::error(" : [LLAC + LHDC V4]: format incorrect.");
+      goto fail;
+    }
+  } else if (!result_config_cie.hasFeatureLLAC && result_config_cie.hasFeatureLHDCV4) {
+    //LHDC V4 only
+    if (result_config_cie.sampleRate == A2DP_LHDC_SAMPLING_FREQ_96000) {
+      // V4 96KHz does not support ABR, quality mode must be fixed bitrate
+      // 1. if ABR is selected, change it to the fixed bitrate LOW
+      if (quality_mode == A2DP_LHDC_QUALITY_ABR) {
+        codec_user_config_.codec_specific_1 &= ~(A2DP_LHDC_VENDOR_CMD_MASK | A2DP_LHDC_QUALITY_MASK);
+        codec_user_config_.codec_specific_1 |= (A2DP_LHDC_QUALITY_MAGIC_NUM | A2DP_LHDC_QUALITY_LOW);
+        quality_mode = A2DP_LHDC_QUALITY_LOW;
+      }
+
+      // 2. up-leveling by peer min bitrate
+      if (result_config_cie.hasFeatureMinBitrate) {
+        if (quality_mode < A2DP_LHDC_QUALITY_MID) {
+          codec_user_config_.codec_specific_1 &= ~(A2DP_LHDC_VENDOR_CMD_MASK | A2DP_LHDC_QUALITY_MASK);
+          codec_user_config_.codec_specific_1 |= (A2DP_LHDC_QUALITY_MAGIC_NUM | A2DP_LHDC_QUALITY_MID);
+          quality_mode = A2DP_LHDC_QUALITY_MID;
+        }
+      } else {
+        if (quality_mode < A2DP_LHDC_QUALITY_LOW) {
+          codec_user_config_.codec_specific_1 &= ~(A2DP_LHDC_VENDOR_CMD_MASK | A2DP_LHDC_QUALITY_MASK);
+          codec_user_config_.codec_specific_1 |= (A2DP_LHDC_QUALITY_MAGIC_NUM | A2DP_LHDC_QUALITY_LOW);
+          quality_mode = A2DP_LHDC_QUALITY_LOW;
+        }
+      }
+
+      // 3. down-leveling by peer max bitrate
+      if (result_config_cie.maxTargetBitrate == A2DP_LHDC_MAX_BIT_RATE_500K) {
+        //maxTargetBitrate == 500kbps
+        if (quality_mode > A2DP_LHDC_QUALITY_MID) {
+          codec_user_config_.codec_specific_1 &= ~(A2DP_LHDC_VENDOR_CMD_MASK | A2DP_LHDC_QUALITY_MASK);
+          codec_user_config_.codec_specific_1 |= (A2DP_LHDC_QUALITY_MAGIC_NUM | A2DP_LHDC_QUALITY_MID);
+          quality_mode = A2DP_LHDC_QUALITY_MID;
+        }
+      } else if (result_config_cie.maxTargetBitrate == A2DP_LHDC_MAX_BIT_RATE_400K) {
+        //maxTargetBitrate == 400kbps
+        if (quality_mode > A2DP_LHDC_QUALITY_LOW) {
+          codec_user_config_.codec_specific_1 &= ~(A2DP_LHDC_VENDOR_CMD_MASK | A2DP_LHDC_QUALITY_MASK);
+          codec_user_config_.codec_specific_1 |= (A2DP_LHDC_QUALITY_MAGIC_NUM | A2DP_LHDC_QUALITY_LOW);
+          quality_mode = A2DP_LHDC_QUALITY_LOW;
+        }
+      } else {
+        // 900kbps dont'care
+      }
+    } else {
+      if (result_config_cie.hasFeatureMinBitrate) {
+        if (quality_mode < A2DP_LHDC_QUALITY_LOW4) {
+          codec_user_config_.codec_specific_1 &= ~(A2DP_LHDC_VENDOR_CMD_MASK | A2DP_LHDC_QUALITY_MASK);
+          codec_user_config_.codec_specific_1 |= (A2DP_LHDC_QUALITY_MAGIC_NUM | A2DP_LHDC_QUALITY_LOW4);
+          quality_mode = A2DP_LHDC_QUALITY_LOW4;
+        }
+      }
+    }
+    /* 2024/08/28: even has no MinBitrate, LHDC type bitrate is at least 128kbps(LOW1) */
+    if (quality_mode < A2DP_LHDC_QUALITY_LOW1) {
+      codec_user_config_.codec_specific_1 &= ~(A2DP_LHDC_VENDOR_CMD_MASK | A2DP_LHDC_QUALITY_MASK);
+      codec_user_config_.codec_specific_1 |= (A2DP_LHDC_QUALITY_MAGIC_NUM | A2DP_LHDC_QUALITY_LOW1);
+      quality_mode = A2DP_LHDC_QUALITY_LOW1;
+    }
+    log::info(" : [LHDCV4 only]: SR(0x{:02x}) Qmode(0x{:02x})", result_config_cie.sampleRate, quality_mode);
+  } else if (result_config_cie.hasFeatureLLAC && !result_config_cie.hasFeatureLHDCV4) {
+    //LLAC only
+    if (result_config_cie.sampleRate == A2DP_LHDC_SAMPLING_FREQ_96000) {
+      result_config_cie.sampleRate = A2DP_LHDC_SAMPLING_FREQ_48000;
+      codec_config_.sample_rate = BTAV_A2DP_CODEC_SAMPLE_RATE_48000;
+      codec_user_config_.sample_rate = BTAV_A2DP_CODEC_SAMPLE_RATE_48000;	//also set UI settings
+      log::info(" : [LLAC only]: 96KHz not supported, reset SampleRate (0x{:02x})",
+                result_config_cie.sampleRate);
+    }
+
+    if (quality_mode > A2DP_LHDC_QUALITY_LOW && quality_mode != A2DP_LHDC_QUALITY_ABR) {
+      codec_user_config_.codec_specific_1 &= ~(A2DP_LHDC_VENDOR_CMD_MASK | A2DP_LHDC_QUALITY_MASK);
+      codec_user_config_.codec_specific_1 |= (A2DP_LHDC_QUALITY_MAGIC_NUM | A2DP_LHDC_QUALITY_LOW);
+      quality_mode = A2DP_LHDC_QUALITY_LOW;
+    }
+
+    /* LLAC: prevent quality mode using 64kbps */
+    if (result_config_cie.hasFeatureMinBitrate) {
+      if (quality_mode < A2DP_LHDC_QUALITY_LOW1) {
+        codec_user_config_.codec_specific_1 &= ~(A2DP_LHDC_VENDOR_CMD_MASK | A2DP_LHDC_QUALITY_MASK);
+        codec_user_config_.codec_specific_1 |= (A2DP_LHDC_QUALITY_MAGIC_NUM | A2DP_LHDC_QUALITY_LOW1);
+        quality_mode = A2DP_LHDC_QUALITY_LOW1;
+      }
+    }
+    log::info(" : [LLAC only]: SR(0x{:02x}) Qmode(0x{:02x})", result_config_cie.sampleRate, quality_mode);
+  } else if (!result_config_cie.hasFeatureLLAC && !result_config_cie.hasFeatureLHDCV4) {
+    //LHDC V3 only
+    if (result_config_cie.sampleRate == A2DP_LHDC_SAMPLING_FREQ_96000) {
+      if (result_config_cie.hasFeatureMinBitrate) {
+        if (quality_mode < A2DP_LHDC_QUALITY_LOW) {
+          codec_user_config_.codec_specific_1 &= ~(A2DP_LHDC_VENDOR_CMD_MASK | A2DP_LHDC_QUALITY_MASK);
+          codec_user_config_.codec_specific_1 |= (A2DP_LHDC_QUALITY_MAGIC_NUM | A2DP_LHDC_QUALITY_LOW);
+          quality_mode = A2DP_LHDC_QUALITY_LOW;
+        }
+      }
+    } else {
+      if (result_config_cie.hasFeatureMinBitrate) {
+        if (quality_mode < A2DP_LHDC_QUALITY_LOW4) {
+          codec_user_config_.codec_specific_1 &= ~(A2DP_LHDC_VENDOR_CMD_MASK | A2DP_LHDC_QUALITY_MASK);
+          codec_user_config_.codec_specific_1 |= (A2DP_LHDC_QUALITY_MAGIC_NUM | A2DP_LHDC_QUALITY_LOW4);
+          quality_mode = A2DP_LHDC_QUALITY_LOW4;
+        }
+      }
+    }
+    /* 2024/08/28: even has no MinBitrate, LHDC type bitrate is at least 128kbps(LOW1) */
+    if (quality_mode < A2DP_LHDC_QUALITY_LOW1) {
+      codec_user_config_.codec_specific_1 &= ~(A2DP_LHDC_VENDOR_CMD_MASK | A2DP_LHDC_QUALITY_MASK);
+      codec_user_config_.codec_specific_1 |= (A2DP_LHDC_QUALITY_MAGIC_NUM | A2DP_LHDC_QUALITY_LOW1);
+      quality_mode = A2DP_LHDC_QUALITY_LOW1;
+    }
+    log::info(" : [V3 only]: SR(0x{:02x}) Qmode(0x{:02x})", result_config_cie.sampleRate, quality_mode);
+  }
+
+  log::info(" : Final quality_mode = ({})  ", 
+            quality_mode,
+            lhdcV3_QualityModeBitRate_toString(quality_mode).c_str());
+  log::info(" : Final peer max bitrate = 0x{:02x}", result_config_cie.maxTargetBitrate);
+
+  //
+  // Copy the codec-specific fields if they are not zero
+  //
+  if (codec_user_config_.codec_specific_1 != 0)
+    codec_config_.codec_specific_1 = codec_user_config_.codec_specific_1;
+  if (codec_user_config_.codec_specific_2 != 0)
+    codec_config_.codec_specific_2 = codec_user_config_.codec_specific_2;
+  if (codec_user_config_.codec_specific_3 != 0)
+    codec_config_.codec_specific_3 = codec_user_config_.codec_specific_3;
+  if (codec_user_config_.codec_specific_4 != 0)
+    codec_config_.codec_specific_4 = codec_user_config_.codec_specific_4;
+
+  /* Setup final nego result codec config to peer */
+  if (int ret = A2DP_BuildInfoLhdcV3(AVDT_MEDIA_TYPE_AUDIO, &result_config_cie,
+                                     p_result_codec_config) != A2DP_SUCCESS) {
+    log::error(" : A2DP_BuildInfoLhdcV3 fail(0x{:02x})", ret);
+    goto fail;
+  }
+
+
+  // Create a local copy of the peer codec capability, and the
+  // result codec config.
+  log::info(" : is_capability = {}", is_capability);
+  if (is_capability) {
+    status = A2DP_BuildInfoLhdcV3(AVDT_MEDIA_TYPE_AUDIO, &sink_info_cie,
+                                    ota_codec_peer_capability_);
+  } else {
+    status = A2DP_BuildInfoLhdcV3(AVDT_MEDIA_TYPE_AUDIO, &sink_info_cie,
+                                    ota_codec_peer_config_);
+  }
+  CHECK(status == A2DP_SUCCESS);
+
+  status = A2DP_BuildInfoLhdcV3(AVDT_MEDIA_TYPE_AUDIO, &result_config_cie,
+                                ota_codec_config_);
+  CHECK(status == A2DP_SUCCESS);
+
+  log::info( " : Final User_SP1=(0x{:02x}); SP2=(0x{:02x}); SP3=(0x{:02x}); SP4=(0x{:02x})",
+             (unsigned long long)codec_user_config_.codec_specific_1,
+             (unsigned long long)codec_user_config_.codec_specific_2,
+             (unsigned long long)codec_user_config_.codec_specific_3,
+             (unsigned long long)codec_user_config_.codec_specific_4);
+  log::info( " : Final Codec_SP1=(0x{:02x}); SP2=(0x{:02x}); SP3=(0x{:02x}); SP4=(0x{:02x})",
+             (unsigned long long)(codec_config_.codec_specific_1),
+             (unsigned long long)(codec_config_.codec_specific_2),
+             (unsigned long long)(codec_config_.codec_specific_3),
+             (unsigned long long)(codec_config_.codec_specific_4));
+
+  return A2DP_SUCCESS;
+
+fail:
+  // Restore the internal state
+  codec_config_ = saved_codec_config;
+  codec_capability_ = saved_codec_capability;
+  codec_selectable_capability_ = saved_codec_selectable_capability;
+  codec_user_config_ = saved_codec_user_config;
+  codec_audio_config_ = saved_codec_audio_config;
+  memcpy(ota_codec_config_, saved_ota_codec_config, sizeof(ota_codec_config_));
+  memcpy(ota_codec_peer_capability_, saved_ota_codec_peer_capability,
+         sizeof(ota_codec_peer_capability_));
+  memcpy(ota_codec_peer_config_, saved_ota_codec_peer_config,
+         sizeof(ota_codec_peer_config_));
+  return status;
+}
+
+
+
+bool A2dpCodecConfigLhdcV3::setPeerCodecCapabilities(
+    const uint8_t* p_peer_codec_capabilities) {
+  std::lock_guard<std::recursive_mutex> lock(codec_mutex_);
+  tA2DP_LHDC_CIE peer_info_cie;
+  uint8_t sampleRate;
+  uint8_t bits_per_sample;
+
+  // Save the internal state
+  btav_a2dp_codec_config_t saved_codec_selectable_capability =
+      codec_selectable_capability_;
+  uint8_t saved_ota_codec_peer_capability[AVDT_CODEC_SIZE];
+  memcpy(saved_ota_codec_peer_capability, ota_codec_peer_capability_,
+         sizeof(ota_codec_peer_capability_));
+
+  tA2DP_STATUS status =
+      A2DP_ParseInfoLhdcV3(&peer_info_cie, p_peer_codec_capabilities, true);
+  if (status != A2DP_SUCCESS) {
+    log::error( " : can't parse peer's capabilities: error = {}",
+               status);
+    goto fail;
+  }
+  /*
+    if (peer_info_cie.version > a2dp_lhdc_source_caps.version) {
+        log::error( " : can't parse peer's capabilities: Missmatch version(%u:%u)",
+                  a2dp_lhdc_source_caps.version, peer_info_cie.version);
+        goto fail;
+    }
+   */
+
+  // Compute the selectable capability - bits per sample
+  //codec_selectable_capability_.bits_per_sample =
+  //a2dp_lhdc_source_caps.bits_per_sample;
+  bits_per_sample = a2dp_lhdc_source_caps.bits_per_sample & peer_info_cie.bits_per_sample;
+  if (bits_per_sample & BTAV_A2DP_CODEC_BITS_PER_SAMPLE_16) {
+    codec_selectable_capability_.bits_per_sample |= BTAV_A2DP_CODEC_BITS_PER_SAMPLE_16;
+  }
+  if (bits_per_sample & BTAV_A2DP_CODEC_BITS_PER_SAMPLE_24) {
+    codec_selectable_capability_.bits_per_sample |= BTAV_A2DP_CODEC_BITS_PER_SAMPLE_24;
+  }
+
+
+  // Compute the selectable capability - sample rate
+  sampleRate = a2dp_lhdc_source_caps.sampleRate & peer_info_cie.sampleRate;
+  if (sampleRate & A2DP_LHDC_SAMPLING_FREQ_44100) {
+    codec_selectable_capability_.sample_rate |=
+        BTAV_A2DP_CODEC_SAMPLE_RATE_44100;
+  }
+  if (sampleRate & A2DP_LHDC_SAMPLING_FREQ_48000) {
+    codec_selectable_capability_.sample_rate |=
+        BTAV_A2DP_CODEC_SAMPLE_RATE_48000;
+  }
+  if (sampleRate & A2DP_LHDC_SAMPLING_FREQ_96000) {
+    codec_selectable_capability_.sample_rate |=
+        BTAV_A2DP_CODEC_SAMPLE_RATE_96000;
+  }
+
+
+  // Compute the selectable capability - channel mode
+  codec_selectable_capability_.channel_mode = BTAV_A2DP_CODEC_CHANNEL_MODE_STEREO;
+
+  status = A2DP_BuildInfoLhdcV3(AVDT_MEDIA_TYPE_AUDIO, &peer_info_cie,
+                                ota_codec_peer_capability_);
+  CHECK(status == A2DP_SUCCESS);
+  return A2DP_SUCCESS;
+
+fail:
+  // Restore the internal state
+  codec_selectable_capability_ = saved_codec_selectable_capability;
+  memcpy(ota_codec_peer_capability_, saved_ota_codec_peer_capability,
+         sizeof(ota_codec_peer_capability_));
+  return status;
+}
diff --git a/system/stack/a2dp/a2dp_vendor_lhdcv3_dec.cc b/system/stack/a2dp/a2dp_vendor_lhdcv3_dec.cc
new file mode 100755
index 0000000000..3ca0ba2d06
--- /dev/null
+++ b/system/stack/a2dp/a2dp_vendor_lhdcv3_dec.cc
@@ -0,0 +1,2087 @@
+/******************************************************************************
+ *
+ *  Copyright 2002-2012 Broadcom Corporation
+ *
+ *  Licensed under the Apache License, Version 2.0 (the "License");
+ *  you may not use this file except in compliance with the License.
+ *  You may obtain a copy of the License at:
+ *
+ *  http://www.apache.org/licenses/LICENSE-2.0
+ *
+ *  Unless required by applicable law or agreed to in writing, software
+ *  distributed under the License is distributed on an "AS IS" BASIS,
+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ *  See the License for the specific language governing permissions and
+ *  limitations under the License.
+ *
+ ******************************************************************************/
+
+/******************************************************************************
+ *
+ *  Utility functions to help build and parse SBC Codec Information Element
+ *  and Media Payload.
+ *
+ ******************************************************************************/
+
+#define LOG_TAG "bluetooth-a2dp"
+#include "bt_target.h"
+
+#include "a2dp_vendor_lhdc_constants.h"
+#include "a2dp_vendor_lhdcv3.h"
+#include "a2dp_vendor_lhdcv3_dec.h"
+
+#include <string.h>
+
+#include <base/logging.h>
+#include "a2dp_vendor.h"
+#include "a2dp_vendor_lhdcv3_decoder.h"
+#include "btif/include/btif_av_co.h"
+#include "internal_include/bt_trace.h"
+#include "stack/include/bt_hdr.h"
+#include "osi/include/osi.h"
+#include <bluetooth/log.h>
+#include "os/log.h"
+using namespace bluetooth;
+
+
+
+typedef struct {
+  btav_a2dp_codec_config_t *_codec_config_;
+  btav_a2dp_codec_config_t *_codec_capability_;
+  btav_a2dp_codec_config_t *_codec_local_capability_;
+  btav_a2dp_codec_config_t *_codec_selectable_capability_;
+  btav_a2dp_codec_config_t *_codec_user_config_;
+  btav_a2dp_codec_config_t *_codec_audio_config_;
+}tA2DP_CODEC_CONFIGS_PACK;
+
+typedef struct {
+  uint8_t   featureCode;    /* code definition for LHDC API ex: LHDC_EXTEND_FUNC_A2DP_LHDC_JAS_CODE */
+  uint8_t   inSpecBank;     /* in which specific bank */
+  uint8_t   bitPos;         /* at which bit index number of the specific bank */
+}tA2DP_LHDC_FEATURE_POS;
+
+/* source side metadata of JAS feature */
+static const tA2DP_LHDC_FEATURE_POS a2dp_lhdc_source_caps_JAS = {
+    LHDC_EXTEND_FUNC_A2DP_LHDC_JAS_CODE,
+    LHDC_EXTEND_FUNC_A2DP_SPECIFIC3_INDEX,
+    A2DP_LHDC_JAS_SPEC_BIT_POS,
+};
+/* source side metadata of AR feature */
+static const tA2DP_LHDC_FEATURE_POS a2dp_lhdc_source_caps_AR = {
+    LHDC_EXTEND_FUNC_A2DP_LHDC_AR_CODE,
+    LHDC_EXTEND_FUNC_A2DP_SPECIFIC3_INDEX,
+    A2DP_LHDC_AR_SPEC_BIT_POS
+};
+/* source side metadata of LLAC feature */
+static const tA2DP_LHDC_FEATURE_POS a2dp_lhdc_source_caps_LLAC = {
+    LHDC_EXTEND_FUNC_A2DP_LHDC_LLAC_CODE,
+    LHDC_EXTEND_FUNC_A2DP_SPECIFIC3_INDEX,
+    A2DP_LHDC_LLAC_SPEC_BIT_POS
+};
+/* source side metadata of META feature */
+static const tA2DP_LHDC_FEATURE_POS a2dp_lhdc_source_caps_META = {
+    LHDC_EXTEND_FUNC_A2DP_LHDC_META_CODE,
+    LHDC_EXTEND_FUNC_A2DP_SPECIFIC3_INDEX,
+    A2DP_LHDC_META_SPEC_BIT_POS
+};
+/* source side metadata of MBR feature */
+static const tA2DP_LHDC_FEATURE_POS a2dp_lhdc_source_caps_MBR = {
+    LHDC_EXTEND_FUNC_A2DP_LHDC_MBR_CODE,
+    LHDC_EXTEND_FUNC_A2DP_SPECIFIC3_INDEX,
+    A2DP_LHDC_MBR_SPEC_BIT_POS
+};
+/* source side metadata of LARC feature */
+static const tA2DP_LHDC_FEATURE_POS a2dp_lhdc_source_caps_LARC = {
+    LHDC_EXTEND_FUNC_A2DP_LHDC_LARC_CODE,
+    LHDC_EXTEND_FUNC_A2DP_SPECIFIC3_INDEX,
+    A2DP_LHDC_LARC_SPEC_BIT_POS
+};
+/* source side metadata of LHDCV4 feature */
+static const tA2DP_LHDC_FEATURE_POS a2dp_lhdc_source_caps_LHDCV4 = {
+    LHDC_EXTEND_FUNC_A2DP_LHDC_V4_CODE,
+    LHDC_EXTEND_FUNC_A2DP_SPECIFIC3_INDEX,
+    A2DP_LHDC_V4_SPEC_BIT_POS
+};
+
+static const UNUSED_ATTR tA2DP_LHDC_FEATURE_POS a2dp_lhdc_sink_caps_all[] = {
+    a2dp_lhdc_source_caps_JAS,
+    a2dp_lhdc_source_caps_AR,
+    a2dp_lhdc_source_caps_LLAC,
+    a2dp_lhdc_source_caps_META,
+    a2dp_lhdc_source_caps_MBR,
+    a2dp_lhdc_source_caps_LARC,
+    a2dp_lhdc_source_caps_LHDCV4,
+};
+
+// data type for the LHDC Codec Information Element */
+// NOTE: bits_per_sample is needed only for LHDC encoder initialization.
+typedef struct {
+  uint32_t vendorId;
+  uint16_t codecId;    /* Codec ID for LHDC */
+  uint8_t sampleRate;  /* Sampling Frequency */
+  uint8_t llac_sampleRate;  /* Sampling Frequency for LLAC */
+  btav_a2dp_codec_bits_per_sample_t bits_per_sample;
+  uint8_t channelSplitMode;
+  uint8_t version;
+  uint8_t maxTargetBitrate;
+  bool isLLSupported;
+  //uint8_t supportedBitrate;
+  bool hasFeatureJAS;
+  bool hasFeatureAR;
+  bool hasFeatureLLAC;
+  bool hasFeatureMETA;
+  bool hasFeatureMinBitrate;
+  bool hasFeatureLARC;
+  bool hasFeatureLHDCV4;
+} tA2DP_LHDCV3_SINK_CIE;
+
+/* LHDC Sink codec capabilities */
+static const tA2DP_LHDCV3_SINK_CIE a2dp_lhdcv3_sink_caps = {
+    A2DP_LHDC_VENDOR_ID,  // vendorId
+    A2DP_LHDCV3_CODEC_ID,   // codecId
+    // sampleRate
+    //(A2DP_LHDC_SAMPLING_FREQ_48000),
+    (A2DP_LHDC_SAMPLING_FREQ_44100 | A2DP_LHDC_SAMPLING_FREQ_48000 | A2DP_LHDC_SAMPLING_FREQ_96000),
+    (A2DP_LHDC_SAMPLING_FREQ_48000),
+    // bits_per_sample
+    (BTAV_A2DP_CODEC_BITS_PER_SAMPLE_16 | BTAV_A2DP_CODEC_BITS_PER_SAMPLE_24),
+    //Channel Separation
+    //A2DP_LHDC_CH_SPLIT_NONE | A2DP_LHDC_CH_SPLIT_TWS,
+	  A2DP_LHDC_CH_SPLIT_NONE,
+    //Version number
+    A2DP_LHDC_VER3,
+    //Target bit Rate
+    A2DP_LHDC_MAX_BIT_RATE_900K,
+    //LL supported ?
+    true,
+
+    /*******************************
+     *  LHDC features/capabilities:
+     *  hasFeatureJAS
+     *  hasFeatureAR
+     *  hasFeatureLLAC
+     *  hasFeatureMETA
+     *  hasFeatureMinBitrate
+     *  hasFeatureLARC
+     *  hasFeatureLHDCV4
+     *******************************/
+    //bool hasFeatureJAS;
+    false,
+
+    //bool hasFeatureAR;
+    false,
+
+    //bool hasFeatureLLAC;
+    true,
+
+    //bool hasFeatureMETA;
+    false,
+
+    //bool hasFeatureMinBitrate;
+    true,
+
+    //bool hasFeatureLARC;
+    false,
+
+    //bool hasFeatureLHDCV4;
+    true,
+};
+
+/* Default LHDC codec configuration */
+static const tA2DP_LHDCV3_SINK_CIE a2dp_lhdcv3_sink_default_config = {
+    A2DP_LHDC_VENDOR_ID,                // vendorId
+    A2DP_LHDCV3_CODEC_ID,                 // codecId
+    A2DP_LHDC_SAMPLING_FREQ_48000,      // sampleRate
+    A2DP_LHDC_SAMPLING_FREQ_48000,      // LLAC default best sampleRate
+    BTAV_A2DP_CODEC_BITS_PER_SAMPLE_24,  // bits_per_sample
+    A2DP_LHDC_CH_SPLIT_NONE,
+    A2DP_LHDC_VER3,
+    A2DP_LHDC_MAX_BIT_RATE_900K,
+    //LL supported ?
+    true,
+
+    //bool hasFeatureJAS;
+    false,
+
+    //bool hasFeatureAR;
+    false,
+
+    //bool hasFeatureLLAC;
+    true,
+
+    //bool hasFeatureMETA;
+    false,
+
+    //bool hasFeatureMinBitrate;
+    true,
+
+    //bool hasFeatureLARC;
+    false,
+
+    //bool hasFeatureLHDCV4;
+    true,
+};
+
+static const tA2DP_DECODER_INTERFACE a2dp_decoder_interface_lhdcv3 = {
+    a2dp_vendor_lhdcv3_decoder_init,
+    a2dp_vendor_lhdcv3_decoder_cleanup,
+    a2dp_vendor_lhdcv3_decoder_decode_packet,
+    a2dp_vendor_lhdcv3_decoder_start,
+    a2dp_vendor_lhdcv3_decoder_suspend,
+    a2dp_vendor_lhdcv3_decoder_configure,
+};
+
+static std::string lhdcV3_QualityModeBitRate_toString(uint32_t value) {
+  switch((int)value)
+  {
+  case A2DP_LHDC_QUALITY_ABR:
+    return "ABR";
+  case A2DP_LHDC_QUALITY_HIGH1:
+    return "HIGH 1 (1000 Kbps)";
+  case A2DP_LHDC_QUALITY_HIGH:
+    return "HIGH (900 Kbps)";
+  case A2DP_LHDC_QUALITY_MID:
+    return "MID (500 Kbps)";
+  case A2DP_LHDC_QUALITY_LOW:
+    return "LOW (400 Kbps)";
+  case A2DP_LHDC_QUALITY_LOW4:
+    return "LOW 4 (320 Kbps)";
+  case A2DP_LHDC_QUALITY_LOW3:
+    return "LOW 3 (256 Kbps)";
+  case A2DP_LHDC_QUALITY_LOW2:
+    return "LOW 2 (192 Kbps)";
+  case A2DP_LHDC_QUALITY_LOW1:
+    return "LOW 1 (128 Kbps)";
+  case A2DP_LHDC_QUALITY_LOW0:
+    return "LOW 0 (64 Kbps)";
+  default:
+    return "Unknown Bit Rate Mode";
+  }
+}
+
+static tA2DP_STATUS A2DP_CodecInfoMatchesCapabilityLhdcV3Sink(
+    const tA2DP_LHDCV3_SINK_CIE* p_cap, const uint8_t* p_codec_info,
+    bool is_capability);
+
+
+// Builds the LHDC Media Codec Capabilities byte sequence beginning from the
+// LOSC octet. |media_type| is the media type |AVDT_MEDIA_TYPE_*|.
+// |p_ie| is a pointer to the LHDC Codec Information Element information.
+// The result is stored in |p_result|. Returns A2DP_SUCCESS on success,
+// otherwise the corresponding A2DP error status code.
+static tA2DP_STATUS A2DP_BuildInfoLhdcV3Sink(uint8_t media_type,
+                                       const tA2DP_LHDCV3_SINK_CIE* p_ie,
+                                       uint8_t* p_result) {
+
+  const uint8_t* tmpInfo = p_result;
+  if (p_ie == NULL || p_result == NULL) {
+    return A2DP_INVALID_CODEC_PARAMETER;
+  }
+
+  *p_result++ = A2DP_LHDCV3_CODEC_LEN;    //0
+  *p_result++ = (media_type << 4);      //1
+  *p_result++ = A2DP_MEDIA_CT_NON_A2DP; //2
+
+  // Vendor ID and Codec ID
+  *p_result++ = (uint8_t)(p_ie->vendorId & 0x000000FF); //3
+  *p_result++ = (uint8_t)((p_ie->vendorId & 0x0000FF00) >> 8);  //4
+  *p_result++ = (uint8_t)((p_ie->vendorId & 0x00FF0000) >> 16); //5
+  *p_result++ = (uint8_t)((p_ie->vendorId & 0xFF000000) >> 24); //6
+  *p_result++ = (uint8_t)(p_ie->codecId & 0x00FF);  //7
+  *p_result++ = (uint8_t)((p_ie->codecId & 0xFF00) >> 8);   //8
+
+  // Sampling Frequency & Bits per sample
+  uint8_t para = 0;
+
+  // sample rate bit0 ~ bit2
+  para = (uint8_t)(p_ie->sampleRate & A2DP_LHDC_SAMPLING_FREQ_MASK);
+
+  if (p_ie->bits_per_sample == (BTAV_A2DP_CODEC_BITS_PER_SAMPLE_24 | BTAV_A2DP_CODEC_BITS_PER_SAMPLE_16)) {
+      para = para | (A2DP_LHDC_BIT_FMT_24 | A2DP_LHDC_BIT_FMT_16);
+  }else if(p_ie->bits_per_sample == BTAV_A2DP_CODEC_BITS_PER_SAMPLE_24){
+      para = para | A2DP_LHDC_BIT_FMT_24;
+  }else if(p_ie->bits_per_sample == BTAV_A2DP_CODEC_BITS_PER_SAMPLE_16){
+      para = para | A2DP_LHDC_BIT_FMT_16;
+  }
+
+  if (p_ie->hasFeatureJAS)
+  {
+    para |= A2DP_LHDC_FEATURE_JAS;
+  }
+
+  if (p_ie->hasFeatureAR)
+  {
+    para |= A2DP_LHDC_FEATURE_AR;
+  }
+
+  // Save octet 9
+  *p_result++ = para;   //9
+
+  para = p_ie->version;
+
+  para |= p_ie->maxTargetBitrate;
+
+  para |= p_ie->isLLSupported ? A2DP_LHDC_LL_SUPPORTED : A2DP_LHDC_LL_NONE;
+
+  if (p_ie->hasFeatureLLAC)
+  {
+    para |= A2DP_LHDC_FEATURE_LLAC;
+  }
+
+  // Save octet 10
+  *p_result++ = para;   //a
+
+  //Save octet 11
+  para = p_ie->channelSplitMode;
+
+  if (p_ie->hasFeatureMETA)
+  {
+    para |= A2DP_LHDC_FEATURE_META;
+  }
+
+  if (p_ie->hasFeatureMinBitrate)
+  {
+    para |= A2DP_LHDC_FEATURE_MIN_BR;
+  }
+
+  if (p_ie->hasFeatureLARC)
+  {
+    para |= A2DP_LHDC_FEATURE_LARC;
+  }
+
+  if (p_ie->hasFeatureLHDCV4)
+  {
+    para |= A2DP_LHDC_FEATURE_LHDCV4;
+  }
+
+  *p_result++ = para;   //b
+
+  //Save octet 12
+  //para = p_ie->supportedBitrate;
+  //*p_result++ = para;   //c
+
+  log::info(": Info build result = [0]:0x{:02x}, [1]:0x{:02x}, [2]:0x{:02x}, [3]:0x{:02x}, "
+                     "[4]:0x{:02x}, [5]:0x{:02x}, [6]:0x{:02x}, [7]:0x{:02x}, [8]:0x{:02x}, [9]:0x{:02x}, [10]:0x{:02x}, [11]:0x{:02x}",
+      tmpInfo[0], tmpInfo[1], tmpInfo[2], tmpInfo[3],
+                    tmpInfo[4], tmpInfo[5], tmpInfo[6], tmpInfo[7], tmpInfo[8], tmpInfo[9], tmpInfo[10], tmpInfo[11]);
+  return A2DP_SUCCESS;
+}
+
+// Parses the LHDC Media Codec Capabilities byte sequence beginning from the
+// LOSC octet. The result is stored in |p_ie|. The byte sequence to parse is
+// |p_codec_info|. If |is_capability| is true, the byte sequence is
+// codec capabilities, otherwise is codec configuration.
+// Returns A2DP_SUCCESS on success, otherwise the corresponding A2DP error
+// status code.
+static tA2DP_STATUS A2DP_ParseInfoLhdcV3Sink(tA2DP_LHDCV3_SINK_CIE* p_ie,
+                                       const uint8_t* p_codec_info,
+                                       bool is_capability) {
+  uint8_t losc;
+  uint8_t media_type;
+  tA2DP_CODEC_TYPE codec_type;
+  const uint8_t* tmpInfo = p_codec_info;
+  const uint8_t* p_codec_Info_save = p_codec_info;
+
+  //log::info(": p_ie = {}, p_codec_info = {}", p_ie, p_codec_info);
+  if (p_ie == NULL || p_codec_info == NULL) return A2DP_INVALID_CODEC_PARAMETER;
+
+  // Check the codec capability length
+  losc = *p_codec_info++;
+
+  if (losc != A2DP_LHDCV3_CODEC_LEN) return AVDTP_UNSUPPORTED_CONFIGURATION;
+
+  media_type = (*p_codec_info++) >> 4;
+  codec_type = static_cast<tA2DP_CODEC_TYPE>(*p_codec_info++);
+    //log::info(": media_type = {}, codec_type = {}", media_type, codec_type);
+  /* Check the Media Type and Media Codec Type */
+  if (media_type != AVDT_MEDIA_TYPE_AUDIO ||
+      codec_type != A2DP_MEDIA_CT_NON_A2DP) {
+    return AVDTP_UNSUPPORTED_CONFIGURATION;
+  }
+
+  // Check the Vendor ID and Codec ID */
+  p_ie->vendorId = (*p_codec_info & 0x000000FF) |
+                   (*(p_codec_info + 1) << 8 & 0x0000FF00) |
+                   (*(p_codec_info + 2) << 16 & 0x00FF0000) |
+                   (*(p_codec_info + 3) << 24 & 0xFF000000);
+  p_codec_info += 4;
+  p_ie->codecId =
+      (*p_codec_info & 0x00FF) | (*(p_codec_info + 1) << 8 & 0xFF00);
+  p_codec_info += 2;
+  log::info(":Vendor(0x{:02x}), Codec(0x{:02x})", p_ie->vendorId, p_ie->codecId);
+  if (p_ie->vendorId != A2DP_LHDC_VENDOR_ID ||
+      p_ie->codecId != A2DP_LHDCV3_CODEC_ID) {
+    return AVDTP_UNSUPPORTED_CONFIGURATION;
+  }
+
+  p_ie->sampleRate = *p_codec_info & A2DP_LHDC_SAMPLING_FREQ_MASK;
+  if ((*p_codec_info & A2DP_LHDC_BIT_FMT_MASK) == 0) {
+    return AVDTP_UNSUPPORTED_CONFIGURATION;
+  }
+
+  p_ie->bits_per_sample = BTAV_A2DP_CODEC_BITS_PER_SAMPLE_NONE;
+  if (*p_codec_info & A2DP_LHDC_BIT_FMT_24)
+    p_ie->bits_per_sample |= BTAV_A2DP_CODEC_BITS_PER_SAMPLE_24;
+  if (*p_codec_info & A2DP_LHDC_BIT_FMT_16) {
+    p_ie->bits_per_sample |= BTAV_A2DP_CODEC_BITS_PER_SAMPLE_16;
+  }
+
+  p_ie->hasFeatureJAS = ((*p_codec_info & A2DP_LHDC_FEATURE_JAS) != 0) ? true : false;
+
+  p_ie->hasFeatureAR = ((*p_codec_info & A2DP_LHDC_FEATURE_AR) != 0) ? true : false;
+
+  p_codec_info += 1;
+
+  p_ie->version = (*p_codec_info) & A2DP_LHDC_VERSION_MASK;
+  //p_ie->version = 1;
+
+  p_ie->maxTargetBitrate = (*p_codec_info) & A2DP_LHDC_MAX_BIT_RATE_MASK;
+  //p_ie->maxTargetBitrate = A2DP_LHDC_MAX_BIT_RATE_900K;
+
+  p_ie->isLLSupported = ((*p_codec_info & A2DP_LHDC_LL_MASK) != 0)? true : false;
+  //p_ie->isLLSupported = false;
+
+  p_ie->hasFeatureLLAC = ((*p_codec_info & A2DP_LHDC_FEATURE_LLAC) != 0) ? true : false;
+
+  p_codec_info += 1;
+
+  p_ie->channelSplitMode = (*p_codec_info) & A2DP_LHDC_CH_SPLIT_MSK;
+
+  p_ie->hasFeatureMETA = ((*p_codec_info & A2DP_LHDC_FEATURE_META) != 0) ? true : false;
+
+  p_ie->hasFeatureMinBitrate = ((*p_codec_info & A2DP_LHDC_FEATURE_MIN_BR) != 0) ? true : false;
+
+  p_ie->hasFeatureLARC = ((*p_codec_info & A2DP_LHDC_FEATURE_LARC) != 0) ? true : false;
+
+  p_ie->hasFeatureLHDCV4 = ((*p_codec_info & A2DP_LHDC_FEATURE_LHDCV4) != 0) ? true : false;
+
+  log::info( ":Has LL({}) JAS({}) AR({}) META({}) LLAC({}) MBR({}) LARC({}) V4({})",
+      p_ie->isLLSupported,
+      p_ie->hasFeatureJAS,
+      p_ie->hasFeatureAR,
+      p_ie->hasFeatureMETA,
+      p_ie->hasFeatureLLAC,
+      p_ie->hasFeatureMinBitrate,
+      p_ie->hasFeatureLARC,
+      p_ie->hasFeatureLHDCV4);
+
+  log::info( ": codec info = [0]:0x{:02x}, [1]:0x{:02x}, [2]:0x{:02x}, [3]:0x{:02x}, [4]:0x{:02x}, [5]:0x{:02x}, [6]:0x{:02x}, [7]:0x{:02x}, [8]:0x{:02x}, [9]:0x{:02x}, [10]:0x{:02x}, [11]:0x{:02x}",
+             tmpInfo[0], tmpInfo[1], tmpInfo[2], tmpInfo[3], tmpInfo[4], tmpInfo[5], tmpInfo[6],
+                        tmpInfo[7], tmpInfo[8], tmpInfo[9], tmpInfo[10], tmpInfo[11]);
+
+  if (is_capability) return A2DP_SUCCESS;
+
+  if (A2DP_BitsSet(p_ie->sampleRate) != A2DP_SET_ONE_BIT)
+    return A2DP_INVALID_SAMPLING_FREQUENCY;
+
+  save_codec_info (p_codec_Info_save);
+
+  return A2DP_SUCCESS;
+}
+
+//
+// Selects the best sample rate from |sampleRate|.
+// The result is stored in |p_result| and |p_codec_config|.
+// Returns true if a selection was made, otherwise false.
+//
+static bool select_best_sample_rate(uint8_t sampleRate,
+                                    tA2DP_LHDCV3_SINK_CIE* p_result,
+                                    btav_a2dp_codec_config_t* p_codec_config) {
+  if (sampleRate & A2DP_LHDC_SAMPLING_FREQ_96000) {
+    p_result->sampleRate = A2DP_LHDC_SAMPLING_FREQ_96000;
+    p_codec_config->sample_rate = BTAV_A2DP_CODEC_SAMPLE_RATE_96000;
+    return true;
+  }
+  if (sampleRate & A2DP_LHDC_SAMPLING_FREQ_88200) {
+    p_result->sampleRate = A2DP_LHDC_SAMPLING_FREQ_88200;
+    p_codec_config->sample_rate = BTAV_A2DP_CODEC_SAMPLE_RATE_88200;
+    return true;
+  }
+  if (sampleRate & A2DP_LHDC_SAMPLING_FREQ_48000) {
+    p_result->sampleRate = A2DP_LHDC_SAMPLING_FREQ_48000;
+    p_codec_config->sample_rate = BTAV_A2DP_CODEC_SAMPLE_RATE_48000;
+    return true;
+  }
+  if (sampleRate & A2DP_LHDC_SAMPLING_FREQ_44100) {
+    p_result->sampleRate = A2DP_LHDC_SAMPLING_FREQ_44100;
+    p_codec_config->sample_rate = BTAV_A2DP_CODEC_SAMPLE_RATE_44100;
+    return true;
+  }
+  return false;
+}
+
+//
+// Selects the audio sample rate from |p_codec_audio_config|.
+// |sampleRate| contains the capability.
+// The result is stored in |p_result| and |p_codec_config|.
+// Returns true if a selection was made, otherwise false.
+//
+static bool select_audio_sample_rate(
+    const btav_a2dp_codec_config_t* p_codec_audio_config, uint8_t sampleRate,
+    tA2DP_LHDCV3_SINK_CIE* p_result, btav_a2dp_codec_config_t* p_codec_config) {
+  switch (p_codec_audio_config->sample_rate) {
+    case BTAV_A2DP_CODEC_SAMPLE_RATE_44100:
+      if (sampleRate & A2DP_LHDC_SAMPLING_FREQ_44100) {
+        p_result->sampleRate = A2DP_LHDC_SAMPLING_FREQ_44100;
+        p_codec_config->sample_rate = BTAV_A2DP_CODEC_SAMPLE_RATE_44100;
+        return true;
+      }
+      break;
+    case BTAV_A2DP_CODEC_SAMPLE_RATE_48000:
+      if (sampleRate & A2DP_LHDC_SAMPLING_FREQ_48000) {
+        p_result->sampleRate = A2DP_LHDC_SAMPLING_FREQ_48000;
+        p_codec_config->sample_rate = BTAV_A2DP_CODEC_SAMPLE_RATE_48000;
+        return true;
+      }
+      break;
+    case BTAV_A2DP_CODEC_SAMPLE_RATE_88200:
+      if (sampleRate & A2DP_LHDC_SAMPLING_FREQ_88200) {
+        p_result->sampleRate = A2DP_LHDC_SAMPLING_FREQ_88200;
+        p_codec_config->sample_rate = BTAV_A2DP_CODEC_SAMPLE_RATE_88200;
+        return true;
+      }
+      break;
+    case BTAV_A2DP_CODEC_SAMPLE_RATE_96000:
+      if (sampleRate & A2DP_LHDC_SAMPLING_FREQ_96000) {
+        p_result->sampleRate = A2DP_LHDC_SAMPLING_FREQ_96000;
+        p_codec_config->sample_rate = BTAV_A2DP_CODEC_SAMPLE_RATE_96000;
+        return true;
+      }
+      break;
+    case BTAV_A2DP_CODEC_SAMPLE_RATE_16000:
+    case BTAV_A2DP_CODEC_SAMPLE_RATE_24000:
+    case BTAV_A2DP_CODEC_SAMPLE_RATE_176400:
+    case BTAV_A2DP_CODEC_SAMPLE_RATE_192000:
+    case BTAV_A2DP_CODEC_SAMPLE_RATE_NONE:
+      break;
+  }
+  return false;
+}
+
+//
+// Selects the best bits per sample from |bits_per_sample|.
+// |bits_per_sample| contains the capability.
+// The result is stored in |p_result| and |p_codec_config|.
+// Returns true if a selection was made, otherwise false.
+//
+static bool select_best_bits_per_sample(
+    btav_a2dp_codec_bits_per_sample_t bits_per_sample, tA2DP_LHDCV3_SINK_CIE* p_result,
+    btav_a2dp_codec_config_t* p_codec_config) {
+  if (bits_per_sample & BTAV_A2DP_CODEC_BITS_PER_SAMPLE_24) {
+    p_codec_config->bits_per_sample = BTAV_A2DP_CODEC_BITS_PER_SAMPLE_24;
+    p_result->bits_per_sample = BTAV_A2DP_CODEC_BITS_PER_SAMPLE_24;
+    return true;
+  }
+  if (bits_per_sample & BTAV_A2DP_CODEC_BITS_PER_SAMPLE_16) {
+    p_codec_config->bits_per_sample = BTAV_A2DP_CODEC_BITS_PER_SAMPLE_16;
+    p_result->bits_per_sample = BTAV_A2DP_CODEC_BITS_PER_SAMPLE_16;
+    return true;
+  }
+  return false;
+}
+
+//
+// Selects the audio bits per sample from |p_codec_audio_config|.
+// |bits_per_sample| contains the capability.
+// The result is stored in |p_result| and |p_codec_config|.
+// Returns true if a selection was made, otherwise false.
+//
+static bool select_audio_bits_per_sample(
+    const btav_a2dp_codec_config_t* p_codec_audio_config,
+    btav_a2dp_codec_bits_per_sample_t bits_per_sample, tA2DP_LHDCV3_SINK_CIE* p_result,
+    btav_a2dp_codec_config_t* p_codec_config) {
+  switch (p_codec_audio_config->bits_per_sample) {
+    case BTAV_A2DP_CODEC_BITS_PER_SAMPLE_16:
+      if (bits_per_sample & BTAV_A2DP_CODEC_BITS_PER_SAMPLE_16) {
+        p_codec_config->bits_per_sample = BTAV_A2DP_CODEC_BITS_PER_SAMPLE_16;
+        p_result->bits_per_sample = BTAV_A2DP_CODEC_BITS_PER_SAMPLE_16;
+        return true;
+      }
+      break;
+    case BTAV_A2DP_CODEC_BITS_PER_SAMPLE_24:
+      if (bits_per_sample & BTAV_A2DP_CODEC_BITS_PER_SAMPLE_24) {
+        p_codec_config->bits_per_sample = BTAV_A2DP_CODEC_BITS_PER_SAMPLE_24;
+        p_result->bits_per_sample = BTAV_A2DP_CODEC_BITS_PER_SAMPLE_24;
+        return true;
+      }
+      break;
+    case BTAV_A2DP_CODEC_BITS_PER_SAMPLE_32:
+    case BTAV_A2DP_CODEC_BITS_PER_SAMPLE_NONE:
+      break;
+  }
+  return false;
+}
+
+static std::string lhdcV3_sampleRate_toString(uint8_t value) {
+  switch((int)value)
+  {
+  case A2DP_LHDC_SAMPLING_FREQ_44100:
+    return "44100";
+  case A2DP_LHDC_SAMPLING_FREQ_48000:
+    return "48000";
+  case A2DP_LHDC_SAMPLING_FREQ_96000:
+    return "96000";
+  default:
+    return "Unknown Sample Rate";
+  }
+}
+
+static std::string lhdcV3_bitPerSample_toString(uint8_t value) {
+  switch((int)value)
+  {
+  case BTAV_A2DP_CODEC_BITS_PER_SAMPLE_16:
+    return "16";
+  case BTAV_A2DP_CODEC_BITS_PER_SAMPLE_24:
+    return "24";
+  default:
+    return "Unknown Bit Per Sample";
+  }
+}
+
+
+static bool A2DP_IsFeatureInUserConfigLhdcV3(tA2DP_CODEC_CONFIGS_PACK* cfgsPtr, uint8_t featureCode)
+{
+  switch(featureCode)
+  {
+    case LHDC_EXTEND_FUNC_A2DP_LHDC_JAS_CODE:
+      {
+        CHECK_IN_A2DP_SPEC(cfgsPtr->_codec_user_config_, a2dp_lhdc_source_caps_JAS.inSpecBank, A2DP_LHDC_JAS_ENABLED);
+      }
+      break;
+    case LHDC_EXTEND_FUNC_A2DP_LHDC_AR_CODE:
+      {
+        CHECK_IN_A2DP_SPEC(cfgsPtr->_codec_user_config_, a2dp_lhdc_source_caps_AR.inSpecBank, A2DP_LHDC_AR_ENABLED);
+      }
+      break;
+    case LHDC_EXTEND_FUNC_A2DP_LHDC_META_CODE:
+      {
+        CHECK_IN_A2DP_SPEC(cfgsPtr->_codec_user_config_, a2dp_lhdc_source_caps_META.inSpecBank, A2DP_LHDC_META_ENABLED);
+      }
+      break;
+    case LHDC_EXTEND_FUNC_A2DP_LHDC_LLAC_CODE:
+      {
+        CHECK_IN_A2DP_SPEC(cfgsPtr->_codec_user_config_, a2dp_lhdc_source_caps_LLAC.inSpecBank, A2DP_LHDC_LLAC_ENABLED);
+      }
+      break;
+    case LHDC_EXTEND_FUNC_A2DP_LHDC_MBR_CODE:
+      {
+        CHECK_IN_A2DP_SPEC(cfgsPtr->_codec_user_config_, a2dp_lhdc_source_caps_MBR.inSpecBank, A2DP_LHDC_MBR_ENABLED);
+      }
+      break;
+    case LHDC_EXTEND_FUNC_A2DP_LHDC_LARC_CODE:
+      {
+        CHECK_IN_A2DP_SPEC(cfgsPtr->_codec_user_config_, a2dp_lhdc_source_caps_LARC.inSpecBank, A2DP_LHDC_LARC_ENABLED);
+      }
+      break;
+    case LHDC_EXTEND_FUNC_A2DP_LHDC_V4_CODE:
+      {
+        CHECK_IN_A2DP_SPEC(cfgsPtr->_codec_user_config_, a2dp_lhdc_source_caps_LHDCV4.inSpecBank, A2DP_LHDC_V4_ENABLED);
+      }
+      break;
+
+  default:
+    break;
+  }
+
+  return false;
+}
+static bool A2DP_IsFeatureInCodecConfigLhdcV3(tA2DP_CODEC_CONFIGS_PACK* cfgsPtr, uint8_t featureCode)
+{
+  switch(featureCode)
+  {
+    case LHDC_EXTEND_FUNC_A2DP_LHDC_JAS_CODE:
+      {
+        CHECK_IN_A2DP_SPEC(cfgsPtr->_codec_config_, a2dp_lhdc_source_caps_JAS.inSpecBank, A2DP_LHDC_JAS_ENABLED);
+      }
+      break;
+    case LHDC_EXTEND_FUNC_A2DP_LHDC_AR_CODE:
+      {
+        CHECK_IN_A2DP_SPEC(cfgsPtr->_codec_config_, a2dp_lhdc_source_caps_AR.inSpecBank, A2DP_LHDC_AR_ENABLED);
+      }
+      break;
+    case LHDC_EXTEND_FUNC_A2DP_LHDC_META_CODE:
+      {
+        CHECK_IN_A2DP_SPEC(cfgsPtr->_codec_config_, a2dp_lhdc_source_caps_META.inSpecBank, A2DP_LHDC_META_ENABLED);
+      }
+      break;
+    case LHDC_EXTEND_FUNC_A2DP_LHDC_LLAC_CODE:
+      {
+        CHECK_IN_A2DP_SPEC(cfgsPtr->_codec_config_, a2dp_lhdc_source_caps_LLAC.inSpecBank, A2DP_LHDC_LLAC_ENABLED);
+      }
+      break;
+    case LHDC_EXTEND_FUNC_A2DP_LHDC_MBR_CODE:
+      {
+        CHECK_IN_A2DP_SPEC(cfgsPtr->_codec_config_, a2dp_lhdc_source_caps_MBR.inSpecBank, A2DP_LHDC_MBR_ENABLED);
+      }
+      break;
+    case LHDC_EXTEND_FUNC_A2DP_LHDC_LARC_CODE:
+      {
+        CHECK_IN_A2DP_SPEC(cfgsPtr->_codec_config_, a2dp_lhdc_source_caps_LARC.inSpecBank, A2DP_LHDC_LARC_ENABLED);
+      }
+      break;
+    case LHDC_EXTEND_FUNC_A2DP_LHDC_V4_CODE:
+      {
+        CHECK_IN_A2DP_SPEC(cfgsPtr->_codec_config_, a2dp_lhdc_source_caps_LHDCV4.inSpecBank, A2DP_LHDC_V4_ENABLED);
+      }
+      break;
+
+  default:
+    break;
+  }
+
+  return false;
+}
+
+static void A2DP_UpdateFeatureToSpecLhdcV3(tA2DP_CODEC_CONFIGS_PACK* cfgsPtr,
+    uint16_t toCodecCfg, bool hasFeature, uint8_t toSpec, int64_t value)
+{
+  if(toCodecCfg & A2DP_LHDC_TO_A2DP_CODEC_CONFIG_)
+  {
+    SETUP_A2DP_SPEC(cfgsPtr->_codec_config_, toSpec, hasFeature, value);
+  }
+  if(toCodecCfg & A2DP_LHDC_TO_A2DP_CODEC_CAP_)
+  {
+    SETUP_A2DP_SPEC(cfgsPtr->_codec_capability_, toSpec, hasFeature, value);
+  }
+  if(toCodecCfg & A2DP_LHDC_TO_A2DP_CODEC_LOCAL_CAP_)
+  {
+    SETUP_A2DP_SPEC(cfgsPtr->_codec_local_capability_, toSpec, hasFeature, value);
+  }
+  if(toCodecCfg & A2DP_LHDC_TO_A2DP_CODEC_SELECT_CAP_)
+  {
+    SETUP_A2DP_SPEC(cfgsPtr->_codec_selectable_capability_, toSpec, hasFeature, value);
+  }
+  if(toCodecCfg & A2DP_LHDC_TO_A2DP_CODEC_USER_)
+  {
+    SETUP_A2DP_SPEC(cfgsPtr->_codec_user_config_, toSpec, hasFeature, value);
+  }
+  if(toCodecCfg & A2DP_LHDC_TO_A2DP_CODEC_AUDIO_)
+  {
+    SETUP_A2DP_SPEC(cfgsPtr->_codec_audio_config_, toSpec, hasFeature, value);
+  }
+}
+
+static void A2DP_UpdateFeatureToA2dpConfigLhdcV3(tA2DP_CODEC_CONFIGS_PACK *cfgsPtr,
+    uint8_t featureCode,  uint16_t toCodecCfg, bool hasFeature)
+{
+
+  //log::info( ": featureCode:0x{} toCfgs:0x{}, toSet:{}", featureCode, toCodecCfg, hasFeature);
+
+  switch(featureCode)
+  {
+  case LHDC_EXTEND_FUNC_A2DP_LHDC_JAS_CODE:
+    A2DP_UpdateFeatureToSpecLhdcV3(cfgsPtr, toCodecCfg, hasFeature,
+        a2dp_lhdc_source_caps_JAS.inSpecBank, A2DP_LHDC_JAS_ENABLED);
+    break;
+  case LHDC_EXTEND_FUNC_A2DP_LHDC_AR_CODE:
+    A2DP_UpdateFeatureToSpecLhdcV3(cfgsPtr, toCodecCfg, hasFeature,
+        a2dp_lhdc_source_caps_AR.inSpecBank, A2DP_LHDC_AR_ENABLED);
+    break;
+  case LHDC_EXTEND_FUNC_A2DP_LHDC_META_CODE:
+    A2DP_UpdateFeatureToSpecLhdcV3(cfgsPtr, toCodecCfg, hasFeature,
+        a2dp_lhdc_source_caps_META.inSpecBank, A2DP_LHDC_META_ENABLED);
+    break;
+  case LHDC_EXTEND_FUNC_A2DP_LHDC_LLAC_CODE:
+    A2DP_UpdateFeatureToSpecLhdcV3(cfgsPtr, toCodecCfg, hasFeature,
+        a2dp_lhdc_source_caps_LLAC.inSpecBank, A2DP_LHDC_LLAC_ENABLED);
+    break;
+  case LHDC_EXTEND_FUNC_A2DP_LHDC_MBR_CODE:
+    A2DP_UpdateFeatureToSpecLhdcV3(cfgsPtr, toCodecCfg, hasFeature,
+        a2dp_lhdc_source_caps_MBR.inSpecBank, A2DP_LHDC_MBR_ENABLED);
+    break;
+  case LHDC_EXTEND_FUNC_A2DP_LHDC_LARC_CODE:
+    A2DP_UpdateFeatureToSpecLhdcV3(cfgsPtr, toCodecCfg, hasFeature,
+        a2dp_lhdc_source_caps_LARC.inSpecBank, A2DP_LHDC_LARC_ENABLED);
+    break;
+  case LHDC_EXTEND_FUNC_A2DP_LHDC_V4_CODE:
+    A2DP_UpdateFeatureToSpecLhdcV3(cfgsPtr, toCodecCfg, hasFeature,
+        a2dp_lhdc_source_caps_LHDCV4.inSpecBank, A2DP_LHDC_V4_ENABLED);
+    break;
+
+  default:
+    break;
+  }
+}
+
+
+static uint32_t A2DP_MaxBitRatetoQualityLevelLhdcV3(uint8_t maxTargetBitrate)
+{
+  switch (maxTargetBitrate & A2DP_LHDC_MAX_BIT_RATE_MASK)
+  {
+  case A2DP_LHDC_MAX_BIT_RATE_900K:
+    return A2DP_LHDC_QUALITY_HIGH;
+  case A2DP_LHDC_MAX_BIT_RATE_500K:
+    return A2DP_LHDC_QUALITY_MID;
+  case A2DP_LHDC_MAX_BIT_RATE_400K:
+    return A2DP_LHDC_QUALITY_LOW;
+  default:
+    return (0xFF);
+  }
+}
+
+const char* A2DP_VendorCodecNameLhdcV3Sink(UNUSED_ATTR const uint8_t* p_codec_info) {
+  return "LHDC V3 Sink";
+}
+
+bool A2DP_IsVendorSinkCodecValidLhdcV3(const uint8_t* p_codec_info) {
+  tA2DP_LHDCV3_SINK_CIE cfg_cie;
+
+  /* Use a liberal check when parsing the codec info */
+  return (A2DP_ParseInfoLhdcV3Sink(&cfg_cie, p_codec_info, false) == A2DP_SUCCESS) ||
+         (A2DP_ParseInfoLhdcV3Sink(&cfg_cie, p_codec_info, true) == A2DP_SUCCESS);
+}
+
+
+bool A2DP_IsVendorPeerSourceCodecValidLhdcV3(const uint8_t* p_codec_info) {
+  tA2DP_LHDCV3_SINK_CIE cfg_cie;
+
+  /* Use a liberal check when parsing the codec info */
+  return (A2DP_ParseInfoLhdcV3Sink(&cfg_cie, p_codec_info, false) == A2DP_SUCCESS) ||
+         (A2DP_ParseInfoLhdcV3Sink(&cfg_cie, p_codec_info, true) == A2DP_SUCCESS);
+}
+
+
+tA2DP_STATUS A2DP_IsVendorSinkCodecSupportedLhdcV3(const uint8_t* p_codec_info) {
+  return A2DP_CodecInfoMatchesCapabilityLhdcV3Sink(&a2dp_lhdcv3_sink_caps, p_codec_info, false);
+}
+
+bool A2DP_IsPeerSourceCodecSupportedLhdcV3(const uint8_t* p_codec_info) {
+  return (A2DP_CodecInfoMatchesCapabilityLhdcV3Sink(&a2dp_lhdcv3_sink_caps, p_codec_info,
+                                             true) == A2DP_SUCCESS);
+}
+
+void A2DP_InitDefaultCodecLhdcV3Sink(uint8_t* p_codec_info) {
+  log::info(": enter");
+  if (A2DP_BuildInfoLhdcV3Sink(AVDT_MEDIA_TYPE_AUDIO, &a2dp_lhdcv3_sink_default_config,
+                        p_codec_info) != A2DP_SUCCESS) {
+    log::error(": A2DP_BuildInfoSbc failed");
+  }
+}
+
+// Checks whether A2DP SBC codec configuration matches with a device's codec
+// capabilities. |p_cap| is the SBC codec configuration. |p_codec_info| is
+// the device's codec capabilities. |is_capability| is true if
+// |p_codec_info| contains A2DP codec capability.
+// Returns A2DP_SUCCESS if the codec configuration matches with capabilities,
+// otherwise the corresponding A2DP error status code.
+static tA2DP_STATUS A2DP_CodecInfoMatchesCapabilityLhdcV3Sink(
+    const tA2DP_LHDCV3_SINK_CIE* p_cap, const uint8_t* p_codec_info,
+    bool is_capability) {
+  tA2DP_STATUS status;
+  tA2DP_LHDCV3_SINK_CIE cfg_cie;
+
+  /* parse configuration */
+  status = A2DP_ParseInfoLhdcV3Sink(&cfg_cie, p_codec_info, is_capability);
+  if (status != A2DP_SUCCESS) {
+    log::error(": parsing failed {}", status);
+    return status;
+  }
+
+  /* verify that each parameter is in range */
+
+  log::info(": FREQ peer: 0x{:02x}, capability 0x{:02x}",
+            cfg_cie.sampleRate, p_cap->sampleRate);
+
+  log::info(": BIT_FMT peer: 0x{:02x}, capability 0x{:02x}",
+            cfg_cie.bits_per_sample, p_cap->bits_per_sample);
+
+  /* sampling frequency */
+  if ((cfg_cie.sampleRate & p_cap->sampleRate) == 0) return A2DP_NOT_SUPPORTED_SAMPLING_FREQUENCY;
+
+  /* bit per sample */
+  if ((cfg_cie.bits_per_sample & p_cap->bits_per_sample) == 0) return A2DP_NOT_SUPPORTED_CHANNEL_MODE;
+
+  return A2DP_SUCCESS;
+}
+
+bool A2DP_VendorCodecTypeEqualsLhdcV3Sink(const uint8_t* p_codec_info_a,
+                                    const uint8_t* p_codec_info_b) {
+  tA2DP_LHDCV3_SINK_CIE lhdc_cie_a;
+  tA2DP_LHDCV3_SINK_CIE lhdc_cie_b;
+
+  // Check whether the codec info contains valid data
+  tA2DP_STATUS a2dp_status =
+      A2DP_ParseInfoLhdcV3Sink(&lhdc_cie_a, p_codec_info_a, true);
+  if (a2dp_status != A2DP_SUCCESS) {
+    log::error(": cannot decode codec information: {}",
+              a2dp_status);
+    return false;
+  }
+  a2dp_status = A2DP_ParseInfoLhdcV3Sink(&lhdc_cie_b, p_codec_info_b, true);
+  if (a2dp_status != A2DP_SUCCESS) {
+    log::error(": cannot decode codec information: {}",
+              a2dp_status);
+    return false;
+  }
+
+  return true;
+}
+
+bool A2DP_VendorCodecEqualsLhdcV3Sink(const uint8_t* p_codec_info_a,
+                                const uint8_t* p_codec_info_b) {
+  tA2DP_LHDCV3_SINK_CIE lhdc_cie_a;
+  tA2DP_LHDCV3_SINK_CIE lhdc_cie_b;
+
+  // Check whether the codec info contains valid data
+  tA2DP_STATUS a2dp_status =
+      A2DP_ParseInfoLhdcV3Sink(&lhdc_cie_a, p_codec_info_a, true);
+  if (a2dp_status != A2DP_SUCCESS) {
+    log::error(": cannot decode codec information: {}",
+              a2dp_status);
+    return false;
+  }
+  a2dp_status = A2DP_ParseInfoLhdcV3Sink(&lhdc_cie_b, p_codec_info_b, true);
+  if (a2dp_status != A2DP_SUCCESS) {
+    log::error(": cannot decode codec information: {}",
+              a2dp_status);
+    return false;
+  }
+
+  return (lhdc_cie_a.sampleRate == lhdc_cie_b.sampleRate) &&
+         (lhdc_cie_a.bits_per_sample == lhdc_cie_b.bits_per_sample) &&
+         /*(lhdc_cie_a.supportedBitrate == lhdc_cie_b.supportedBitrate) &&*/
+         (lhdc_cie_a.isLLSupported == lhdc_cie_b.isLLSupported);
+}
+
+
+int A2DP_VendorGetTrackSampleRateLhdcV3Sink(const uint8_t* p_codec_info) {
+  tA2DP_LHDCV3_SINK_CIE lhdc_cie;
+
+  // Check whether the codec info contains valid data
+  tA2DP_STATUS a2dp_status = A2DP_ParseInfoLhdcV3Sink(&lhdc_cie, p_codec_info, false);
+  if (a2dp_status != A2DP_SUCCESS) {
+    log::error(": cannot decode codec information: {}",
+              a2dp_status);
+    return -1;
+  }
+
+  switch (lhdc_cie.sampleRate) {
+    case A2DP_LHDC_SAMPLING_FREQ_44100:
+      return 44100;
+    case A2DP_LHDC_SAMPLING_FREQ_48000:
+      return 48000;
+    case A2DP_LHDC_SAMPLING_FREQ_88200:
+      return 88200;
+    case A2DP_LHDC_SAMPLING_FREQ_96000:
+      return 96000;
+  }
+
+  return -1;
+}
+
+int A2DP_VendorGetSinkTrackChannelTypeLhdcV3(const uint8_t* p_codec_info) {
+  tA2DP_LHDCV3_SINK_CIE lhdc_cie;
+
+  // Check whether the codec info contains valid data
+  tA2DP_STATUS a2dp_status = A2DP_ParseInfoLhdcV3Sink(&lhdc_cie, p_codec_info, false);
+  if (a2dp_status != A2DP_SUCCESS) {
+    log::error(": cannot decode codec information: {}",
+              a2dp_status);
+    return -1;
+  }
+
+  return A2DP_LHDC_CHANNEL_MODE_STEREO;
+}
+
+int A2DP_VendorGetChannelModeCodeLhdcV3Sink(const uint8_t* p_codec_info) {
+  tA2DP_LHDCV3_SINK_CIE lhdc_cie;
+
+  // Check whether the codec info contains valid data
+  tA2DP_STATUS a2dp_status = A2DP_ParseInfoLhdcV3Sink(&lhdc_cie, p_codec_info, false);
+  if (a2dp_status != A2DP_SUCCESS) {
+    log::error(": cannot decode codec information: {}",
+              a2dp_status);
+    return -1;
+  }
+  return A2DP_LHDC_CHANNEL_MODE_STEREO;
+}
+
+bool A2DP_VendorGetPacketTimestampLhdcV3Sink(UNUSED_ATTR const uint8_t* p_codec_info,
+                                       const uint8_t* p_data,
+                                       uint32_t* p_timestamp) {
+  // TODO: Is this function really codec-specific?
+  *p_timestamp = *(const uint32_t*)p_data;
+  return true;
+}
+/*
+bool A2DP_VendorBuildCodecHeaderLhdcV3Sink(UNUSED_ATTR const uint8_t* p_codec_info,
+                              BT_HDR* p_buf, uint16_t frames_per_packet) {
+  uint8_t* p;
+
+  p_buf->offset -= A2DP_SBC_MPL_HDR_LEN;
+  p = (uint8_t*)(p_buf + 1) + p_buf->offset;
+  p_buf->len += A2DP_SBC_MPL_HDR_LEN;
+  A2DP_BuildMediaPayloadHeaderSbc(p, false, false, false,
+                                  (uint8_t)frames_per_packet);
+
+  return true;
+}
+*/
+std::string A2DP_VendorCodecInfoStringLhdcV3Sink(const uint8_t* p_codec_info) {
+  std::stringstream res;
+  std::string field;
+  tA2DP_STATUS a2dp_status;
+  tA2DP_LHDCV3_SINK_CIE lhdc_cie;
+
+  a2dp_status = A2DP_ParseInfoLhdcV3Sink(&lhdc_cie, p_codec_info, true);
+  if (a2dp_status != A2DP_SUCCESS) {
+    res << "A2DP_ParseInfoLhdcV3Sink fail: "
+        << loghex(static_cast<uint8_t>(a2dp_status));
+    return res.str();
+  }
+
+  res << "\tname: LHDC\n";
+
+  // Sample frequency
+  field.clear();
+  AppendField(&field, (lhdc_cie.sampleRate == 0), "NONE");
+  AppendField(&field, (lhdc_cie.sampleRate & A2DP_LHDC_SAMPLING_FREQ_44100),
+              "44100");
+  AppendField(&field, (lhdc_cie.sampleRate & A2DP_LHDC_SAMPLING_FREQ_48000),
+              "48000");
+  AppendField(&field, (lhdc_cie.sampleRate & A2DP_LHDC_SAMPLING_FREQ_88200),
+              "88200");
+  AppendField(&field, (lhdc_cie.sampleRate & A2DP_LHDC_SAMPLING_FREQ_96000),
+              "96000");
+  res << "\tsamp_freq: " << field << " (" << loghex(lhdc_cie.sampleRate)
+      << ")\n";
+
+  // Channel mode
+  field.clear();
+  AppendField(&field, 1,
+             "Stereo");
+  res << "\tch_mode: " << field << " (" << "Only support stereo."
+      << ")\n";
+
+  // bits per sample
+  field.clear();
+  AppendField(&field, (lhdc_cie.bits_per_sample & BTAV_A2DP_CODEC_BITS_PER_SAMPLE_16),
+              "16");
+  AppendField(&field, (lhdc_cie.bits_per_sample & BTAV_A2DP_CODEC_BITS_PER_SAMPLE_24),
+              "24");
+  res << "\tbits_depth: " << field << " bits (" << loghex((int)lhdc_cie.bits_per_sample)
+      << ")\n";
+
+  // Max data rate...
+  field.clear();
+  AppendField(&field, ((lhdc_cie.maxTargetBitrate & A2DP_LHDC_MAX_BIT_RATE_MASK) == A2DP_LHDC_MAX_BIT_RATE_900K),
+              "900Kbps");
+  AppendField(&field, ((lhdc_cie.maxTargetBitrate & A2DP_LHDC_MAX_BIT_RATE_MASK) == A2DP_LHDC_MAX_BIT_RATE_500K),
+              "500Kbps");
+  AppendField(&field, ((lhdc_cie.maxTargetBitrate & A2DP_LHDC_MAX_BIT_RATE_MASK) == A2DP_LHDC_MAX_BIT_RATE_400K),
+              "400Kbps");
+  res << "\tMax target-rate: " << field << " (" << loghex((lhdc_cie.maxTargetBitrate & A2DP_LHDC_MAX_BIT_RATE_MASK))
+      << ")\n";
+
+  // Version
+  field.clear();
+  AppendField(&field, (lhdc_cie.version == A2DP_LHDC_VER3),
+              "LHDC V3");
+  res << "\tversion: " << field << " (" << loghex(lhdc_cie.version)
+      << ")\n";
+
+
+  /*
+  field.clear();
+  AppendField(&field, 0, "NONE");
+  AppendField(&field, 0,
+              "Mono");
+  AppendField(&field, 0,
+              "Dual");
+  AppendField(&field, 1,
+              "Stereo");
+  res << "\tch_mode: " << field << " (" << loghex(lhdc_cie.channelMode)
+      << ")\n";
+*/
+  return res.str();
+}
+
+const tA2DP_DECODER_INTERFACE* A2DP_VendorGetDecoderInterfaceLhdcV3(
+    const uint8_t* p_codec_info) {
+  if (!A2DP_IsVendorSinkCodecValidLhdcV3(p_codec_info)) return NULL;
+
+  return &a2dp_decoder_interface_lhdcv3;
+}
+
+bool A2DP_VendorAdjustCodecLhdcV3Sink(uint8_t* p_codec_info) {
+  tA2DP_LHDCV3_SINK_CIE cfg_cie;
+
+  // Nothing to do: just verify the codec info is valid
+  if (A2DP_ParseInfoLhdcV3Sink(&cfg_cie, p_codec_info, true) != A2DP_SUCCESS)
+    return false;
+
+  return true;
+}
+
+btav_a2dp_codec_index_t A2DP_VendorSinkCodecIndexLhdcV3(
+    UNUSED_ATTR const uint8_t* p_codec_info) {
+  return BTAV_A2DP_CODEC_INDEX_SINK_LHDCV3;
+}
+
+const char* A2DP_VendorCodecIndexStrLhdcV3Sink(void) { return "LHDC V3 SINK"; }
+
+bool A2DP_VendorInitCodecConfigLhdcV3Sink(AvdtpSepConfig* p_cfg) {
+  log::info(": enter");
+  if (A2DP_BuildInfoLhdcV3Sink(AVDT_MEDIA_TYPE_AUDIO, &a2dp_lhdcv3_sink_caps,
+                        p_cfg->codec_info) != A2DP_SUCCESS) {
+    return false;
+  }
+
+  return true;
+}
+
+UNUSED_ATTR static void build_codec_config(const tA2DP_LHDCV3_SINK_CIE& config_cie,
+                                           btav_a2dp_codec_config_t* result) {
+  if (config_cie.sampleRate & A2DP_LHDC_SAMPLING_FREQ_44100)
+    result->sample_rate |= BTAV_A2DP_CODEC_SAMPLE_RATE_44100;
+  if (config_cie.sampleRate & A2DP_LHDC_SAMPLING_FREQ_48000)
+    result->sample_rate |= BTAV_A2DP_CODEC_SAMPLE_RATE_48000;
+  if (config_cie.sampleRate & A2DP_LHDC_SAMPLING_FREQ_88200)
+    result->sample_rate |= BTAV_A2DP_CODEC_SAMPLE_RATE_88200;
+  if (config_cie.sampleRate & A2DP_LHDC_SAMPLING_FREQ_96000)
+    result->sample_rate |= BTAV_A2DP_CODEC_SAMPLE_RATE_96000;
+
+  result->bits_per_sample = config_cie.bits_per_sample;
+
+  result->channel_mode |= BTAV_A2DP_CODEC_CHANNEL_MODE_STEREO;
+}
+
+
+
+
+
+A2dpCodecConfigLhdcV3Sink::A2dpCodecConfigLhdcV3Sink(
+    btav_a2dp_codec_priority_t codec_priority)
+    : A2dpCodecConfigLhdcV3Base(BTAV_A2DP_CODEC_INDEX_SINK_LHDCV3,
+                             A2DP_VendorCodecIndexStrLhdcV3Sink(), codec_priority,
+                             false) {}
+
+A2dpCodecConfigLhdcV3Sink::~A2dpCodecConfigLhdcV3Sink() {}
+
+bool A2dpCodecConfigLhdcV3Sink::init() {
+  // Load the decoder
+  if (!A2DP_VendorLoadDecoderLhdcV3()) {
+    log::error(": cannot load the decoder");
+    return false;
+  }
+
+  return true;
+}
+
+bool A2dpCodecConfigLhdcV3Sink::useRtpHeaderMarkerBit() const {
+  // TODO: This method applies only to Source codecs
+  return false;
+}
+
+#if 0
+bool A2dpCodecConfigLhdcV3Sink::updateEncoderUserConfig(
+    UNUSED_ATTR const tA2DP_ENCODER_INIT_PEER_PARAMS* p_peer_params,
+    UNUSED_ATTR bool* p_restart_input, UNUSED_ATTR bool* p_restart_output,
+    UNUSED_ATTR bool* p_config_updated) {
+  // TODO: This method applies only to Source codecs
+  return false;
+}
+#endif
+
+#if 0
+uint64_t A2dpCodecConfigLhdcV3Sink::encoderIntervalMs() const {
+  // TODO: This method applies only to Source codecs
+  return 0;
+}
+#endif
+
+#if 0
+int A2dpCodecConfigLhdcV3Sink::getEffectiveMtu() const {
+  // TODO: This method applies only to Source codecs
+  return 0;
+}
+#endif
+
+tA2DP_STATUS A2dpCodecConfigLhdcV3Base::setCodecConfig(const uint8_t* p_peer_codec_info, bool is_capability,
+                      uint8_t* p_result_codec_config) {
+  std::lock_guard<std::recursive_mutex> lock(codec_mutex_);
+  is_source_ = false;
+  tA2DP_LHDCV3_SINK_CIE sink_info_cie;
+  tA2DP_LHDCV3_SINK_CIE result_config_cie;
+  uint8_t sampleRate;
+  bool isLLEnabled;
+  bool hasFeature = false;
+  bool hasUserSet = false;
+  uint32_t quality_mode, maxBitRate_Qmode;
+  //uint8_t supportedBitrate;
+  btav_a2dp_codec_bits_per_sample_t bits_per_sample;
+
+  // Save the internal state
+  btav_a2dp_codec_config_t saved_codec_config = codec_config_;
+  btav_a2dp_codec_config_t saved_codec_capability = codec_capability_;
+  btav_a2dp_codec_config_t saved_codec_selectable_capability =
+      codec_selectable_capability_;
+  btav_a2dp_codec_config_t saved_codec_user_config = codec_user_config_;
+  btav_a2dp_codec_config_t saved_codec_audio_config = codec_audio_config_;
+  uint8_t saved_ota_codec_config[AVDT_CODEC_SIZE];
+  uint8_t saved_ota_codec_peer_capability[AVDT_CODEC_SIZE];
+  uint8_t saved_ota_codec_peer_config[AVDT_CODEC_SIZE];
+  memcpy(saved_ota_codec_config, ota_codec_config_, sizeof(ota_codec_config_));
+  memcpy(saved_ota_codec_peer_capability, ota_codec_peer_capability_,
+         sizeof(ota_codec_peer_capability_));
+  memcpy(saved_ota_codec_peer_config, ota_codec_peer_config_,
+         sizeof(ota_codec_peer_config_));
+
+  tA2DP_CODEC_CONFIGS_PACK allCfgPack;
+  allCfgPack._codec_config_ = &codec_config_;
+  allCfgPack._codec_capability_ = &codec_capability_;
+  allCfgPack._codec_local_capability_ = &codec_local_capability_;
+  allCfgPack._codec_selectable_capability_ = &codec_selectable_capability_;
+  allCfgPack._codec_user_config_ = &codec_user_config_;
+  allCfgPack._codec_audio_config_ = &codec_audio_config_;
+
+  tA2DP_STATUS status =
+      A2DP_ParseInfoLhdcV3Sink(&sink_info_cie, p_peer_codec_info, is_capability);
+  if (status != A2DP_SUCCESS) {
+    log::error( ": can't parse peer's Sink capabilities: error = {}",
+               status);
+    goto fail;
+  }
+
+  //
+  // Build the preferred configuration
+  //
+  memset(&result_config_cie, 0, sizeof(result_config_cie));
+  result_config_cie.vendorId = a2dp_lhdcv3_sink_caps.vendorId;
+  result_config_cie.codecId = a2dp_lhdcv3_sink_caps.codecId;
+
+
+  log::info( ": incoming version: peer(0x{:02x}), host(0x{:02x})",
+             sink_info_cie.version, a2dp_lhdcv3_sink_caps.version);
+
+  // 2021/08/19: when sink's version is "V3_NotComapatible(version == A2DP_LHDC_VER6(0x8))",
+  //        wrap it to A2DP_LHDC_VER3 to accept and treat as an A2DP_LHDC_VER3 device.
+  if(sink_info_cie.version == A2DP_LHDC_VER6) {
+    sink_info_cie.version = A2DP_LHDC_VER3;
+    log::info( ": wrap V3_NotComapatible sink version to A2DP_LHDC_VER3");
+  }
+
+  if ((sink_info_cie.version & a2dp_lhdcv3_sink_caps.version) == 0) {
+    log::error( ": Sink versoin unsupported! peer(0x{:02x}), host(0x{:02x})",
+               sink_info_cie.version, a2dp_lhdcv3_sink_caps.version);
+    goto fail;
+  }
+  result_config_cie.version = sink_info_cie.version;
+
+  /*******************************************
+   * Update Capabilities: LHDC Low Latency
+   * to A2DP specifics 2
+   *******************************************/
+  isLLEnabled = (a2dp_lhdcv3_sink_caps.isLLSupported & sink_info_cie.isLLSupported);
+  result_config_cie.isLLSupported = false;
+  switch (codec_user_config_.codec_specific_2 & A2DP_LHDC_LL_ENABLED) {
+    case A2DP_LHDC_LL_ENABLE:
+    if (isLLEnabled) {
+      result_config_cie.isLLSupported = true;
+      codec_config_.codec_specific_2 |= A2DP_LHDC_LL_ENABLED;
+    }
+    break;
+    case A2DP_LHDC_LL_DISABLE:
+    if (!isLLEnabled) {
+      result_config_cie.isLLSupported = false;
+      codec_config_.codec_specific_2 &= ~A2DP_LHDC_LL_ENABLED;
+    }
+    break;
+  }
+  if (isLLEnabled) {
+    codec_selectable_capability_.codec_specific_2 |= A2DP_LHDC_LL_ENABLED;
+    codec_capability_.codec_specific_2 |= A2DP_LHDC_LL_ENABLED;
+  }
+  //result_config_cie.isLLSupported = sink_info_cie.isLLSupported;
+  log::info( ": isLLSupported, Sink(0x{:02x}) Set(0x{:02x}), result(0x{:02x})",
+                                sink_info_cie.isLLSupported,
+                                (uint32_t)codec_user_config_.codec_specific_2,
+                                result_config_cie.isLLSupported);
+
+  //
+  // Select the sample frequency
+  //
+  sampleRate = a2dp_lhdcv3_sink_caps.sampleRate & sink_info_cie.sampleRate;
+  log::info(": sampleRate:peer:0x{:02x} local:0x{:02x} cap:0x{:02x} user:0x{:02x} ",
+       sink_info_cie.sampleRate, a2dp_lhdcv3_sink_caps.sampleRate,
+      sampleRate, codec_user_config_.sample_rate);
+
+  codec_config_.sample_rate = BTAV_A2DP_CODEC_SAMPLE_RATE_NONE;
+  switch (codec_user_config_.sample_rate) {
+    case BTAV_A2DP_CODEC_SAMPLE_RATE_44100:
+      if (sampleRate & A2DP_LHDC_SAMPLING_FREQ_44100) {
+        result_config_cie.sampleRate = A2DP_LHDC_SAMPLING_FREQ_44100;
+        codec_capability_.sample_rate = codec_user_config_.sample_rate;
+        codec_config_.sample_rate = codec_user_config_.sample_rate;
+      }
+      break;
+    case BTAV_A2DP_CODEC_SAMPLE_RATE_48000:
+      if (sampleRate & A2DP_LHDC_SAMPLING_FREQ_48000) {
+        result_config_cie.sampleRate = A2DP_LHDC_SAMPLING_FREQ_48000;
+        codec_capability_.sample_rate = codec_user_config_.sample_rate;
+        codec_config_.sample_rate = codec_user_config_.sample_rate;
+      }
+      break;
+    case BTAV_A2DP_CODEC_SAMPLE_RATE_88200:
+      if (sampleRate & A2DP_LHDC_SAMPLING_FREQ_88200) {
+        result_config_cie.sampleRate = A2DP_LHDC_SAMPLING_FREQ_88200;
+        codec_capability_.sample_rate = codec_user_config_.sample_rate;
+        codec_config_.sample_rate = codec_user_config_.sample_rate;
+      }
+      break;
+    case BTAV_A2DP_CODEC_SAMPLE_RATE_96000:
+      if (sampleRate & A2DP_LHDC_SAMPLING_FREQ_96000) {
+        result_config_cie.sampleRate = A2DP_LHDC_SAMPLING_FREQ_96000;
+        codec_capability_.sample_rate = codec_user_config_.sample_rate;
+        codec_config_.sample_rate = codec_user_config_.sample_rate;
+      }
+      break;
+    case BTAV_A2DP_CODEC_SAMPLE_RATE_16000:
+    case BTAV_A2DP_CODEC_SAMPLE_RATE_24000:
+    case BTAV_A2DP_CODEC_SAMPLE_RATE_176400:
+    case BTAV_A2DP_CODEC_SAMPLE_RATE_192000:
+    case BTAV_A2DP_CODEC_SAMPLE_RATE_NONE:
+      codec_capability_.sample_rate = BTAV_A2DP_CODEC_SAMPLE_RATE_NONE;
+      codec_config_.sample_rate = BTAV_A2DP_CODEC_SAMPLE_RATE_NONE;
+      break;
+  }
+
+  // Select the sample frequency if there is no user preference
+  do {
+    // Compute the selectable capability
+    if (sampleRate & A2DP_LHDC_SAMPLING_FREQ_44100) {
+      codec_selectable_capability_.sample_rate |=
+          BTAV_A2DP_CODEC_SAMPLE_RATE_44100;
+    }
+    if (sampleRate & A2DP_LHDC_SAMPLING_FREQ_48000) {
+      codec_selectable_capability_.sample_rate |=
+          BTAV_A2DP_CODEC_SAMPLE_RATE_48000;
+    }
+    if (sampleRate & A2DP_LHDC_SAMPLING_FREQ_88200) {
+      codec_selectable_capability_.sample_rate |=
+          BTAV_A2DP_CODEC_SAMPLE_RATE_88200;
+    }
+    if (sampleRate & A2DP_LHDC_SAMPLING_FREQ_96000) {
+      codec_selectable_capability_.sample_rate |=
+          BTAV_A2DP_CODEC_SAMPLE_RATE_96000;
+    }
+
+    //Above Parts: if codec_config is setup successfully(ie., sampleRate in codec_user_config_ is valid), ignore following parts.
+    if (codec_config_.sample_rate != BTAV_A2DP_CODEC_SAMPLE_RATE_NONE) {
+      log::info( ": setup sample_rate:0x{:02x} from user_config", codec_config_.sample_rate);
+      break;
+    }
+    //Below Parts: if codec_config is still not setup successfully, test default sample rate or use the best match
+
+    // Compute the common capability
+    if (sampleRate & A2DP_LHDC_SAMPLING_FREQ_44100)
+      codec_capability_.sample_rate |= BTAV_A2DP_CODEC_SAMPLE_RATE_44100;
+    if (sampleRate & A2DP_LHDC_SAMPLING_FREQ_48000)
+      codec_capability_.sample_rate |= BTAV_A2DP_CODEC_SAMPLE_RATE_48000;
+    if (sampleRate & A2DP_LHDC_SAMPLING_FREQ_88200)
+      codec_capability_.sample_rate |= BTAV_A2DP_CODEC_SAMPLE_RATE_88200;
+    if (sampleRate & A2DP_LHDC_SAMPLING_FREQ_96000)
+      codec_capability_.sample_rate |= BTAV_A2DP_CODEC_SAMPLE_RATE_96000;
+
+    // No user preference - try the codec audio config
+    if (select_audio_sample_rate(&codec_audio_config_, sampleRate,
+                                 &result_config_cie, &codec_config_)) {
+      log::info( ": select audio sample rate:(0x{:02x})", result_config_cie.sampleRate);
+      break;
+    }
+
+    // No user preference - try the default config
+    if (sink_info_cie.hasFeatureLLAC) {
+      if (select_best_sample_rate(
+              a2dp_lhdcv3_sink_default_config.llac_sampleRate & sink_info_cie.sampleRate,
+              &result_config_cie, &codec_config_)) {
+      log::info( ": select best sample rate(LLAC default):0x{:02x}", result_config_cie.sampleRate);
+        break;
+      }
+    } else {
+      if (select_best_sample_rate(
+              a2dp_lhdcv3_sink_default_config.sampleRate & sink_info_cie.sampleRate,
+              &result_config_cie, &codec_config_)) {
+        log::info( ": select best sample rate(LHDC default):0x{:02x}", result_config_cie.sampleRate);
+        break;
+      }
+    }
+
+    // No user preference - use the best match
+    if (select_best_sample_rate(sampleRate, &result_config_cie,
+                                &codec_config_)) {
+      log::info( ": select best sample rate(best):0x{:02x}", result_config_cie.sampleRate);
+      break;
+    }
+  } while (false);
+  if (codec_config_.sample_rate == BTAV_A2DP_CODEC_SAMPLE_RATE_NONE) {
+    log::error(
+              ": cannot match sample frequency: source caps = 0x{:02x} "
+              "sink info = 0x{:02x}",
+               a2dp_lhdcv3_sink_caps.sampleRate, sink_info_cie.sampleRate);
+    goto fail;
+  }
+  codec_user_config_.sample_rate = codec_config_.sample_rate;
+  log::info( ": => sample rate(0x{:02x}) = {}",
+      result_config_cie.sampleRate,
+      lhdcV3_sampleRate_toString(result_config_cie.sampleRate).c_str());
+
+  //
+  // Select the bits per sample
+  //
+  // NOTE: this information is NOT included in the LHDC A2DP codec description
+  // that is sent OTA.
+  bits_per_sample = a2dp_lhdcv3_sink_caps.bits_per_sample & sink_info_cie.bits_per_sample;
+  log::info(": bits_per_sample:peer:0x{:02x} local:0x{:02x} cap:0x{:02x} user:0x{:02x}",
+       sink_info_cie.bits_per_sample, a2dp_lhdcv3_sink_caps.bits_per_sample,
+      bits_per_sample, codec_user_config_.bits_per_sample);
+  codec_config_.bits_per_sample = BTAV_A2DP_CODEC_BITS_PER_SAMPLE_NONE;
+  switch (codec_user_config_.bits_per_sample) {
+    case BTAV_A2DP_CODEC_BITS_PER_SAMPLE_16:
+      if (bits_per_sample & BTAV_A2DP_CODEC_BITS_PER_SAMPLE_16) {
+        result_config_cie.bits_per_sample = BTAV_A2DP_CODEC_BITS_PER_SAMPLE_16;
+        codec_capability_.bits_per_sample = codec_user_config_.bits_per_sample;
+        codec_config_.bits_per_sample = codec_user_config_.bits_per_sample;
+      }
+      break;
+    case BTAV_A2DP_CODEC_BITS_PER_SAMPLE_24:
+      if (bits_per_sample & BTAV_A2DP_CODEC_BITS_PER_SAMPLE_24) {
+        result_config_cie.bits_per_sample = BTAV_A2DP_CODEC_BITS_PER_SAMPLE_24;
+        codec_capability_.bits_per_sample = codec_user_config_.bits_per_sample;
+        codec_config_.bits_per_sample = codec_user_config_.bits_per_sample;
+      }
+      break;
+    case BTAV_A2DP_CODEC_BITS_PER_SAMPLE_32:
+    case BTAV_A2DP_CODEC_BITS_PER_SAMPLE_NONE:
+      result_config_cie.bits_per_sample = BTAV_A2DP_CODEC_BITS_PER_SAMPLE_NONE;
+      codec_capability_.bits_per_sample = BTAV_A2DP_CODEC_BITS_PER_SAMPLE_NONE;
+      codec_config_.bits_per_sample = BTAV_A2DP_CODEC_BITS_PER_SAMPLE_NONE;
+      break;
+  }
+
+  // Select the bits per sample if there is no user preference
+  do {
+    // Compute the selectable capability
+      // Compute the selectable capability
+      if (bits_per_sample & BTAV_A2DP_CODEC_BITS_PER_SAMPLE_16)
+        codec_selectable_capability_.bits_per_sample |= BTAV_A2DP_CODEC_BITS_PER_SAMPLE_16;
+      if (bits_per_sample & BTAV_A2DP_CODEC_BITS_PER_SAMPLE_24)
+        codec_selectable_capability_.bits_per_sample |= BTAV_A2DP_CODEC_BITS_PER_SAMPLE_24;
+
+    if (codec_config_.bits_per_sample != BTAV_A2DP_CODEC_BITS_PER_SAMPLE_NONE){
+      log::info( ": setup bit_per_sample:0x{:02x} user_config", codec_config_.bits_per_sample);
+      break;
+    }
+
+    // Compute the common capability
+    if (bits_per_sample & BTAV_A2DP_CODEC_BITS_PER_SAMPLE_16)
+      codec_capability_.bits_per_sample |= BTAV_A2DP_CODEC_BITS_PER_SAMPLE_16;
+    if (bits_per_sample & BTAV_A2DP_CODEC_BITS_PER_SAMPLE_24)
+      codec_capability_.bits_per_sample |= BTAV_A2DP_CODEC_BITS_PER_SAMPLE_24;
+
+    // No user preference - the the codec audio config
+    if (select_audio_bits_per_sample(&codec_audio_config_, bits_per_sample,
+                                     &result_config_cie, &codec_config_)) {
+      log::info( ": select audio bits_per_sample:0x{:02x}", result_config_cie.bits_per_sample);
+      break;
+    }
+
+    // No user preference - try the default config
+    if (select_best_bits_per_sample(a2dp_lhdcv3_sink_default_config.bits_per_sample & sink_info_cie.bits_per_sample,
+                                    &result_config_cie, &codec_config_)) {
+      log::info( ": select best bits_per_sample(default):0x{:02x}", result_config_cie.bits_per_sample);
+      break;
+    }
+
+    // No user preference - use the best match
+    if (select_best_bits_per_sample(bits_per_sample,
+                                    &result_config_cie, &codec_config_)) {
+      log::info( ": select best bits_per_sample(best):0x{:02x}", result_config_cie.bits_per_sample);
+      break;
+    }
+  } while (false);
+  if (codec_config_.bits_per_sample == BTAV_A2DP_CODEC_BITS_PER_SAMPLE_NONE) {
+    log::error(
+              ": cannot match bits per sample: default = 0x{:02x} "
+              "user preference = 0x{:02x}",
+               a2dp_lhdcv3_sink_default_config.bits_per_sample,
+              codec_user_config_.bits_per_sample);
+    goto fail;
+  }
+  codec_user_config_.bits_per_sample = codec_config_.bits_per_sample;
+  log::info( ": => bit per sample(0x{:02x}) = {}",
+      result_config_cie.bits_per_sample,
+      lhdcV3_bitPerSample_toString(result_config_cie.bits_per_sample).c_str());
+
+  //
+  // Select the channel mode
+  //
+  log::info( ": channelMode = Only supported stereo");
+  codec_config_.channel_mode = BTAV_A2DP_CODEC_CHANNEL_MODE_NONE;
+  switch (codec_user_config_.channel_mode) {
+    case BTAV_A2DP_CODEC_CHANNEL_MODE_STEREO:
+      codec_capability_.channel_mode = codec_user_config_.channel_mode;
+      codec_config_.channel_mode = codec_user_config_.channel_mode;
+      break;
+    case BTAV_A2DP_CODEC_CHANNEL_MODE_MONO:
+    case BTAV_A2DP_CODEC_CHANNEL_MODE_NONE:
+      codec_capability_.channel_mode = BTAV_A2DP_CODEC_CHANNEL_MODE_NONE;
+      codec_config_.channel_mode = BTAV_A2DP_CODEC_CHANNEL_MODE_NONE;
+      break;
+  }
+  codec_selectable_capability_.channel_mode = BTAV_A2DP_CODEC_CHANNEL_MODE_STEREO;
+  codec_capability_.channel_mode = BTAV_A2DP_CODEC_CHANNEL_MODE_STEREO;
+  codec_config_.channel_mode = BTAV_A2DP_CODEC_CHANNEL_MODE_STEREO;
+  if (codec_config_.channel_mode == BTAV_A2DP_CODEC_CHANNEL_MODE_NONE) {
+    log::error(": codec_config_.channel_mode != BTAV_A2DP_CODEC_CHANNEL_MODE_NONE or BTAV_A2DP_CODEC_CHANNEL_MODE_STEREO"
+              );
+    goto fail;
+  }
+
+  /*******************************************
+   * Update maxTargetBitrate
+   *
+   *******************************************/
+  result_config_cie.maxTargetBitrate = sink_info_cie.maxTargetBitrate;
+
+  log::info( ": Config Max bitrate result(0x{:02x})", result_config_cie.maxTargetBitrate);
+
+  /*******************************************
+   * Update channelSplitMode
+   *
+   *******************************************/
+  result_config_cie.channelSplitMode = sink_info_cie.channelSplitMode;
+  log::info(": channelSplitMode = {}", result_config_cie.channelSplitMode);
+
+
+  /*******************************************
+   * quality mode: magic num check and reconfigure
+   * to specific 1
+   *******************************************/
+  if ((codec_user_config_.codec_specific_1 & A2DP_LHDC_VENDOR_CMD_MASK) != A2DP_LHDC_QUALITY_MAGIC_NUM) {
+      codec_user_config_.codec_specific_1 = A2DP_LHDC_QUALITY_MAGIC_NUM | A2DP_LHDC_QUALITY_ABR;
+      log::info(": use default quality_mode:ABR");
+  }
+  quality_mode = codec_user_config_.codec_specific_1 & 0xff;
+
+  // (1000K) does not supported in V3, reset to 900K
+  if (quality_mode == A2DP_LHDC_QUALITY_HIGH1) {
+    codec_user_config_.codec_specific_1 = A2DP_LHDC_QUALITY_MAGIC_NUM | A2DP_LHDC_QUALITY_HIGH;
+    quality_mode = A2DP_LHDC_QUALITY_HIGH;
+    log::info(": reset non-supported quality_mode to ",
+        lhdcV3_QualityModeBitRate_toString(quality_mode).c_str());
+  }
+
+  /*******************************************
+   * LHDC features: safety tag check
+   * to specific 3
+   *******************************************/
+  if ((codec_user_config_.codec_specific_3 & A2DP_LHDC_VENDOR_FEATURE_MASK) != A2DP_LHDC_FEATURE_MAGIC_NUM)
+  {
+      log::info( ": LHDC feature tag not matched! use old feature settings");
+
+      /* *
+       * Magic num does not match:
+       * 1. add tag
+       * 2. Re-adjust previous feature(which refers to codec_user_config)'s state(in codec_config_) to codec_user_config_:
+       *  AR(has UI)
+       * */
+      // clean entire specific and set safety tag
+      codec_user_config_.codec_specific_3 = A2DP_LHDC_FEATURE_MAGIC_NUM;
+
+      // Feature: AR
+      hasUserSet = A2DP_IsFeatureInCodecConfigLhdcV3(&allCfgPack, LHDC_EXTEND_FUNC_A2DP_LHDC_AR_CODE);
+      A2DP_UpdateFeatureToA2dpConfigLhdcV3(
+          &allCfgPack,
+          LHDC_EXTEND_FUNC_A2DP_LHDC_AR_CODE,
+          A2DP_LHDC_TO_A2DP_CODEC_USER_,
+          (hasUserSet?true:false));
+      log::info( ": LHDC features tag check fail, reset UI status[AR] => {}", hasUserSet?"true":"false");
+  }
+
+  /*******************************************
+   *  LLAC: caps-control enabling
+   *******************************************/
+  {
+    hasFeature = (a2dp_lhdcv3_sink_caps.hasFeatureLLAC & sink_info_cie.hasFeatureLLAC);
+    result_config_cie.hasFeatureLLAC = false;
+    hasUserSet = true;  //caps-control enabling case => always true
+
+    A2DP_UpdateFeatureToA2dpConfigLhdcV3(
+        &allCfgPack,
+        LHDC_EXTEND_FUNC_A2DP_LHDC_LLAC_CODE,
+        (A2DP_LHDC_TO_A2DP_CODEC_CONFIG_| A2DP_LHDC_TO_A2DP_CODEC_CAP_ |
+            A2DP_LHDC_TO_A2DP_CODEC_SELECT_CAP_ | A2DP_LHDC_TO_A2DP_CODEC_USER_),
+        false);
+
+    if (hasFeature && hasUserSet) {
+      result_config_cie.hasFeatureLLAC = true;
+      A2DP_UpdateFeatureToA2dpConfigLhdcV3(
+          &allCfgPack,
+          LHDC_EXTEND_FUNC_A2DP_LHDC_LLAC_CODE,
+          (A2DP_LHDC_TO_A2DP_CODEC_CAP_ |
+              A2DP_LHDC_TO_A2DP_CODEC_SELECT_CAP_ | A2DP_LHDC_TO_A2DP_CODEC_USER_),
+          true);
+    }
+    log::info( ": featureLLAC: enabled? <{}> Peer:0x{:02x} Local:0x{:02x}",
+        (result_config_cie.hasFeatureLLAC?"Y":"N"),
+        sink_info_cie.hasFeatureLLAC,
+        a2dp_lhdcv3_sink_caps.hasFeatureLLAC);
+  }
+
+  /*******************************************
+   *  LHDCV4: caps-control enabling
+   *******************************************/
+  {
+    hasFeature = (a2dp_lhdcv3_sink_caps.hasFeatureLHDCV4 & sink_info_cie.hasFeatureLHDCV4);
+    result_config_cie.hasFeatureLHDCV4 = false;
+    hasUserSet = true;  //caps-control enabling case => always true
+
+    A2DP_UpdateFeatureToA2dpConfigLhdcV3(
+        &allCfgPack,
+        LHDC_EXTEND_FUNC_A2DP_LHDC_V4_CODE,
+        (A2DP_LHDC_TO_A2DP_CODEC_CONFIG_| A2DP_LHDC_TO_A2DP_CODEC_CAP_ |
+            A2DP_LHDC_TO_A2DP_CODEC_SELECT_CAP_ | A2DP_LHDC_TO_A2DP_CODEC_USER_),
+        false);
+
+    if (hasFeature && hasUserSet) {
+      result_config_cie.hasFeatureLHDCV4 = true;
+      A2DP_UpdateFeatureToA2dpConfigLhdcV3(
+          &allCfgPack,
+          LHDC_EXTEND_FUNC_A2DP_LHDC_V4_CODE,
+          (A2DP_LHDC_TO_A2DP_CODEC_CAP_ |
+              A2DP_LHDC_TO_A2DP_CODEC_SELECT_CAP_ | A2DP_LHDC_TO_A2DP_CODEC_USER_),
+          true);
+    }
+    log::info( ": featureV4: enabled? <{}> Peer:0x{:02x} Local:0x{:02x}",
+        (result_config_cie.hasFeatureLHDCV4?"Y":"N"),
+        sink_info_cie.hasFeatureLHDCV4,
+        a2dp_lhdcv3_sink_caps.hasFeatureLHDCV4);
+  }
+
+  /*******************************************
+   *  JAS: caps-control enabling
+   *******************************************/
+  {
+    //result_config_cie.hasFeatureJAS = sink_info_cie.hasFeatureJAS;
+    hasFeature = (a2dp_lhdcv3_sink_caps.hasFeatureJAS & sink_info_cie.hasFeatureJAS);
+    result_config_cie.hasFeatureJAS = false;
+    hasUserSet = true;  //caps-control enabling case => always true
+
+    A2DP_UpdateFeatureToA2dpConfigLhdcV3(
+        &allCfgPack,
+        LHDC_EXTEND_FUNC_A2DP_LHDC_JAS_CODE,
+        (A2DP_LHDC_TO_A2DP_CODEC_CONFIG_| A2DP_LHDC_TO_A2DP_CODEC_CAP_ |
+            A2DP_LHDC_TO_A2DP_CODEC_SELECT_CAP_ | A2DP_LHDC_TO_A2DP_CODEC_USER_),
+        false);
+
+    if (hasFeature && hasUserSet) {
+      result_config_cie.hasFeatureJAS = true;
+      A2DP_UpdateFeatureToA2dpConfigLhdcV3(
+          &allCfgPack,
+          LHDC_EXTEND_FUNC_A2DP_LHDC_JAS_CODE,
+          (A2DP_LHDC_TO_A2DP_CODEC_CAP_ |
+              A2DP_LHDC_TO_A2DP_CODEC_SELECT_CAP_ | A2DP_LHDC_TO_A2DP_CODEC_USER_),
+          true);
+    }
+    log::info( ": featureJAS: enabled? <{}> Peer:0x{:02x} Local:0x{:02x}",
+        (result_config_cie.hasFeatureJAS?"Y":"N"),
+        sink_info_cie.hasFeatureJAS,
+        a2dp_lhdcv3_sink_caps.hasFeatureJAS);
+  }
+
+  /*******************************************
+   * AR: user-control control enabling
+   *******************************************/
+  {
+    hasFeature = (a2dp_lhdcv3_sink_caps.hasFeatureAR & sink_info_cie.hasFeatureAR);
+    result_config_cie.hasFeatureAR = false;
+    hasUserSet = A2DP_IsFeatureInUserConfigLhdcV3(&allCfgPack, LHDC_EXTEND_FUNC_A2DP_LHDC_AR_CODE);
+
+    A2DP_UpdateFeatureToA2dpConfigLhdcV3(
+        &allCfgPack,
+        LHDC_EXTEND_FUNC_A2DP_LHDC_AR_CODE,
+        (A2DP_LHDC_TO_A2DP_CODEC_CONFIG_ | A2DP_LHDC_TO_A2DP_CODEC_CAP_ |
+            A2DP_LHDC_TO_A2DP_CODEC_SELECT_CAP_ | A2DP_LHDC_TO_A2DP_CODEC_USER_),
+        false);
+
+    if (hasFeature && hasUserSet) {
+      result_config_cie.hasFeatureAR = true;
+      A2DP_UpdateFeatureToA2dpConfigLhdcV3(
+          &allCfgPack,
+          LHDC_EXTEND_FUNC_A2DP_LHDC_AR_CODE,
+          (A2DP_LHDC_TO_A2DP_CODEC_CAP_ |
+              A2DP_LHDC_TO_A2DP_CODEC_SELECT_CAP_ | A2DP_LHDC_TO_A2DP_CODEC_USER_),
+          true);
+
+      /* Special Rule: AR only enable at the the sample rate of 48KHz */
+      if(codec_user_config_.sample_rate > BTAV_A2DP_CODEC_SAMPLE_RATE_48000) {
+        log::info( ": AR ON, adjust sample rate to 48KHz  ");
+        codec_config_.sample_rate = BTAV_A2DP_CODEC_SAMPLE_RATE_48000;
+        codec_user_config_.sample_rate = BTAV_A2DP_CODEC_SAMPLE_RATE_48000;
+        result_config_cie.sampleRate = A2DP_LHDC_SAMPLING_FREQ_48000;
+      }
+    }
+    log::info( ": featureAR: enabled? <{}> Peer:0x{:02x} Local:0x{:02x} User:{}",
+        (result_config_cie.hasFeatureAR?"Y":"N"),
+        sink_info_cie.hasFeatureAR,
+        a2dp_lhdcv3_sink_caps.hasFeatureAR,
+        (hasUserSet?"Y":"N"));
+  }
+
+  /*******************************************
+   * META: caps-control enabling
+   *******************************************/
+  {
+    hasFeature = (a2dp_lhdcv3_sink_caps.hasFeatureMETA & sink_info_cie.hasFeatureMETA);
+    result_config_cie.hasFeatureMETA = false;
+    hasUserSet = true;  //caps-control enabling, always true
+
+    A2DP_UpdateFeatureToA2dpConfigLhdcV3(
+        &allCfgPack,
+        LHDC_EXTEND_FUNC_A2DP_LHDC_META_CODE,
+        (A2DP_LHDC_TO_A2DP_CODEC_CONFIG_ | A2DP_LHDC_TO_A2DP_CODEC_CAP_ |
+            A2DP_LHDC_TO_A2DP_CODEC_SELECT_CAP_ | A2DP_LHDC_TO_A2DP_CODEC_USER_),
+        false);
+    // update
+    if (hasFeature && hasUserSet) {
+      result_config_cie.hasFeatureMETA = true;
+      A2DP_UpdateFeatureToA2dpConfigLhdcV3(
+          &allCfgPack,
+          LHDC_EXTEND_FUNC_A2DP_LHDC_META_CODE,
+          (A2DP_LHDC_TO_A2DP_CODEC_CAP_ |
+              A2DP_LHDC_TO_A2DP_CODEC_SELECT_CAP_ | A2DP_LHDC_TO_A2DP_CODEC_USER_),
+              true);
+    }
+    log::info( ": featureMETA:enabled? <{}> Peer:0x{:02x} Local:0x{:02x}",
+        (result_config_cie.hasFeatureMETA?"Y":"N"),
+        sink_info_cie.hasFeatureMETA,
+        a2dp_lhdcv3_sink_caps.hasFeatureMETA);
+  }
+
+  /*******************************************
+   * Min BitRate (MBR): caps-control enabling
+   *******************************************/
+  {
+    hasFeature = (a2dp_lhdcv3_sink_caps.hasFeatureMinBitrate & sink_info_cie.hasFeatureMinBitrate);
+    result_config_cie.hasFeatureMinBitrate = false;
+    hasUserSet = true;  //caps-control enabling, always true
+
+    A2DP_UpdateFeatureToA2dpConfigLhdcV3(
+        &allCfgPack,
+        LHDC_EXTEND_FUNC_A2DP_LHDC_MBR_CODE,
+        (A2DP_LHDC_TO_A2DP_CODEC_CONFIG_ | A2DP_LHDC_TO_A2DP_CODEC_CAP_ |
+            A2DP_LHDC_TO_A2DP_CODEC_SELECT_CAP_ | A2DP_LHDC_TO_A2DP_CODEC_USER_),
+        false);
+    // update
+    if (hasFeature && hasUserSet) {
+      result_config_cie.hasFeatureMinBitrate = true;
+      A2DP_UpdateFeatureToA2dpConfigLhdcV3(
+          &allCfgPack,
+          LHDC_EXTEND_FUNC_A2DP_LHDC_MBR_CODE,
+          (A2DP_LHDC_TO_A2DP_CODEC_CAP_ |
+              A2DP_LHDC_TO_A2DP_CODEC_SELECT_CAP_ | A2DP_LHDC_TO_A2DP_CODEC_USER_),
+              true);
+    }
+    log::info( ": featureMBR: enabled? <{}> Peer:0x{:02x} Local:0x{:02x}",
+        (result_config_cie.hasFeatureMinBitrate?"Y":"N"),
+        sink_info_cie.hasFeatureMinBitrate,
+        a2dp_lhdcv3_sink_caps.hasFeatureMinBitrate);
+  }
+
+  /*******************************************
+   * Update Feature/Capabilities: LARC
+   * to A2DP specifics
+   *******************************************/
+  // LARC is not supported
+
+  /*******************************************
+   * quality mode: re-adjust according to maxTargetBitrate(smaller one adopted)
+   *******************************************/
+  if ( (result_config_cie.hasFeatureLLAC && result_config_cie.hasFeatureLHDCV4) &&
+     (result_config_cie.sampleRate == A2DP_LHDC_SAMPLING_FREQ_96000) &&
+     (quality_mode != A2DP_LHDC_QUALITY_ABR))
+  {
+    //In this case, max bit rate mechanism is disabled(set to 900k)
+    result_config_cie.maxTargetBitrate = A2DP_LHDC_MAX_BIT_RATE_900K;
+    log::info(": [LLAC + LHDC V4]: set MBR (0x{:02x})", result_config_cie.maxTargetBitrate);
+
+    //dont re-adjust quality mode in this case
+    log::info(": do not adjust quality_mode in this case");
+  }
+  else
+  {
+    maxBitRate_Qmode = A2DP_MaxBitRatetoQualityLevelLhdcV3(result_config_cie.maxTargetBitrate);
+    if(maxBitRate_Qmode < 0xFF) {
+      if(quality_mode != A2DP_LHDC_QUALITY_ABR && quality_mode > maxBitRate_Qmode){
+        log::info(": adjust quality_mode:0x{:02x} to 0x{:02x} by maxTargetBitrate:0x{:02x}",
+            quality_mode, maxBitRate_Qmode, result_config_cie.maxTargetBitrate);
+        quality_mode = maxBitRate_Qmode;
+        codec_user_config_.codec_specific_1 = A2DP_LHDC_QUALITY_MAGIC_NUM | quality_mode;
+      }
+    }
+  }
+
+  /*
+   * Final Custom Rules of resolving conflict between capabilities and version
+   */
+  if (result_config_cie.hasFeatureLLAC && result_config_cie.hasFeatureLHDCV4) {
+    //LHDCV4 + LLAC
+    if (result_config_cie.sampleRate == A2DP_LHDC_SAMPLING_FREQ_96000) {
+
+      if (quality_mode == A2DP_LHDC_QUALITY_ABR) {
+    result_config_cie.sampleRate = A2DP_LHDC_SAMPLING_FREQ_48000;
+    codec_config_.sample_rate = BTAV_A2DP_CODEC_SAMPLE_RATE_48000;
+    codec_user_config_.sample_rate = BTAV_A2DP_CODEC_SAMPLE_RATE_48000; //also set UI settings
+    result_config_cie.hasFeatureLHDCV4 = false;
+    codec_config_.codec_specific_3 &= ~A2DP_LHDC_V4_ENABLED;
+    log::info(": [LLAC + LHDC V4]: LLAC, reset sampleRate (0x{:02x})", result_config_cie.sampleRate);
+      } else {
+        result_config_cie.hasFeatureLLAC = false;
+        codec_config_.codec_specific_3 &= ~A2DP_LHDC_LLAC_ENABLED;
+        log::info(": [LLAC + LHDC V4]: LHDC");
+
+        //result_config_cie.maxTargetBitrate = A2DP_LHDC_MAX_BIT_RATE_900K;
+        //log::info(": [LLAC + LHDC V4]: set MBR (0x{})", result_config_cie.maxTargetBitrate);
+
+        if (result_config_cie.hasFeatureMinBitrate) {
+          if (quality_mode < A2DP_LHDC_QUALITY_MID) {
+            codec_user_config_.codec_specific_1 = A2DP_LHDC_QUALITY_MAGIC_NUM | A2DP_LHDC_QUALITY_MID;
+            quality_mode = A2DP_LHDC_QUALITY_MID;
+            log::info(": [LLAC + LHDC V4]: LHDC 96KSR, reset Qmode (0x{:02x})", quality_mode);
+          }
+        } else {
+        if (quality_mode < A2DP_LHDC_QUALITY_LOW) {
+        codec_user_config_.codec_specific_1 = A2DP_LHDC_QUALITY_MAGIC_NUM | A2DP_LHDC_QUALITY_LOW;
+        quality_mode = A2DP_LHDC_QUALITY_LOW;
+        log::info(": [LLAC + LHDC V4]: LHDC 96KSR, reset Qmode (0x{:02x})", quality_mode);
+      }
+        }
+      }
+    } else if (
+        (result_config_cie.sampleRate == A2DP_LHDC_SAMPLING_FREQ_48000 && (quality_mode > A2DP_LHDC_QUALITY_LOW && quality_mode != A2DP_LHDC_QUALITY_ABR)) ||
+        (result_config_cie.sampleRate == A2DP_LHDC_SAMPLING_FREQ_44100 && (quality_mode > A2DP_LHDC_QUALITY_LOW && quality_mode != A2DP_LHDC_QUALITY_ABR))
+       ) {
+      result_config_cie.hasFeatureLLAC = false;
+      codec_config_.codec_specific_3 &= ~A2DP_LHDC_LLAC_ENABLED;
+      log::info(": [LLAC + LHDC V4]: LHDC");
+    } else if (
+       (result_config_cie.sampleRate == A2DP_LHDC_SAMPLING_FREQ_48000 && (quality_mode <= A2DP_LHDC_QUALITY_LOW || quality_mode == A2DP_LHDC_QUALITY_ABR)) ||
+       (result_config_cie.sampleRate == A2DP_LHDC_SAMPLING_FREQ_44100 && (quality_mode <= A2DP_LHDC_QUALITY_LOW || quality_mode == A2DP_LHDC_QUALITY_ABR))
+      ) {
+      result_config_cie.hasFeatureLHDCV4 = false;
+      codec_config_.codec_specific_3 &= ~A2DP_LHDC_V4_ENABLED;
+      log::info(": [LLAC + LHDC V4]: LLAC");
+
+      /* LLAC: prevent quality mode using 64kbps */
+      if (result_config_cie.hasFeatureMinBitrate) {
+      if (quality_mode < A2DP_LHDC_QUALITY_LOW1) {
+        codec_user_config_.codec_specific_1 = A2DP_LHDC_QUALITY_MAGIC_NUM | A2DP_LHDC_QUALITY_LOW1;
+        quality_mode = A2DP_LHDC_QUALITY_LOW1;
+        log::info(": [LLAC + LHDC V4]: LLAC, reset Qmode (0x{:02x})", quality_mode);
+      }
+      }
+    } else {
+      log::error(": [LLAC + LHDC V4]: format incorrect.");
+      goto fail;
+    }
+
+  } else if (!result_config_cie.hasFeatureLLAC && result_config_cie.hasFeatureLHDCV4) {
+    //LHDC V4 only
+    log::info(": [LHDCV4 only]");
+  if (result_config_cie.sampleRate == A2DP_LHDC_SAMPLING_FREQ_96000) {
+    if (result_config_cie.hasFeatureMinBitrate) {
+      if (quality_mode < A2DP_LHDC_QUALITY_LOW) {
+        codec_user_config_.codec_specific_1 = A2DP_LHDC_QUALITY_MAGIC_NUM | A2DP_LHDC_QUALITY_LOW;
+        quality_mode = A2DP_LHDC_QUALITY_LOW;
+        log::info(": [LHDCV4 only]: reset Qmode (0x{:02x})", quality_mode);
+      }
+    }
+  } else {
+    if (result_config_cie.hasFeatureMinBitrate) {
+      if (quality_mode < A2DP_LHDC_QUALITY_LOW4) {
+        codec_user_config_.codec_specific_1 = A2DP_LHDC_QUALITY_MAGIC_NUM | A2DP_LHDC_QUALITY_LOW4;
+        quality_mode = A2DP_LHDC_QUALITY_LOW4;
+        log::info(": [LHDCV4 only]: reset Qmode (0x{:02x}), ", quality_mode);
+      }
+    }
+  }
+
+  } else if (result_config_cie.hasFeatureLLAC && !result_config_cie.hasFeatureLHDCV4) {
+    //LLAC only
+    log::info(": [LLAC only]");
+    if (result_config_cie.sampleRate == A2DP_LHDC_SAMPLING_FREQ_96000) {
+      result_config_cie.sampleRate = A2DP_LHDC_SAMPLING_FREQ_48000;
+      codec_config_.sample_rate = BTAV_A2DP_CODEC_SAMPLE_RATE_48000;
+      codec_user_config_.sample_rate = BTAV_A2DP_CODEC_SAMPLE_RATE_48000; //also set UI settings
+      log::info(": [LLAC only]: reset SampleRate (0x{:02x})", result_config_cie.sampleRate);
+    }
+
+    if (quality_mode > A2DP_LHDC_QUALITY_LOW && quality_mode != A2DP_LHDC_QUALITY_ABR) {
+      codec_user_config_.codec_specific_1 = A2DP_LHDC_QUALITY_MAGIC_NUM | A2DP_LHDC_QUALITY_LOW;
+      quality_mode = A2DP_LHDC_QUALITY_LOW;
+      log::info(": [LLAC only]: reset Qmode (0x{:02x})", quality_mode);
+    }
+
+    /* LLAC: prevent quality mode using 64kbps */
+    if (result_config_cie.hasFeatureMinBitrate) {
+    if (quality_mode < A2DP_LHDC_QUALITY_LOW1) {
+      codec_user_config_.codec_specific_1 = A2DP_LHDC_QUALITY_MAGIC_NUM | A2DP_LHDC_QUALITY_LOW1;
+      quality_mode = A2DP_LHDC_QUALITY_LOW1;
+      log::info(": [LLAC only]: reset Qmode (0x{:02x})", quality_mode);
+    }
+    }
+
+  } else if (!result_config_cie.hasFeatureLLAC && !result_config_cie.hasFeatureLHDCV4) {
+    //LHDC V3 only
+    log::info(": [LHDCV3 only]");
+  if (result_config_cie.sampleRate == A2DP_LHDC_SAMPLING_FREQ_96000) {
+    if (result_config_cie.hasFeatureMinBitrate) {
+      if (quality_mode < A2DP_LHDC_QUALITY_LOW) {
+        codec_user_config_.codec_specific_1 = A2DP_LHDC_QUALITY_MAGIC_NUM | A2DP_LHDC_QUALITY_LOW;
+        quality_mode = A2DP_LHDC_QUALITY_LOW;
+        log::info(": [LHDCV3 only]: reset Qmode (0x{:02x})", quality_mode);
+      }
+    }
+  } else {
+    if (result_config_cie.hasFeatureMinBitrate) {
+      if (quality_mode < A2DP_LHDC_QUALITY_LOW4) {
+        codec_user_config_.codec_specific_1 = A2DP_LHDC_QUALITY_MAGIC_NUM | A2DP_LHDC_QUALITY_LOW4;
+        quality_mode = A2DP_LHDC_QUALITY_LOW4;
+        log::info(": [LHDCV3 only]: reset Qmode (0x{:02x}), ", quality_mode);
+      }
+    }
+  }
+  }
+
+  log::info(": Final quality_mode = ({}) ",
+      quality_mode,
+      lhdcV3_QualityModeBitRate_toString(quality_mode).c_str());
+
+  //
+  // Copy the codec-specific fields if they are not zero
+  //
+  if (codec_user_config_.codec_specific_1 != 0)
+    codec_config_.codec_specific_1 = codec_user_config_.codec_specific_1;
+  if (codec_user_config_.codec_specific_2 != 0)
+    codec_config_.codec_specific_2 = codec_user_config_.codec_specific_2;
+  if (codec_user_config_.codec_specific_3 != 0)
+    codec_config_.codec_specific_3 = codec_user_config_.codec_specific_3;
+  if (codec_user_config_.codec_specific_4 != 0)
+    codec_config_.codec_specific_4 = codec_user_config_.codec_specific_4;
+
+  /* Setup final nego result codec config to peer */
+  if (int ret = A2DP_BuildInfoLhdcV3Sink(AVDT_MEDIA_TYPE_AUDIO, &result_config_cie,
+                         p_result_codec_config) != A2DP_SUCCESS) {
+    log::error(": A2DP_BuildInfoLhdcV3Sink fail(0x{:02x})", ret);
+    goto fail;
+  }
+
+
+  // Create a local copy of the peer codec capability, and the
+  // result codec config.
+    log::error(": is_capability = {}", is_capability);
+  if (is_capability) {
+    status = A2DP_BuildInfoLhdcV3Sink(AVDT_MEDIA_TYPE_AUDIO, &sink_info_cie,
+                                ota_codec_peer_capability_);
+  } else {
+    status = A2DP_BuildInfoLhdcV3Sink(AVDT_MEDIA_TYPE_AUDIO, &sink_info_cie,
+                                ota_codec_peer_config_);
+  }
+  CHECK(status == A2DP_SUCCESS);
+
+  status = A2DP_BuildInfoLhdcV3Sink(AVDT_MEDIA_TYPE_AUDIO, &result_config_cie,
+                              ota_codec_config_);
+  CHECK(status == A2DP_SUCCESS);
+  return A2DP_SUCCESS;
+
+fail:
+  // Restore the internal state
+  codec_config_ = saved_codec_config;
+  codec_capability_ = saved_codec_capability;
+  codec_selectable_capability_ = saved_codec_selectable_capability;
+  codec_user_config_ = saved_codec_user_config;
+  codec_audio_config_ = saved_codec_audio_config;
+  memcpy(ota_codec_config_, saved_ota_codec_config, sizeof(ota_codec_config_));
+  memcpy(ota_codec_peer_capability_, saved_ota_codec_peer_capability,
+         sizeof(ota_codec_peer_capability_));
+  memcpy(ota_codec_peer_config_, saved_ota_codec_peer_config,
+         sizeof(ota_codec_peer_config_));
+  return status;
+}
+
+bool A2dpCodecConfigLhdcV3Base::setPeerCodecCapabilities(
+      const uint8_t* p_peer_codec_capabilities) {
+  std::lock_guard<std::recursive_mutex> lock(codec_mutex_);
+  is_source_ = false;
+  tA2DP_LHDCV3_SINK_CIE peer_info_cie;
+  uint8_t sampleRate;
+  uint8_t bits_per_sample;
+
+  // Save the internal state
+  btav_a2dp_codec_config_t saved_codec_selectable_capability =
+  codec_selectable_capability_;
+  uint8_t saved_ota_codec_peer_capability[AVDT_CODEC_SIZE];
+  memcpy(saved_ota_codec_peer_capability, ota_codec_peer_capability_,
+         sizeof(ota_codec_peer_capability_));
+
+  tA2DP_STATUS status =
+  A2DP_ParseInfoLhdcV3Sink(&peer_info_cie, p_peer_codec_capabilities, true);
+  if (status != A2DP_SUCCESS) {
+      log::error( ": can't parse peer's capabilities: error = {}",
+                 status);
+      goto fail;
+  }
+/*
+  if (peer_info_cie.version > a2dp_lhdc_source_caps.version) {
+      log::error( ": can't parse peer's capabilities: Missmatch version({}:{})",
+                 a2dp_lhdc_source_caps.version, peer_info_cie.version);
+      goto fail;
+  }
+*/
+
+  // Compute the selectable capability - bits per sample
+  //codec_selectable_capability_.bits_per_sample =
+  //a2dp_lhdc_source_caps.bits_per_sample;
+  bits_per_sample = a2dp_lhdcv3_sink_caps.bits_per_sample & peer_info_cie.bits_per_sample;
+  if (bits_per_sample & BTAV_A2DP_CODEC_BITS_PER_SAMPLE_16) {
+      codec_selectable_capability_.bits_per_sample |= BTAV_A2DP_CODEC_BITS_PER_SAMPLE_16;
+  }
+  if (bits_per_sample & BTAV_A2DP_CODEC_BITS_PER_SAMPLE_24) {
+      codec_selectable_capability_.bits_per_sample |= BTAV_A2DP_CODEC_BITS_PER_SAMPLE_24;
+  }
+
+
+  // Compute the selectable capability - sample rate
+  sampleRate = a2dp_lhdcv3_sink_caps.sampleRate & peer_info_cie.sampleRate;
+  if (sampleRate & A2DP_LHDC_SAMPLING_FREQ_44100) {
+      codec_selectable_capability_.sample_rate |=
+      BTAV_A2DP_CODEC_SAMPLE_RATE_44100;
+  }
+  if (sampleRate & A2DP_LHDC_SAMPLING_FREQ_48000) {
+      codec_selectable_capability_.sample_rate |=
+      BTAV_A2DP_CODEC_SAMPLE_RATE_48000;
+  }
+  if (sampleRate & A2DP_LHDC_SAMPLING_FREQ_96000) {
+      codec_selectable_capability_.sample_rate |=
+      BTAV_A2DP_CODEC_SAMPLE_RATE_96000;
+  }
+
+
+  // Compute the selectable capability - channel mode
+  codec_selectable_capability_.channel_mode = BTAV_A2DP_CODEC_CHANNEL_MODE_STEREO;
+
+  status = A2DP_BuildInfoLhdcV3Sink(AVDT_MEDIA_TYPE_AUDIO, &peer_info_cie,
+                              ota_codec_peer_capability_);
+  CHECK(status == A2DP_SUCCESS);
+  return true;
+
+fail:
+  // Restore the internal state
+  codec_selectable_capability_ = saved_codec_selectable_capability;
+  memcpy(ota_codec_peer_capability_, saved_ota_codec_peer_capability,
+         sizeof(ota_codec_peer_capability_));
+  return false;
+}
+
+
diff --git a/system/stack/a2dp/a2dp_vendor_lhdcv3_decoder.cc b/system/stack/a2dp/a2dp_vendor_lhdcv3_decoder.cc
new file mode 100755
index 0000000000..e51c7b417e
--- /dev/null
+++ b/system/stack/a2dp/a2dp_vendor_lhdcv3_decoder.cc
@@ -0,0 +1,554 @@
+/*
+ * Copyright (C) 2016 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+#define LOG_TAG "bluetooth-a2dp"
+#include "a2dp_vendor_lhdcv3_decoder.h"
+
+#include <dlfcn.h>
+#include <inttypes.h>
+#include <stdio.h>
+#include <string.h>
+
+#include <lhdcBT_dec.h>
+#include "stack/include/bt_hdr.h"
+#include "common/time_util.h"
+#include "btif/include/btif_av_co.h"
+#include "internal_include/bt_trace.h"
+#include "stack/include/bt_hdr.h"
+#include "osi/include/osi.h"
+#include <bluetooth/log.h>
+#include "os/log.h"
+using namespace bluetooth;
+
+
+#define A2DP_LHDC_FUNC_DISABLE		0
+#define A2DP_LHDC_FUNC_ENABLE		1
+
+#define LHDCV3_DEC_MAX_SAMPLES_PER_FRAME  256
+#define LHDCV3_DEC_MAX_CHANNELS           2
+#define LHDCV3_DEC_MAX_BIT_DEPTH          32
+#define LHDCV3_DEC_FRAME_NUM              16
+#define LHDCV3_DEC_BUF_BYTES              (LHDCV3_DEC_FRAME_NUM * LHDCV3_DEC_MAX_SAMPLES_PER_FRAME * LHDCV3_DEC_MAX_CHANNELS * (LHDCV3_DEC_MAX_BIT_DEPTH >> 3))
+#define LHDCV3_DEC_PACKET_NUM             8
+
+#define LHDCV3_DEC_INPUT_BUF_BYTES        1024
+
+#define LHDCV3_DEC_PKT_HDR_BYTES          2
+
+
+typedef struct {
+  lhdc_ver_t  version;
+  uint32_t    sample_rate;
+  uint8_t     bits_per_sample;
+  uint8_t     func_ch_split;
+  uint8_t     func_ar;
+  uint8_t     func_jas;
+  uint8_t     func_meta;
+
+  uint32_t    timestamp;        // Timestamp for the A2DP frames
+  uint8_t     decode_buf[LHDCV3_DEC_PACKET_NUM][LHDCV3_DEC_BUF_BYTES];
+  uint32_t    dec_buf_idx;
+
+  uint8_t     dec_input_buf[LHDCV3_DEC_INPUT_BUF_BYTES];
+  uint32_t    dec_input_buf_bytes;
+
+  decoded_data_callback_t decode_callback;
+} tA2DP_LHDCV3_DECODER_CB;
+
+static tA2DP_LHDCV3_DECODER_CB a2dp_lhdcv3_decoder_cb;
+
+
+//#define _DEC_REC_FILE_
+#if defined(_DEC_REC_FILE_)
+#define RAW_FILE_NAME "/sdcard/Download/lhdcdec.raw"
+#define PCM_FILE_NAME "/sdcard/Download/decoded.pcm"
+static FILE *rawFile = NULL;
+static FILE *pcmFile = NULL;
+#endif
+
+//
+// Decoder for LHDC Sink Codec
+//
+
+//
+// The LHDC decoder shared library, and the functions to use
+//
+static const char* LHDC_DECODER_LIB_NAME = "liblhdcBT_dec.so";
+static void* lhdc_decoder_lib_handle = NULL;
+
+
+static const char* LHDCDEC_INIT_DECODER_NAME = "lhdcBT_dec_init_decoder";
+typedef int (*tLHDCDEC_INIT_DECODER)(tLHDCV3_DEC_CONFIG *config);
+
+static const char* LHDCDEC_CHECK_FRAME_DATA_ENOUGH_NAME = "lhdcBT_dec_check_frame_data_enough";
+typedef int (*tLHDCDEC_CHECK_FRAME_DATA_ENOUGH)(const uint8_t *frameData, uint32_t frameBytes, uint32_t *packetBytes);
+
+static const char* LHDCDEC_DECODE_NAME = "lhdcBT_dec_decode";
+typedef int (*tLHDCDEC_DECODE)(const uint8_t *frameData, uint32_t frameBytes, uint8_t* pcmData, uint32_t* pcmBytes, uint32_t bits_depth);
+
+static const char* LHDCDEC_DEINIT_DECODER_NAME = "lhdcBT_dec_deinit_decoder";
+typedef int (*tLHDCDEC_DEINIT_DECODER)(void);
+
+
+static tLHDCDEC_INIT_DECODER lhdcdec_init_decoder;
+static tLHDCDEC_CHECK_FRAME_DATA_ENOUGH lhdcdec_check_frame_data_enough;
+static tLHDCDEC_DECODE lhdcdec_decode;
+static tLHDCDEC_DEINIT_DECODER lhdcdec_deinit_decoder;
+
+
+
+
+// LHDC v4 Extend flags
+#define A2DP_LHDC_FLAG_JAS            0x40
+#define A2DP_LHDC_FLAG_AR             0x80
+
+#define A2DP_LHDC_FLAG_LLAC           0x80
+
+#define A2DP_LHDC_FLAG_META           0x10
+#define A2DP_LHDC_FLAG_MBR            0x20
+#define A2DP_LHDC_FLAG_LARC           0x40
+#define A2DP_LHDC_FLAG_V4             0x80
+
+
+
+// offset  0		1B	codec capability length (11 Bytes)
+// offset  1		1B	[7:4] media type
+// offset  2		1B  codec type
+// offset  3		4B	Vendor ID
+// offset  7		2B	Codec ID
+// offset  9		3B 	LHDC specific capability
+#define A2DP_LHDCV3_CODEC_INFO_SPECIFIC_1	9
+#define A2DP_LHDCV3_CODEC_INFO_SPECIFIC_2	10
+#define A2DP_LHDCV3_CODEC_INFO_SPECIFIC_3	11
+
+
+bool save_codec_info (const uint8_t* p_codec_info)
+{
+  if (p_codec_info == NULL)
+  {
+    return false;
+  }
+
+
+  if (p_codec_info[A2DP_LHDCV3_CODEC_INFO_SPECIFIC_1] & 
+      A2DP_LHDC_SAMPLING_FREQ_44100)
+  {
+    a2dp_lhdcv3_decoder_cb.sample_rate = 44100;
+  }
+  else if (p_codec_info[A2DP_LHDCV3_CODEC_INFO_SPECIFIC_1] & 
+           A2DP_LHDC_SAMPLING_FREQ_48000)
+  {
+	a2dp_lhdcv3_decoder_cb.sample_rate = 48000;
+  }
+  else if (p_codec_info[A2DP_LHDCV3_CODEC_INFO_SPECIFIC_1] & 
+           A2DP_LHDC_SAMPLING_FREQ_96000)
+  {
+	a2dp_lhdcv3_decoder_cb.sample_rate = 96000;
+  }
+  else
+  {
+    return false;
+  }
+
+
+  if (p_codec_info[A2DP_LHDCV3_CODEC_INFO_SPECIFIC_1] & 
+      A2DP_LHDC_BIT_FMT_16)
+  {
+    a2dp_lhdcv3_decoder_cb.bits_per_sample = 16;
+  }
+  else if (p_codec_info[A2DP_LHDCV3_CODEC_INFO_SPECIFIC_1] & 
+           A2DP_LHDC_BIT_FMT_24)
+  {
+	a2dp_lhdcv3_decoder_cb.bits_per_sample = 24;
+  }
+  else
+  {
+    return false;
+  }
+
+  if (p_codec_info[A2DP_LHDCV3_CODEC_INFO_SPECIFIC_2] & A2DP_LHDC_FLAG_LLAC)
+  {
+    //LLAC only 
+    a2dp_lhdcv3_decoder_cb.version = VERSION_LLAC;
+    log::info(":LLAC only" );
+  }
+  else if (p_codec_info[A2DP_LHDCV3_CODEC_INFO_SPECIFIC_3] & A2DP_LHDC_FLAG_V4) 
+  {
+    //LHDCV4 only 
+    a2dp_lhdcv3_decoder_cb.version = VERSION_4;
+    log::info(":LHDC V4 only");
+  }
+  else
+  {
+    //LHDCV3 only 
+	a2dp_lhdcv3_decoder_cb.version = VERSION_3;
+    log::info("':LHDC V3 only");
+  }
+
+  if (p_codec_info[A2DP_LHDCV3_CODEC_INFO_SPECIFIC_3] & A2DP_LHDC_CH_SPLIT_NONE)
+  {
+    a2dp_lhdcv3_decoder_cb.func_ch_split = A2DP_LHDC_FUNC_DISABLE;
+  }
+  else if (p_codec_info[A2DP_LHDCV3_CODEC_INFO_SPECIFIC_3] & A2DP_LHDC_CH_SPLIT_TWS)
+  {
+	a2dp_lhdcv3_decoder_cb.func_ch_split = A2DP_LHDC_FUNC_ENABLE;
+  }
+  else
+  {
+    return false;
+  }
+
+  // AR
+  if (p_codec_info[A2DP_LHDCV3_CODEC_INFO_SPECIFIC_1] & A2DP_LHDC_FLAG_AR)
+  {
+	a2dp_lhdcv3_decoder_cb.func_ar = A2DP_LHDC_FUNC_ENABLE;
+  }
+  else
+  {
+    a2dp_lhdcv3_decoder_cb.func_ar = A2DP_LHDC_FUNC_DISABLE;
+  }
+
+  // JAS
+  if (p_codec_info[A2DP_LHDCV3_CODEC_INFO_SPECIFIC_1] & A2DP_LHDC_FLAG_JAS)
+  {
+	a2dp_lhdcv3_decoder_cb.func_jas = A2DP_LHDC_FUNC_ENABLE;
+  }
+  else
+  {
+    a2dp_lhdcv3_decoder_cb.func_jas = A2DP_LHDC_FUNC_DISABLE;
+  }
+
+  // META
+  if (p_codec_info[A2DP_LHDCV3_CODEC_INFO_SPECIFIC_3] & A2DP_LHDC_FLAG_META)
+  {
+	a2dp_lhdcv3_decoder_cb.func_meta = A2DP_LHDC_FUNC_ENABLE;
+  }
+  else
+  {
+    a2dp_lhdcv3_decoder_cb.func_meta = A2DP_LHDC_FUNC_DISABLE;
+  }
+
+  return true;
+
+}
+
+
+static void* load_func(const char* func_name) {
+
+  void* func_ptr = NULL;
+
+  if ((func_name == NULL) ||
+      (lhdc_decoder_lib_handle == NULL))  {
+
+    return NULL;
+  }
+
+  func_ptr = dlsym(lhdc_decoder_lib_handle, func_name);
+
+  if (func_ptr == NULL) {
+    log::error("cannot find function ,in the encoder library:{}", dlerror());
+    A2DP_VendorUnloadDecoderLhdcV3();
+    return NULL;
+  }
+
+  return func_ptr;
+}
+
+
+bool A2DP_VendorLoadDecoderLhdcV3(void) {
+
+  if (lhdc_decoder_lib_handle != NULL) return true;  // Already loaded
+
+  memset(&a2dp_lhdcv3_decoder_cb, 0, sizeof(a2dp_lhdcv3_decoder_cb));
+
+  // Open the encoder library
+  lhdc_decoder_lib_handle = dlopen(LHDC_DECODER_LIB_NAME, RTLD_NOW);
+  if (lhdc_decoder_lib_handle == NULL) {
+  //  LOG_ERROR("%s: cannot open LHDC decoder library %s: %s", __func__,
+             // LHDC_DECODER_LIB_NAME, dlerror());
+    log::error("cannot open LHDC decoder library : {}",LHDC_DECODER_LIB_NAME,dlerror());
+              
+    return false;
+  }
+
+
+  // Load all functions
+  lhdcdec_init_decoder = (tLHDCDEC_INIT_DECODER)load_func(LHDCDEC_INIT_DECODER_NAME);
+  if (lhdcdec_init_decoder == NULL) return false;
+
+  lhdcdec_check_frame_data_enough = (tLHDCDEC_CHECK_FRAME_DATA_ENOUGH)load_func(LHDCDEC_CHECK_FRAME_DATA_ENOUGH_NAME);
+  if (lhdcdec_check_frame_data_enough == NULL) return false;
+
+  lhdcdec_decode = (tLHDCDEC_DECODE)load_func(LHDCDEC_DECODE_NAME);
+  if (lhdcdec_decode == NULL) return false;
+
+  lhdcdec_deinit_decoder = (tLHDCDEC_DEINIT_DECODER)load_func(LHDCDEC_DEINIT_DECODER_NAME);
+  if (lhdcdec_deinit_decoder == NULL) return false;
+
+  return true;
+}
+
+
+void A2DP_VendorUnloadDecoderLhdcV3(void) {
+  a2dp_vendor_lhdcv3_decoder_cleanup();
+}
+
+
+bool a2dp_vendor_lhdcv3_decoder_init(decoded_data_callback_t decode_callback) {
+  //LOG_ERROR("%s: A2DP Sink", __func__);
+  log::error("A2DP Sink");
+
+  tLHDCV3_DEC_CONFIG  lhdcdec_config;
+  int  fn_ret;
+
+
+  if ((lhdc_decoder_lib_handle == NULL) ||
+      (lhdcdec_init_decoder == NULL) ||
+	  (lhdcdec_deinit_decoder == NULL)) {
+
+	return false;
+  }
+
+  lhdcdec_deinit_decoder ();
+
+  lhdcdec_config.version = a2dp_lhdcv3_decoder_cb.version;
+  lhdcdec_config.sample_rate = a2dp_lhdcv3_decoder_cb.sample_rate;
+  lhdcdec_config.bits_depth = a2dp_lhdcv3_decoder_cb.bits_per_sample;
+
+  fn_ret = lhdcdec_init_decoder (&lhdcdec_config);
+
+  if (fn_ret != LHDCBT_DEC_FUNC_SUCCEED) {
+
+    return false;
+  }
+
+  a2dp_lhdcv3_decoder_cb.dec_buf_idx = 0;
+  a2dp_lhdcv3_decoder_cb.dec_input_buf_bytes = 0;
+  a2dp_lhdcv3_decoder_cb.decode_callback = decode_callback;
+
+#if defined(_DEC_REC_FILE_)
+  if (rawFile == NULL) {
+    rawFile = fopen(RAW_FILE_NAME,"wb");
+    log::info(":Create recode file = {}" ,rawFile);
+  }
+  if (pcmFile == NULL) {
+    pcmFile = fopen(PCM_FILE_NAME,"wb");
+    log::info(":Create recode file = {}",pcmFile);
+  }
+#endif
+  return true;
+}
+
+
+void a2dp_vendor_lhdcv3_decoder_cleanup(void) {
+  // Cleanup any LHDC-related state
+
+  log::info(":lhdc_decoder_lib_handle = {}",lhdc_decoder_lib_handle);
+
+  if (lhdc_decoder_lib_handle == NULL) {
+
+	return;
+  }
+
+  if (lhdcdec_deinit_decoder != NULL) {
+
+    lhdcdec_deinit_decoder ();
+  }
+
+  memset(&a2dp_lhdcv3_decoder_cb, 0, sizeof(a2dp_lhdcv3_decoder_cb));
+
+  dlclose(lhdc_decoder_lib_handle);
+  lhdc_decoder_lib_handle = NULL;
+
+#if defined(_DEC_REC_FILE_)
+  if (rawFile != NULL) {
+    fclose(rawFile);
+    rawFile = NULL;
+    remove(RAW_FILE_NAME);
+  }
+  if (pcmFile != NULL) {
+    fclose(pcmFile);
+    pcmFile = NULL;
+    remove(PCM_FILE_NAME);
+  }
+#endif
+}
+
+bool a2dp_vendor_lhdcv3_decoder_decode_packet(BT_HDR* p_buf) {
+  uint8_t* data;
+  size_t data_size;
+  uint32_t out_used = 0;
+  int fn_ret;
+  uint32_t dec_buf_idx;
+  uint8_t *ptr_src;
+  uint8_t *ptr_dst;
+  uint32_t packet_bytes;
+  uint32_t i;
+
+
+  if (p_buf == NULL) {
+
+	return false;
+  }
+
+  data = p_buf->data + p_buf->offset;
+  data_size = p_buf->len;
+
+  dec_buf_idx = a2dp_lhdcv3_decoder_cb.dec_buf_idx++;
+  if (a2dp_lhdcv3_decoder_cb.dec_buf_idx >= LHDCV3_DEC_PACKET_NUM)
+  {
+	a2dp_lhdcv3_decoder_cb.dec_buf_idx = 0;
+  }
+
+
+  if (data_size == 0) {
+    //LOG_ERROR("%s: Empty packet", __func__);
+    log::error(":Empty packet");
+    return false;
+  }
+
+  if ((lhdc_decoder_lib_handle == NULL) ||
+      (lhdcdec_decode == NULL)) {
+
+    //LOG_ERROR("%s: Invalid handle!", __func__);
+    log::error("Invalid handle!");
+    return false;
+  }
+
+#if defined(_DEC_REC_FILE_)
+  if (rawFile != NULL && data_size > 0) {
+    fwrite(data + LHDCV3_DEC_PKT_HDR_BYTES, sizeof(uint8_t), data_size - LHDCV3_DEC_PKT_HDR_BYTES, rawFile);
+  }
+#endif
+
+  if ((a2dp_lhdcv3_decoder_cb.dec_input_buf_bytes + data_size) > LHDCV3_DEC_INPUT_BUF_BYTES)
+  {
+	// the data queued is useless
+	// discard them
+    a2dp_lhdcv3_decoder_cb.dec_input_buf_bytes = 0;
+
+	if (data_size > LHDCV3_DEC_INPUT_BUF_BYTES)
+	{
+	  // input data is too big (more than buffer size)!!
+	  // just ingore it, and do nothing
+	  return true;
+	}
+  }
+
+  memcpy (&(a2dp_lhdcv3_decoder_cb.dec_input_buf[a2dp_lhdcv3_decoder_cb.dec_input_buf_bytes]), 
+          data, 
+          data_size);
+  a2dp_lhdcv3_decoder_cb.dec_input_buf_bytes += data_size;
+
+  packet_bytes = 0;
+  fn_ret = lhdcdec_check_frame_data_enough (a2dp_lhdcv3_decoder_cb.dec_input_buf, 
+                                            a2dp_lhdcv3_decoder_cb.dec_input_buf_bytes,
+											&packet_bytes);
+
+  if (fn_ret == LHDCBT_DEC_FUNC_INPUT_NOT_ENOUGH) {
+    //LOG_ERROR("%s: Input buffer is NOT enough!, but return true", __func__);
+    log::error("Input buffer is NOT enough!, but return true");
+    return true;
+  }
+  else if (fn_ret != LHDCBT_DEC_FUNC_SUCCEED) {
+
+    //LOG_ERROR("%s: fail to check frame data!", __func__);
+    log::error(":fail to check frame data!");
+    // clear the data in the input buffer
+    a2dp_lhdcv3_decoder_cb.dec_input_buf_bytes = 0;
+    return false;
+  }
+
+  if (packet_bytes != (a2dp_lhdcv3_decoder_cb.dec_input_buf_bytes - LHDCV3_DEC_PKT_HDR_BYTES))
+  {
+	// strange!
+	// queued data is NOT exactly equal to one packet!
+	// maybe wrong data in buffer
+	// discard data queued previously, and save input data
+	//LOG_ERROR("%s: queued data is NOT exactly equal to one packet! packet (%d),  input (%d)", __func__, packet_bytes, a2dp_lhdcv3_decoder_cb.dec_input_buf_bytes);
+  log::error("queued data is NOT exactly equal to one packet! packet {},{}",packet_bytes,a2dp_lhdcv3_decoder_cb.dec_input_buf_bytes);
+	a2dp_lhdcv3_decoder_cb.dec_input_buf_bytes = 0;
+	memcpy (&(a2dp_lhdcv3_decoder_cb.dec_input_buf[a2dp_lhdcv3_decoder_cb.dec_input_buf_bytes]), 
+            data, 
+            data_size);
+    a2dp_lhdcv3_decoder_cb.dec_input_buf_bytes += data_size;
+	return true;
+  }
+
+  out_used = sizeof(a2dp_lhdcv3_decoder_cb.decode_buf[dec_buf_idx]);
+  fn_ret = lhdcdec_decode (a2dp_lhdcv3_decoder_cb.dec_input_buf, 
+                           a2dp_lhdcv3_decoder_cb.dec_input_buf_bytes, 
+                           a2dp_lhdcv3_decoder_cb.decode_buf[dec_buf_idx],
+						   &out_used,
+						   a2dp_lhdcv3_decoder_cb.bits_per_sample);
+
+  // finish decoding
+  // clear the data in the input buffer
+  a2dp_lhdcv3_decoder_cb.dec_input_buf_bytes = 0;
+
+  if (fn_ret != LHDCBT_DEC_FUNC_SUCCEED) {
+      log::error("fail to decode lhdc stream!");
+    return false;
+  }
+
+  if (a2dp_lhdcv3_decoder_cb.bits_per_sample == 24) {
+    ptr_src = a2dp_lhdcv3_decoder_cb.decode_buf[dec_buf_idx];
+	ptr_dst = a2dp_lhdcv3_decoder_cb.decode_buf[dec_buf_idx];
+
+    for (i = 0; i < (out_used >> 2) ; i++) {
+	  *ptr_dst++ = *ptr_src++;
+	  *ptr_dst++ = *ptr_src++;
+	  *ptr_dst++ = *ptr_src++;
+	  ptr_src++;
+    }
+	
+	out_used = (out_used >> 2) * 3;
+  }
+
+#if defined(_DEC_REC_FILE_)
+  if (pcmFile != NULL && out_used > 0 && out_used <= sizeof(a2dp_lhdcv3_decoder_cb.decode_buf[dec_buf_idx])) {
+    int write_bytes;
+
+    write_bytes = fwrite(a2dp_lhdcv3_decoder_cb.decode_buf[dec_buf_idx], sizeof(uint8_t), out_used, pcmFile);
+  }
+#endif
+
+  a2dp_lhdcv3_decoder_cb.decode_callback(
+      reinterpret_cast<uint8_t*>(a2dp_lhdcv3_decoder_cb.decode_buf[dec_buf_idx]), out_used);
+
+  return true;
+}
+
+void a2dp_vendor_lhdcv3_decoder_start(void) {
+  log::info("a2dp_vendor_lhdcv3_decoder_start");
+  // do nothing
+}
+
+void a2dp_vendor_lhdcv3_decoder_suspend(void) {
+  log::info("a2dp_vendor_lhdcv3_decoder_suspend");
+  // do nothing
+}
+
+void a2dp_vendor_lhdcv3_decoder_configure(const uint8_t* p_codec_info) {
+  //int32_t sample_rate;
+  //int32_t bits_per_sample;
+  //int32_t channel_mode;
+
+  if (p_codec_info == NULL) {
+    log::error("p_codec_info is NULL");
+    return;
+  }
+}
diff --git a/system/stack/a2dp/a2dp_vendor_lhdcv3_encoder.cc b/system/stack/a2dp/a2dp_vendor_lhdcv3_encoder.cc
new file mode 100755
index 0000000000..920e32046f
--- /dev/null
+++ b/system/stack/a2dp/a2dp_vendor_lhdcv3_encoder.cc
@@ -0,0 +1,1054 @@
+/*
+ * Copyright (C) 2016 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+#define LOG_TAG "bluetooth-a2dp"
+#define ATRACE_TAG ATRACE_TAG_AUDIO
+
+#include "a2dp_vendor_lhdcv3_encoder.h"
+
+#ifndef OS_GENERIC
+#include <cutils/trace.h>
+#endif
+#include <dlfcn.h>
+#include <inttypes.h>
+#include <stdio.h>
+#include <string.h>
+
+#include <lhdcBT.h>
+
+#include "a2dp_vendor.h"
+#include "a2dp_vendor_lhdcv3.h"
+#include "common/time_util.h"
+#include "osi/include/allocator.h"
+#include "btif/include/btif_av_co.h"
+#include "internal_include/bt_trace.h"
+#include "stack/include/bt_hdr.h"
+#include "osi/include/osi.h"
+#include <bluetooth/log.h>
+#include "os/log.h"
+using namespace bluetooth;
+
+//
+// Encoder for LHDC Source Codec
+//
+//#define MCPS_FRAME_ENCODE    // estimate MCPS of encoding frame
+
+#ifdef MCPS_FRAME_ENCODE
+#define STATIS_MILLION_UNIT   (1000000)
+#define STATIS_KILO_UNIT      (1000)
+#define STATIS_CPU_FREQ_MHZ   (1708800 / 1000)  //referenced CPU clock: 1708800KHz
+#define MCPS_FRAME_ENCODE_DUR (60)             //statistics duration (sec)
+uint64_t mcpsStat_time_dur_cnt_lhdcv3 = 0;     //statistics duration counter (sec)
+uint64_t mcpsStat_all_enc_us_lhdcv3 = 0;       //total execution time(us) of current encoded frames
+uint64_t mcpsStat_all_enc_frm_lhdcv3 = 0;      //total number of current encoded frames
+uint64_t mcpsStat_enc_frm_per_sec_lhdcv3 = 0;  //number of frame encoded in one sec
+uint64_t mcpsStat_all_time_dur_ms_lhdcv3 = 0;  //total real time(ms) when enter final statistics calculation
+#endif
+
+//#define LHDCV3_SRC_EXT_API_ENABLE // Savitehc LHDC_EXT_API
+
+//
+// The LHDC encoder shared library, and the functions to use
+//
+static const char* LHDC_ENCODER_LIB_NAME = "liblhdcBT_enc.so";
+static void* lhdc_encoder_lib_handle = NULL;
+
+static const char* LHDC_GET_HANDLE_NAME = "lhdcBT_get_handle";
+typedef HANDLE_LHDC_BT (*tLHDC_GET_HANDLE)(int version);
+
+static const char* LHDC_FREE_HANDLE_NAME = "lhdcBT_free_handle";
+typedef void (*tLHDC_FREE_HANDLE)(HANDLE_LHDC_BT hLhdcParam);
+
+static const char* LHDC_GET_BITRATE_NAME = "lhdcBT_get_bitrate";
+typedef int (*tLHDC_GET_BITRATE)(HANDLE_LHDC_BT hLhdcParam);
+static const char* LHDC_SET_BITRATE_NAME = "lhdcBT_set_bitrate";
+typedef int (*tLHDC_SET_BITRATE)(HANDLE_LHDC_BT hLhdcParam, int index);
+
+static const char* LHDC_INIT_ENCODER_NAME = "lhdcBT_init_encoder";
+typedef int (*tLHDC_INIT_ENCODER)(HANDLE_LHDC_BT hLhdcParam,int sampling_freq, int bitPerSample, int bitrate_inx, int dualChannels, int need_padding, int mtu_size, int interval);
+
+static const char* LHDC_AUTO_ADJUST_BITRATE_NAME = "lhdcBT_adjust_bitrate";
+typedef int (*tLHDC_AUTO_ADJUST_BITRATE)(HANDLE_LHDC_BT hLhdcParam, size_t queueLength);
+
+
+static const char* LHDC_ENCODE_NAME = "lhdcBT_encodeV3";
+typedef int (*tLHDC_ENCODE)(HANDLE_LHDC_BT hLhdcParam, void* p_pcm, unsigned char* out_put, uint32_t * written, uint32_t * out_fraems);
+
+static const char* LHDC_SET_LIMIT_BITRATE_ENABLED_NAME = "lhdcBT_set_max_bitrate";
+typedef void (*tLHDC_SET_LIMIT_BITRATE_ENABLED)(HANDLE_LHDC_BT hLhdcParam, int max_rate_index);
+
+static const char* LHDC_GET_BLOCK_SIZE = "lhdcBT_get_block_Size";
+typedef int (*tLHDC_GET_BLOCK_SIZE)(HANDLE_LHDC_BT hLhdcParam);
+
+
+static const char* LHDC_SET_EXT_FUNC = "lhdcBT_set_ext_func_state";
+typedef int (*tLHDC_SET_EXT_FUNC)(HANDLE_LHDC_BT handle, lhdcBT_ext_func_field_t field, bool enabled, void * priv, int priv_data_len);
+
+
+static const char* LHDC_SET_MBR_FUNC = "lhdcBT_set_hasMinBitrateLimit";
+typedef int (*tLHDC_SET_MBR_FUNC)(HANDLE_LHDC_BT handle, bool enabled);
+//int lhdcBT_set_hasMinBitrateLimit(HANDLE_LHDC_BT handle, bool enabled )
+//int lhdcBT_set_ext_func_state(HANDLE_LHDC_BT handle, lhdcBT_ext_func_field_t field, bool enabled, void * priv, int priv_data_len)
+/*leo set_gyro_pos */
+//static const char* LHDC_SET_GYRO_POS_NAME = "lhdcBT_set_gyro_pos";
+//typedef int (*tLHDC_SET_GYRO_POS)(HANDLE_LHDC_BT hLhdcParam, uint32_t world_coordinate_x, uint32_t world_coordinate_y, uint32_t world_coordinate_z);
+
+
+static tLHDC_GET_HANDLE lhdc_get_handle;
+static tLHDC_FREE_HANDLE lhdc_free_handle;
+static tLHDC_GET_BITRATE lhdc_get_bitrate;
+static tLHDC_SET_BITRATE lhdc_set_bitrate;
+static tLHDC_INIT_ENCODER lhdc_init_encoder;
+static tLHDC_ENCODE lhdc_encode_func;
+static tLHDC_AUTO_ADJUST_BITRATE lhdc_auto_adjust_bitrate;
+static tLHDC_SET_LIMIT_BITRATE_ENABLED lhdc_set_limit_bitrate;
+static tLHDC_GET_BLOCK_SIZE lhdc_get_block_size;
+static tLHDC_SET_EXT_FUNC lhdc_set_ext_func;
+static tLHDC_SET_MBR_FUNC lhdc_set_mbr_func;
+
+
+
+// A2DP LHDC encoder interval in milliseconds
+#define A2DP_LHDC_ENCODER_SHORT_INTERVAL_MS 10
+#define A2DP_LHDC_ENCODER_INTERVAL_MS 20
+
+// offset
+#if (BTA_AV_CO_CP_SCMS_T == TRUE)
+#define A2DP_LHDC_OFFSET (AVDT_MEDIA_OFFSET + A2DP_LHDC_MPL_HDR_LEN + 1)
+#else
+#define A2DP_LHDC_OFFSET (AVDT_MEDIA_OFFSET + A2DP_LHDC_MPL_HDR_LEN)
+#endif
+
+
+namespace fmt {
+template <>
+struct formatter<LHDCBT_SMPL_FMT_T> : enum_formatter<LHDCBT_SMPL_FMT_T> {};
+}  // namespace fmt
+
+
+//#define A2DP_LHDC_OFFSET (AVDT_MEDIA_OFFSET + 0)
+
+typedef struct {
+  uint32_t sample_rate;
+  uint8_t channel_mode;
+  uint8_t bits_per_sample;
+  int quality_mode_index;
+  //int latency_mode_index;
+  int pcm_wlength;
+  LHDCBT_SMPL_FMT_T pcm_fmt;
+  int8_t channelSplitMode;
+  int8_t maxTargetBitrate;
+  bool isLLEnabled;
+} tA2DP_LHDC_ENCODER_PARAMS;
+
+typedef struct {
+  uint32_t counter;
+  uint32_t bytes_per_tick; /* pcm bytes read each media task tick */
+  uint64_t last_frame_us;
+} tA2DP_LHDC_FEEDING_STATE;
+
+typedef struct {
+  uint64_t session_start_us;
+
+  size_t media_read_total_expected_packets;
+  size_t media_read_total_expected_reads_count;
+  size_t media_read_total_expected_read_bytes;
+
+  size_t media_read_total_dropped_packets;
+  size_t media_read_total_actual_reads_count;
+  size_t media_read_total_actual_read_bytes;
+} a2dp_lhdc_encoder_stats_t;
+
+typedef struct {
+  a2dp_source_read_callback_t read_callback;
+  a2dp_source_enqueue_callback_t enqueue_callback;
+  uint16_t TxAaMtuSize;
+  size_t TxQueueLength;
+
+  bool use_SCMS_T;
+  bool is_peer_edr;          // True if the peer device supports EDR
+  bool peer_supports_3mbps;  // True if the peer device supports 3Mbps EDR
+  uint16_t peer_mtu;         // MTU of the A2DP peer
+  uint32_t timestamp;        // Timestamp for the A2DP frames
+
+  HANDLE_LHDC_BT lhdc_handle;
+  bool has_lhdc_handle;  // True if lhdc_handle is valid
+  uint8_t version;
+
+  tA2DP_FEEDING_PARAMS feeding_params;
+  tA2DP_LHDC_ENCODER_PARAMS lhdc_encoder_params;
+  tA2DP_LHDC_FEEDING_STATE lhdc_feeding_state;
+
+  a2dp_lhdc_encoder_stats_t stats;
+  uint32_t buf_seq;
+  uint32_t bytes_read;
+} tA2DP_LHDC_ENCODER_CB;
+
+//static bool lhdc_abr_loaded = false;
+
+
+
+typedef struct _lhdc_frame_Info {
+    uint32_t frame_len;
+    uint32_t isSplit;
+    uint32_t isLeft;
+
+} lhdc_frame_Info_t;
+
+
+//#define _RECODER_FILE_
+#if defined(_RECODER_FILE_)
+#define ENCODED_FILE_NAME "/sdcard/Download/lhdc.raw"
+#define PCM_FILE_NAME     "/sdcard/Download/source.pcm"
+static FILE  *RecFile = NULL;
+static FILE *pcmFile = NULL;
+#endif
+
+static tA2DP_LHDC_ENCODER_CB a2dp_lhdc_encoder_cb;
+
+static void a2dp_vendor_lhdcv3_encoder_update(uint16_t peer_mtu,
+                                            A2dpCodecConfig* a2dp_codec_config,
+                                            bool* p_restart_input,
+                                            bool* p_restart_output,
+                                            bool* p_config_updated);
+static void a2dp_lhdcv3_get_num_frame_iteration(uint8_t* num_of_iterations,
+                                              uint8_t* num_of_frames,
+                                              uint64_t timestamp_us);
+
+static void a2dp_lhdcV3_encode_frames(uint8_t nb_frame);
+static bool a2dp_lhdcv3_read_feeding(uint8_t* read_buffer, uint32_t *bytes_read);
+static std::string quality_mode_index_to_name(int quality_mode_index);
+//static std::string latency_mode_index_to_name(int latency_mode_index);
+
+static void* load_func(const char* func_name) {
+  void* func_ptr = dlsym(lhdc_encoder_lib_handle, func_name);
+  if (func_ptr == NULL) {
+    log::error(
+              ": cannot find function '' in the encoder library: ",
+               func_name, dlerror());
+    A2DP_VendorUnloadEncoderLhdcV3();
+    return NULL;
+  }
+  return func_ptr;
+}
+
+bool A2DP_VendorLoadEncoderLhdcV3(void) {
+  if (lhdc_encoder_lib_handle != NULL) return true;  // Already loaded
+
+  // Initialize the control block
+  memset(&a2dp_lhdc_encoder_cb, 0, sizeof(a2dp_lhdc_encoder_cb));
+
+  // Open the encoder library
+  lhdc_encoder_lib_handle = dlopen(LHDC_ENCODER_LIB_NAME, RTLD_NOW);
+  if (lhdc_encoder_lib_handle == NULL) {
+    log::error( ": cannot open LHDC encoder library : {}",
+              LHDC_ENCODER_LIB_NAME, dlerror());
+    return false;
+  }
+
+
+  // Load all functions
+  lhdc_get_handle = (tLHDC_GET_HANDLE)load_func(LHDC_GET_HANDLE_NAME);
+  if (lhdc_get_handle == NULL) return false;
+  lhdc_free_handle = (tLHDC_FREE_HANDLE)load_func(LHDC_FREE_HANDLE_NAME);
+  if (lhdc_free_handle == NULL) return false;
+  lhdc_get_bitrate = (tLHDC_GET_BITRATE)load_func(LHDC_GET_BITRATE_NAME);
+  if (lhdc_get_bitrate == NULL) return false;
+  lhdc_set_bitrate = (tLHDC_SET_BITRATE)load_func(LHDC_SET_BITRATE_NAME);
+  if (lhdc_set_bitrate == NULL) return false;
+  lhdc_init_encoder = (tLHDC_INIT_ENCODER)load_func(LHDC_INIT_ENCODER_NAME);
+  if (lhdc_init_encoder == NULL) return false;
+  lhdc_encode_func = (tLHDC_ENCODE)load_func(LHDC_ENCODE_NAME);
+  if (lhdc_encode_func == NULL) return false;
+  lhdc_auto_adjust_bitrate = (tLHDC_AUTO_ADJUST_BITRATE)load_func(LHDC_AUTO_ADJUST_BITRATE_NAME);
+  if (lhdc_auto_adjust_bitrate == NULL) return false;
+
+
+  lhdc_set_limit_bitrate = (tLHDC_SET_LIMIT_BITRATE_ENABLED)load_func(LHDC_SET_LIMIT_BITRATE_ENABLED_NAME);
+  if (lhdc_set_limit_bitrate == NULL) return false;
+  lhdc_get_block_size = (tLHDC_GET_BLOCK_SIZE)load_func(LHDC_GET_BLOCK_SIZE);
+  if (lhdc_get_block_size == NULL) return false;
+  lhdc_set_ext_func = (tLHDC_SET_EXT_FUNC)load_func(LHDC_SET_EXT_FUNC);
+  if (lhdc_set_ext_func == NULL) return false;
+  lhdc_set_mbr_func = (tLHDC_SET_MBR_FUNC)load_func(LHDC_SET_MBR_FUNC);
+  if (lhdc_set_mbr_func == NULL) return false;
+
+  return true;
+}
+
+void A2DP_VendorUnloadEncoderLhdcV3(void) {
+  // Cleanup any LHDC-related state
+
+   // log::info( ": a2dp_lhdc_encoder_cb.has_lhdc_handle = {}, lhdc_free_handle = {}",
+       //        a2dp_lhdc_encoder_cb.has_lhdc_handle, lhdc_free_handle);
+  if (a2dp_lhdc_encoder_cb.has_lhdc_handle && lhdc_free_handle != NULL)
+    lhdc_free_handle(a2dp_lhdc_encoder_cb.lhdc_handle);
+  memset(&a2dp_lhdc_encoder_cb, 0, sizeof(a2dp_lhdc_encoder_cb));
+
+  lhdc_get_handle = NULL;
+  lhdc_free_handle = NULL;
+  lhdc_get_bitrate = NULL;
+  lhdc_set_bitrate = NULL;
+  lhdc_init_encoder = NULL;
+  lhdc_encode_func = NULL;
+  lhdc_auto_adjust_bitrate = NULL;
+  lhdc_set_limit_bitrate = NULL;
+  lhdc_get_block_size = NULL;
+  lhdc_set_ext_func = NULL;
+  lhdc_set_mbr_func = NULL;
+
+  if (lhdc_encoder_lib_handle != NULL) {
+    dlclose(lhdc_encoder_lib_handle);
+    lhdc_encoder_lib_handle = NULL;
+  }
+}
+
+void a2dp_vendor_lhdcv3_encoder_init(
+    const tA2DP_ENCODER_INIT_PEER_PARAMS* p_peer_params,
+    A2dpCodecConfig* a2dp_codec_config,
+    a2dp_source_read_callback_t read_callback,
+    a2dp_source_enqueue_callback_t enqueue_callback) {
+  if (a2dp_lhdc_encoder_cb.has_lhdc_handle)
+    lhdc_free_handle(a2dp_lhdc_encoder_cb.lhdc_handle);
+
+  memset(&a2dp_lhdc_encoder_cb, 0, sizeof(a2dp_lhdc_encoder_cb));
+
+  a2dp_lhdc_encoder_cb.stats.session_start_us = bluetooth::common::time_get_os_boottime_us();
+
+  a2dp_lhdc_encoder_cb.read_callback = read_callback;
+  a2dp_lhdc_encoder_cb.enqueue_callback = enqueue_callback;
+  a2dp_lhdc_encoder_cb.is_peer_edr = p_peer_params->is_peer_edr;
+  a2dp_lhdc_encoder_cb.peer_supports_3mbps = p_peer_params->peer_supports_3mbps;
+  a2dp_lhdc_encoder_cb.peer_mtu = p_peer_params->peer_mtu;
+  a2dp_lhdc_encoder_cb.timestamp = 0;
+
+
+  a2dp_lhdc_encoder_cb.use_SCMS_T = false;  // TODO: should be a parameter
+#if (BTA_AV_CO_CP_SCMS_T == TRUE)
+  a2dp_lhdc_encoder_cb.use_SCMS_T = true;
+#endif
+
+  // NOTE: Ignore the restart_input / restart_output flags - this initization
+  // happens when the connection is (re)started.
+  bool restart_input = false;
+  bool restart_output = false;
+  bool config_updated = false;
+  a2dp_vendor_lhdcv3_encoder_update(a2dp_lhdc_encoder_cb.peer_mtu,
+                                  a2dp_codec_config, &restart_input,
+                                  &restart_output, &config_updated);
+}
+
+#if 0
+bool A2dpCodecConfigLhdcV3::updateEncoderUserConfig(
+    const tA2DP_ENCODER_INIT_PEER_PARAMS* p_peer_params, bool* p_restart_input,
+    bool* p_restart_output, bool* p_config_updated) {
+  if (a2dp_lhdc_encoder_cb.has_lhdc_handle) {
+    lhdc_free_handle(a2dp_lhdc_encoder_cb.lhdc_handle);
+    a2dp_lhdc_encoder_cb.has_lhdc_handle = false;
+    log::info( ": clean lhdc handle");
+  }
+  a2dp_lhdc_encoder_cb.is_peer_edr = p_peer_params->is_peer_edr;
+  a2dp_lhdc_encoder_cb.peer_supports_3mbps = p_peer_params->peer_supports_3mbps;
+  a2dp_lhdc_encoder_cb.peer_mtu = p_peer_params->peer_mtu;
+  a2dp_lhdc_encoder_cb.timestamp = 0;
+
+  if (a2dp_lhdc_encoder_cb.peer_mtu == 0) {
+    log::error(
+              ": Cannot update the codec encoder for : "
+              "invalid peer MTU",
+               name().c_str());
+    return false;
+  }
+
+  a2dp_vendor_lhdcv3_encoder_update(a2dp_lhdc_encoder_cb.peer_mtu, this,
+                                  p_restart_input, p_restart_output,
+                                  p_config_updated);
+  return true;
+}
+#endif
+
+// Update the A2DP LHDC encoder.
+// |peer_mtu| is the peer MTU.
+// |a2dp_codec_config| is the A2DP codec to use for the update.
+static void a2dp_vendor_lhdcv3_encoder_update(uint16_t peer_mtu,
+                                            A2dpCodecConfig* a2dp_codec_config,
+                                            bool* p_restart_input,
+                                            bool* p_restart_output,
+                                            bool* p_config_updated) {
+  tA2DP_LHDC_ENCODER_PARAMS* p_encoder_params =
+      &a2dp_lhdc_encoder_cb.lhdc_encoder_params;
+  uint8_t codec_info[AVDT_CODEC_SIZE];
+
+  *p_restart_input = false;
+  *p_restart_output = false;
+  *p_config_updated = false;
+
+  //Example for limit bit rate
+  //lhdc_set_limit_bitrate(a2dp_lhdc_encoder_cb.lhdc_handle, 0);
+
+
+  if (!a2dp_codec_config->copyOutOtaCodecConfig(codec_info)) {
+    log::error(
+              ": Cannot update the codec encoder for : {}"
+              "invalid codec config",
+               a2dp_codec_config->name().c_str());
+    return;
+  }
+  const uint8_t* p_codec_info = codec_info;
+  btav_a2dp_codec_config_t codec_config = a2dp_codec_config->getCodecConfig();
+
+  uint32_t verCode = A2DP_VendorGetVersionLhdcV3(p_codec_info);  //LHDC V3 should 1!
+
+  bool isLLAC = A2DP_VendorHasLLACFlagLhdcV3(p_codec_info);
+
+  bool isLHDCV4 = A2DP_VendorHasV4FlagLhdcV3(p_codec_info);
+
+
+  log::info( ":codec_config.codec_specific_1 = {}, codec_config.codec_specific_2 = {}",  (int32_t)codec_config.codec_specific_1, (int32_t)codec_config.codec_specific_2);
+  if ((codec_config.codec_specific_1 & A2DP_LHDC_VENDOR_CMD_MASK) == A2DP_LHDC_QUALITY_MAGIC_NUM) {
+      int newValue = codec_config.codec_specific_1 & 0xff;
+
+      // adjust non-supported quality modes and wrap to internal library used index
+      if (newValue == A2DP_LHDC_QUALITY_ABR) {
+        newValue = LHDCBT_QUALITY_AUTO; //9->8
+      }
+
+      if (newValue != p_encoder_params->quality_mode_index) {
+        p_encoder_params->quality_mode_index = newValue;
+        log::info( ": setting internal quality mode index: ({})", 
+                  quality_mode_index_to_name(p_encoder_params->quality_mode_index)
+                      .c_str(), p_encoder_params->quality_mode_index);
+      }
+  }else {
+      p_encoder_params->quality_mode_index = LHDCBT_QUALITY_AUTO;
+      log::info( ": setting default quality mode to ABR");
+  }
+
+  if (!a2dp_lhdc_encoder_cb.has_lhdc_handle) {
+      uint32_t versionSetup = 2;
+      if(isLLAC && !isLHDCV4 && verCode == 1){
+        //LLAC Only
+        versionSetup = 4;
+        log::info( ": init to LLAC : {}", versionSetup);
+      }else if(!isLLAC && isLHDCV4 && verCode == 1) {
+        //LHDCV4 Only
+        versionSetup = 3;
+        log::info( ": init to LHDC V4 : {}", versionSetup);
+      }else if(!isLLAC && !isLHDCV4 && verCode == 1) {
+        //LHDCV3 Only
+        versionSetup = 2;
+        log::info( ": init to LHDC V3 : {}", versionSetup);
+      }else {
+        log::info( ": Flags check incorrect. So init to LHDCV3 only : {}", versionSetup);
+      }
+
+
+      a2dp_lhdc_encoder_cb.lhdc_handle = lhdc_get_handle(versionSetup);
+      if (a2dp_lhdc_encoder_cb.lhdc_handle == NULL) {
+        log::error( ": Cannot get LHDC encoder handle");
+        return;  // TODO: Return an error?
+      }
+      a2dp_lhdc_encoder_cb.has_lhdc_handle = true;
+  }
+  a2dp_lhdc_encoder_cb.version = A2DP_VendorGetVersionLhdcV3(p_codec_info);
+
+
+  // The feeding parameters
+  tA2DP_FEEDING_PARAMS* p_feeding_params = &a2dp_lhdc_encoder_cb.feeding_params;
+  p_feeding_params->sample_rate =
+      A2DP_VendorGetTrackSampleRateLhdcV3(p_codec_info);
+  p_feeding_params->bits_per_sample =
+      a2dp_codec_config->getAudioBitsPerSample();
+  p_feeding_params->channel_count =
+      A2DP_VendorGetTrackChannelCountLhdcV3(p_codec_info);
+  log::info( ":(feeding) sample_rate={} bits_per_sample={} channel_count={}",
+             p_feeding_params->sample_rate,
+            p_feeding_params->bits_per_sample, p_feeding_params->channel_count);
+
+  // The codec parameters
+  p_encoder_params->sample_rate =
+      a2dp_lhdc_encoder_cb.feeding_params.sample_rate;
+
+  uint16_t mtu_size =
+      BT_DEFAULT_BUFFER_SIZE - A2DP_LHDC_OFFSET - sizeof(BT_HDR);
+
+  a2dp_lhdc_encoder_cb.TxAaMtuSize = (mtu_size < peer_mtu) ? mtu_size : peer_mtu;
+
+  //get separation feature.
+  p_encoder_params->channelSplitMode = A2DP_VendorGetChannelSplitModeLhdcV3(p_codec_info);
+  // Set the quality mode index
+  //int old_quality_mode_index = p_encoder_params->quality_mode_index;
+
+  p_encoder_params->maxTargetBitrate = A2DP_VendorGetMaxDatarateLhdcV3(p_codec_info);
+
+
+  p_encoder_params->isLLEnabled = (codec_config.codec_specific_2 & 1ULL) != 0 ? true :false; //A2DP_VendorGetLowLatencyState(p_codec_info);
+
+
+  p_encoder_params->pcm_wlength =
+      a2dp_lhdc_encoder_cb.feeding_params.bits_per_sample >> 3;
+  // Set the Audio format from pcm_wlength
+  p_encoder_params->pcm_fmt = LHDCBT_SMPL_FMT_S16;
+  if (p_encoder_params->pcm_wlength == 2)
+    p_encoder_params->pcm_fmt = LHDCBT_SMPL_FMT_S16;
+  else if (p_encoder_params->pcm_wlength == 3)
+    p_encoder_params->pcm_fmt = LHDCBT_SMPL_FMT_S24;
+ // else if (p_encoder_params->pcm_wlength == 4)
+//    p_encoder_params->pcm_fmt = LHDCBT_SMPL_FMT_S32;
+
+  log::info( ": MTU={}, peer_mtu={}", 
+            a2dp_lhdc_encoder_cb.TxAaMtuSize, peer_mtu);
+  log::info(
+            ": sample_rate: {} "
+            "quality_mode_index: {} pcm_wlength: {} pcm_fmt: {}",
+             p_encoder_params->sample_rate,
+            p_encoder_params->quality_mode_index, p_encoder_params->pcm_wlength,
+            p_encoder_params->pcm_fmt);
+
+#if (BTA_AV_CO_CP_SCMS_T == TRUE)
+    uint32_t max_mtu_len = ( uint32_t)( a2dp_lhdc_encoder_cb.TxAaMtuSize - A2DP_LHDC_MPL_HDR_LEN - 1);
+#else
+    uint32_t max_mtu_len = ( uint32_t)( a2dp_lhdc_encoder_cb.TxAaMtuSize - A2DP_LHDC_MPL_HDR_LEN);
+#endif
+  
+  log::info( ":AR Flag = {}",  A2DP_VendorHasARFlagLhdcV3(p_codec_info));
+  lhdc_set_ext_func(a2dp_lhdc_encoder_cb.lhdc_handle, LHDCBT_EXT_FUNC_AR, A2DP_VendorHasARFlagLhdcV3(p_codec_info), NULL, 0);
+  lhdc_set_ext_func(a2dp_lhdc_encoder_cb.lhdc_handle, LHDCBT_EXT_FUNC_JAS, A2DP_VendorHasJASFlagLhdcV3(p_codec_info), NULL, 0);
+  lhdc_set_ext_func(a2dp_lhdc_encoder_cb.lhdc_handle, LHDCBT_EXT_FUNC_LARC, A2DP_VendorHasLARCFlagLhdcV3(p_codec_info), NULL, 0);
+  lhdc_set_mbr_func(a2dp_lhdc_encoder_cb.lhdc_handle, A2DP_VendorHasMinBRFlagLhdcV3(p_codec_info));
+  // Initialize the encoder.
+  // NOTE: MTU in the initialization must include the AVDT media header size.
+  int result = lhdc_init_encoder(
+      a2dp_lhdc_encoder_cb.lhdc_handle,
+      p_encoder_params->sample_rate,
+      p_encoder_params->pcm_fmt,
+      p_encoder_params->quality_mode_index,
+      p_encoder_params->channelSplitMode > A2DP_LHDC_CH_SPLIT_NONE ? 1 : 0,
+      0 /* This parameter alaways is 0 in A2DP */ ,
+      max_mtu_len,
+      a2dp_vendor_lhdcv3_get_encoder_interval_ms()
+  );
+  lhdc_set_limit_bitrate(a2dp_lhdc_encoder_cb.lhdc_handle, p_encoder_params->maxTargetBitrate);
+
+  lhdc_set_bitrate(a2dp_lhdc_encoder_cb.lhdc_handle, p_encoder_params->quality_mode_index);
+
+#ifdef MCPS_FRAME_ENCODE
+  mcpsStat_all_enc_us_lhdcv3 = 0;
+  mcpsStat_all_enc_frm_lhdcv3 = 0;
+  mcpsStat_time_dur_cnt_lhdcv3 = 0;
+  mcpsStat_enc_frm_per_sec_lhdcv3 = 0;
+  mcpsStat_all_time_dur_ms_lhdcv3 = 0;
+#endif
+
+#if defined(_RECODER_FILE_)
+  if (RecFile == NULL) {
+    RecFile = fopen(ENCODED_FILE_NAME,"wb");
+    log::info( ": Create recode file = {}",  RecFile);
+  }
+  if (pcmFile == NULL) {
+    pcmFile = fopen(PCM_FILE_NAME,"wb");
+    log::info( ": Create recode file = {}",  pcmFile);
+  }
+#endif
+  if (result != 0) {
+    log::error( ": error initializing the LHDC encoder: {}", 
+              result);
+  }
+}
+
+void a2dp_vendor_lhdcv3_encoder_cleanup(void) {
+  if (a2dp_lhdc_encoder_cb.has_lhdc_handle)
+    lhdc_free_handle(a2dp_lhdc_encoder_cb.lhdc_handle);
+  memset(&a2dp_lhdc_encoder_cb, 0, sizeof(a2dp_lhdc_encoder_cb));
+#if defined(_RECODER_FILE_)
+  if (RecFile != NULL) {
+    fclose(RecFile);
+    RecFile = NULL;
+    remove(ENCODED_FILE_NAME);
+  }
+  if (pcmFile != NULL) {
+    fclose(pcmFile);
+    pcmFile = NULL;
+    remove(PCM_FILE_NAME);
+  }
+#endif
+}
+
+void a2dp_vendor_lhdcv3_feeding_reset(void) {
+  /* By default, just clear the entire state */
+  memset(&a2dp_lhdc_encoder_cb.lhdc_feeding_state, 0,
+         sizeof(a2dp_lhdc_encoder_cb.lhdc_feeding_state));
+
+  int encoder_interval = a2dp_vendor_lhdcv3_get_encoder_interval_ms();
+  a2dp_lhdc_encoder_cb.lhdc_feeding_state.bytes_per_tick =
+      (a2dp_lhdc_encoder_cb.feeding_params.sample_rate *
+       a2dp_lhdc_encoder_cb.feeding_params.bits_per_sample / 8 *
+       a2dp_lhdc_encoder_cb.feeding_params.channel_count *
+       encoder_interval) /
+      1000;
+  a2dp_lhdc_encoder_cb.buf_seq = 0;
+  a2dp_lhdc_encoder_cb.bytes_read = 0;
+  a2dp_lhdc_encoder_cb.lhdc_feeding_state.last_frame_us = 0;
+  tA2DP_LHDC_ENCODER_PARAMS* p_encoder_params = &a2dp_lhdc_encoder_cb.lhdc_encoder_params;
+  if (p_encoder_params->quality_mode_index == LHDCBT_QUALITY_AUTO) {
+    if(lhdc_set_bitrate != NULL && a2dp_lhdc_encoder_cb.has_lhdc_handle) {
+      lhdc_set_bitrate(a2dp_lhdc_encoder_cb.lhdc_handle, LHDCBT_QUALITY_RESET_AUTO);
+    }
+  }
+  log::info( ": PCM bytes per tick {}, reset timestamp", 
+            a2dp_lhdc_encoder_cb.lhdc_feeding_state.bytes_per_tick);
+
+#ifdef MCPS_FRAME_ENCODE
+  mcpsStat_all_enc_us_lhdcv3 = 0;
+  mcpsStat_all_enc_frm_lhdcv3 = 0;
+  mcpsStat_time_dur_cnt_lhdcv3 = 0;
+  mcpsStat_enc_frm_per_sec_lhdcv3 = 0;
+  mcpsStat_all_time_dur_ms_lhdcv3 = 0;
+#endif
+}
+
+void a2dp_vendor_lhdcv3_feeding_flush(void) {
+  a2dp_lhdc_encoder_cb.lhdc_feeding_state.counter = 0;
+  log::info( "");
+}
+
+uint64_t a2dp_vendor_lhdcv3_get_encoder_interval_ms(void) {
+  log::info( ": A2DP_LHDC_ENCODER_INTERVAL_MS {}",
+               a2dp_lhdc_encoder_cb.lhdc_encoder_params.isLLEnabled ? A2DP_LHDC_ENCODER_SHORT_INTERVAL_MS : A2DP_LHDC_ENCODER_INTERVAL_MS);
+  if (a2dp_lhdc_encoder_cb.lhdc_encoder_params.isLLEnabled){
+      return A2DP_LHDC_ENCODER_SHORT_INTERVAL_MS;
+  }else{
+      return A2DP_LHDC_ENCODER_INTERVAL_MS;
+  }
+}
+
+int a2dp_vendor_lhdcv3_get_effective_frame_size() {
+  return a2dp_lhdc_encoder_cb.TxAaMtuSize;
+}
+
+void a2dp_vendor_lhdcv3_send_frames(uint64_t timestamp_us) {
+  uint8_t nb_frame = 0;
+  uint8_t nb_iterations = 0;
+
+  a2dp_lhdcv3_get_num_frame_iteration(&nb_iterations, &nb_frame, timestamp_us);
+  log::info( ": Sending {} frames per iteration, {} iterations",
+               nb_frame, nb_iterations);
+
+  if (nb_frame == 0) return;
+
+  for (uint8_t counter = 0; counter < nb_iterations; counter++) {
+    // Transcode frame and enqueue
+    a2dp_lhdcV3_encode_frames(nb_frame);
+  }
+}
+
+// Obtains the number of frames to send and number of iterations
+// to be used. |num_of_iterations| and |num_of_frames| parameters
+// are used as output param for returning the respective values.
+static void a2dp_lhdcv3_get_num_frame_iteration(uint8_t* num_of_iterations,
+                                              uint8_t* num_of_frames,
+                                              uint64_t timestamp_us) {
+  uint32_t result = 0;
+  uint8_t nof = 0;
+  uint8_t noi = 1;
+
+  *num_of_iterations = 0;
+  *num_of_frames = 0;
+
+  int32_t pcm_bytes_per_frame = lhdc_get_block_size(a2dp_lhdc_encoder_cb.lhdc_handle);
+  if (pcm_bytes_per_frame <= 0) {
+    log::info( ": lhdc_get_block_size error!");
+    return;
+  }
+
+  pcm_bytes_per_frame = pcm_bytes_per_frame *
+  a2dp_lhdc_encoder_cb.feeding_params.channel_count *
+  a2dp_lhdc_encoder_cb.feeding_params.bits_per_sample / 8;
+  log::info( ": pcm_bytes_per_frame {}",  pcm_bytes_per_frame);
+
+  int encoder_interval = a2dp_vendor_lhdcv3_get_encoder_interval_ms();
+  uint32_t us_this_tick = encoder_interval * 1000;
+  uint64_t now_us = timestamp_us;
+  if (a2dp_lhdc_encoder_cb.lhdc_feeding_state.last_frame_us != 0)
+    us_this_tick =
+        (now_us - a2dp_lhdc_encoder_cb.lhdc_feeding_state.last_frame_us);
+  a2dp_lhdc_encoder_cb.lhdc_feeding_state.last_frame_us = now_us;
+
+  a2dp_lhdc_encoder_cb.lhdc_feeding_state.counter +=
+      a2dp_lhdc_encoder_cb.lhdc_feeding_state.bytes_per_tick * us_this_tick /
+      (encoder_interval * 1000);
+
+  result =
+      a2dp_lhdc_encoder_cb.lhdc_feeding_state.counter / pcm_bytes_per_frame;
+  a2dp_lhdc_encoder_cb.lhdc_feeding_state.counter -=
+      result * pcm_bytes_per_frame;
+  nof = result;
+
+  log::info( ": effective num of frames {}, iterations {}",  nof, noi);
+
+  *num_of_frames = nof;
+  *num_of_iterations = noi;
+}
+
+static BT_HDR *bt_buf_new( void) {
+    BT_HDR *p_buf = ( BT_HDR*)osi_malloc( BT_DEFAULT_BUFFER_SIZE);
+    if ( p_buf == NULL) {
+        // LeoKu(C): should not happen
+        log::error(  ": bt_buf_new failed!");
+        return  NULL;
+    }
+
+    p_buf->offset = A2DP_LHDC_OFFSET;
+    p_buf->len = 0;
+    p_buf->layer_specific = 0;
+    return  p_buf;
+}
+
+static void a2dp_lhdcV3_encode_frames(uint8_t nb_frame){
+  //tA2DP_LHDC_ENCODER_PARAMS* p_encoder_params =
+  //    &a2dp_lhdc_encoder_cb.lhdc_encoder_params;
+  int32_t samples_per_frame = lhdc_get_block_size(a2dp_lhdc_encoder_cb.lhdc_handle);
+  if (samples_per_frame <= 0) {
+    log::error (": lhdc_get_block_size error!");
+    return;
+  }
+
+#if defined(_RECODER_FILE_)
+  uint32_t pcm_bytes_per_frame = samples_per_frame *
+                                 a2dp_lhdc_encoder_cb.feeding_params.channel_count *
+                                 a2dp_lhdc_encoder_cb.feeding_params.bits_per_sample / 8;
+#endif
+
+#if (BTA_AV_CO_CP_SCMS_T == TRUE)
+  uint32_t max_mtu_len = ( uint32_t)( a2dp_lhdc_encoder_cb.TxAaMtuSize - A2DP_LHDC_MPL_HDR_LEN - 1);
+#else
+  uint32_t max_mtu_len = ( uint32_t)( a2dp_lhdc_encoder_cb.TxAaMtuSize - A2DP_LHDC_MPL_HDR_LEN);
+#endif
+
+  static float mtu_usage = 0;
+  static int mtu_usage_cnt = 0;
+  static uint64_t time_prev_ms = bluetooth::common::time_get_os_boottime_ms();
+  static uint32_t all_send_bytes = 0;
+  uint8_t read_buffer[samples_per_frame * 2 * 4];
+  uint8_t latency =0; // p_encoder_params->latency_mode_index;
+  int32_t out_frames = 0, remain_nb_frame = nb_frame;
+  int32_t written = 0;
+  uint32_t bytes_read = 0;
+  uint8_t* packet;
+  BT_HDR * p_buf = NULL;
+
+#ifdef MCPS_FRAME_ENCODE
+  uint64_t time_prev_enc_us_2 = 0;
+  uint64_t time_aft_enc_us_2 = 0;
+#endif
+
+  while (nb_frame) {
+      if ((p_buf = bt_buf_new()) == NULL) {
+          log::error ( ": ERROR");
+          return;
+      }
+    uint32_t written_frame = 0;
+    do {
+      uint32_t temp_bytes_read = 0;
+      if (a2dp_lhdcv3_read_feeding(read_buffer, &temp_bytes_read)) {
+        a2dp_lhdc_encoder_cb.bytes_read += temp_bytes_read;
+        packet = (uint8_t*)(p_buf + 1) + p_buf->offset + p_buf->len;
+
+        //int result =
+
+      #if defined(_RECODER_FILE_)
+        if (pcmFile != NULL) {
+          fwrite(read_buffer, sizeof(uint8_t), pcm_bytes_per_frame, pcmFile);
+        }
+      #endif
+
+#ifdef MCPS_FRAME_ENCODE
+        time_prev_enc_us_2 = bluetooth::common::time_get_os_boottime_us();
+#endif
+
+        lhdc_encode_func(a2dp_lhdc_encoder_cb.lhdc_handle, read_buffer, packet, (uint32_t*)&written, (uint32_t*)&out_frames);
+
+#ifdef MCPS_FRAME_ENCODE
+#if 0
+        // For old frame per packet mechanism
+        if (mcpsStat_time_dur_cnt_lhdcv3 > 0) { //begin after statistics initialized
+          if (out_frames > 0) {
+            time_aft_enc_us_2 = bluetooth::common::time_get_os_boottime_us();
+            mcpsStat_all_enc_us_lhdcv3 += (time_aft_enc_us_2 - time_prev_enc_us_2);
+            mcpsStat_all_enc_frm_lhdcv3 += out_frames;
+          }
+        }
+#else
+        // For new frame per packet mechanism
+        if (mcpsStat_time_dur_cnt_lhdcv3 > 0) { //begin after statistics initialized
+          time_aft_enc_us_2 = bluetooth::common::time_get_os_boottime_us();
+          mcpsStat_all_enc_us_lhdcv3 += (time_aft_enc_us_2 - time_prev_enc_us_2);
+          mcpsStat_all_enc_frm_lhdcv3 += 1;
+        }
+#endif
+#endif
+
+        #if defined(_RECODER_FILE_)
+        if (RecFile != NULL && written > 0) {
+            fwrite(packet, sizeof(uint8_t), written, RecFile);
+        }
+        #endif
+
+        p_buf->len += written;
+        all_send_bytes += written;
+        nb_frame--;
+        written_frame += out_frames;  // added a frame to the buffer
+        log::info (": nb_frame:{}, written:{}, out_frames:{}",  nb_frame, written, out_frames);
+
+      }else{
+        log::info ( ": underflow {}",  nb_frame);
+        a2dp_lhdc_encoder_cb.lhdc_feeding_state.counter +=
+                        nb_frame * samples_per_frame *
+                        a2dp_lhdc_encoder_cb.feeding_params.channel_count *
+                        a2dp_lhdc_encoder_cb.feeding_params.bits_per_sample / 8;
+
+        // no more pcm to read
+        nb_frame = 0;
+      }
+    } while ((written == 0) && nb_frame);
+
+    if (p_buf->len) {
+      /*
+       * Timestamp of the media packet header represent the TS of the
+       * first frame, i.e the timestamp before including this frame.
+       */
+      p_buf->layer_specific = a2dp_lhdc_encoder_cb.buf_seq++;
+      p_buf->layer_specific <<= 8;
+      p_buf->layer_specific |= ( latency | ( written_frame << A2DP_LHDC_HDR_NUM_SHIFT));
+
+      *( ( uint32_t*)( p_buf + 1)) = a2dp_lhdc_encoder_cb.timestamp;
+      log::info ( ": Timestamp ({})",  a2dp_lhdc_encoder_cb.timestamp);
+
+      a2dp_lhdc_encoder_cb.timestamp += ( written_frame * samples_per_frame);
+
+      uint8_t done_nb_frame = remain_nb_frame - nb_frame;
+      remain_nb_frame = nb_frame;
+      log::info( ": nb_frame:{}, remain_nb_frame:{}, done_nb_frame:{}",  nb_frame, remain_nb_frame, done_nb_frame);
+
+      mtu_usage += ((float)p_buf->len) / max_mtu_len;
+      mtu_usage_cnt++;
+
+      log::info ( ": Read bytes({})",  a2dp_lhdc_encoder_cb.bytes_read);
+      log::info ( ": Send Frame({}), length({})",  written_frame, p_buf->len);
+      bytes_read = a2dp_lhdc_encoder_cb.bytes_read;
+      a2dp_lhdc_encoder_cb.bytes_read = 0;
+
+      if (!a2dp_lhdc_encoder_cb.enqueue_callback(p_buf, 1, bytes_read))
+        return;
+    } else {
+      // NOTE: Unlike the execution path for other codecs, it is normal for
+      // LHDC to NOT write encoded data to the last buffer if there wasn't
+      // enough data to write to. That data is accumulated internally by
+      // the codec and included in the next iteration. Therefore, here we
+      // don't increment the "media_read_total_dropped_packets" counter.
+      log::info ( ": free buffer len({})",  p_buf->len);
+      osi_free(p_buf);
+    }
+  }
+
+  // for statistics
+  uint64_t time_now_ms = bluetooth::common::time_get_os_boottime_ms();
+  if (time_now_ms - time_prev_ms >= 1000 ) {
+#ifdef MCPS_FRAME_ENCODE
+    mcpsStat_time_dur_cnt_lhdcv3++;
+
+    if (mcpsStat_time_dur_cnt_lhdcv3 <= MCPS_FRAME_ENCODE_DUR) {  //how long we stop statistics
+      if (mcpsStat_time_dur_cnt_lhdcv3 <= 1) {
+        mcpsStat_all_time_dur_ms_lhdcv3 = 0;
+      } else {
+        mcpsStat_all_time_dur_ms_lhdcv3 += (time_now_ms - time_prev_ms);
+      }
+
+      /*
+       * MCPS STATISTICS LOG:
+       *  [cnt:{} time_now_ms({})-time_prev_ms({})=({}) {}]:
+       *    cnt       : the number of rounds
+       *    time_now_ms    : now system time point (ms)
+       *    time_prev_ms : previous system time point (ms)
+       *  [{} {} {} kbps]: sampleRate, bitDepth, Bitrate
+       *  frmPerTheSec: number of frames encoded in "this second"
+       *  avgFrmPerSec: so far, the average number of encoded frames per second
+       *  avgUsPerfrm:  so far, the average execution time(us) of each encoded frame
+       *  avgMCPS:  so far, the average MCPS
+       */
+      log::info( "[MCPS_STAT]: [cnt:{} time_now_ms({})-time_prev_ms({})=({}) {}] [{} {} {} kbps] "
+          "frmPerTheSec({}) avgFrmPerSec({}) avgUsPerfrm:({})us, avgMCPS:({})",
+          (uint32_t)mcpsStat_time_dur_cnt_lhdcv3,
+          (uint32_t)time_now_ms,
+          (uint32_t)time_prev_ms,
+          (uint32_t)mcpsStat_all_time_dur_ms_lhdcv3,            //total elapsed time (in ms)
+          (float)mcpsStat_all_time_dur_ms_lhdcv3 / 1000,        //total elapsed time (in sec)
+          a2dp_lhdc_encoder_cb.feeding_params.sample_rate,      //current sample rate
+          a2dp_lhdc_encoder_cb.feeding_params.bits_per_sample,  //current bit depth
+          (all_send_bytes * 8) / 1000,                          //current bit rate
+
+          (uint32_t)(mcpsStat_all_enc_frm_lhdcv3 - mcpsStat_enc_frm_per_sec_lhdcv3),
+          ((float)mcpsStat_all_enc_frm_lhdcv3 / ((float)mcpsStat_all_time_dur_ms_lhdcv3 / 1000)),
+          ((float)mcpsStat_all_enc_us_lhdcv3 / (float)mcpsStat_all_enc_frm_lhdcv3),
+
+          // avgMCPS = (avgUsPerfrm / STATIS_MILLION_UNIT) * CPU_Freq_MHz * avgFrmPerSec
+          (((float)mcpsStat_all_enc_us_lhdcv3 / (float)mcpsStat_all_enc_frm_lhdcv3) * STATIS_CPU_FREQ_MHZ *
+            ((float)mcpsStat_all_enc_frm_lhdcv3 / ((float)mcpsStat_all_time_dur_ms_lhdcv3 / 1000)) /
+            STATIS_MILLION_UNIT)
+          );
+    }
+    mcpsStat_enc_frm_per_sec_lhdcv3 = mcpsStat_all_enc_frm_lhdcv3;
+#endif
+    log::info (": Current data rate about {} kbps, packet usage {}%%", 
+        (all_send_bytes * 8) / 1000, (mtu_usage * 100)/mtu_usage_cnt);
+      all_send_bytes = 0;
+      mtu_usage_cnt = 0;
+      mtu_usage = 0;
+      time_prev_ms = time_now_ms;
+  }
+}
+
+static bool a2dp_lhdcv3_read_feeding(uint8_t* read_buffer, uint32_t *bytes_read) {
+    uint32_t bytes_per_sample = a2dp_lhdc_encoder_cb.feeding_params.channel_count * a2dp_lhdc_encoder_cb.feeding_params.bits_per_sample / 8;
+  uint32_t read_size = 0;
+  int32_t read_size_tmp = lhdc_get_block_size(a2dp_lhdc_encoder_cb.lhdc_handle);
+  if (read_size_tmp <= 0) {
+    log::error (": lhdc_get_block_size error!");
+    return false;
+  }
+  read_size = read_size_tmp * bytes_per_sample;
+
+  a2dp_lhdc_encoder_cb.stats.media_read_total_expected_reads_count++;
+  a2dp_lhdc_encoder_cb.stats.media_read_total_expected_read_bytes += read_size;
+
+  /* Read Data from UIPC channel */
+  uint32_t nb_byte_read =
+      a2dp_lhdc_encoder_cb.read_callback(read_buffer, read_size);
+  log::info( ": want to read size {}, read byte number {}",
+                     read_size, nb_byte_read);
+  if ((nb_byte_read % bytes_per_sample) != 0) {
+	  log::info( ": PCM data not alignment. The audio sample is shfit {} bytes.", (nb_byte_read % bytes_per_sample));
+  }
+  a2dp_lhdc_encoder_cb.stats.media_read_total_actual_read_bytes += nb_byte_read;
+
+  if (nb_byte_read < read_size) {
+    if (nb_byte_read == 0) return false;
+
+    /* Fill the unfilled part of the read buffer with silence (0) */
+    memset(((uint8_t*)read_buffer) + nb_byte_read, 0, read_size - nb_byte_read);
+    nb_byte_read = read_size;
+  }
+  a2dp_lhdc_encoder_cb.stats.media_read_total_actual_reads_count++;
+
+    *bytes_read = nb_byte_read;
+
+  return true;
+}
+
+// library index mapping: quality mode index
+static std::string quality_mode_index_to_name(int quality_mode_index) {
+  switch (quality_mode_index) {
+    case LHDCBT_QUALITY_AUTO:
+      return "ABR";
+    case LHDCBT_QUALITY_HIGH:
+      return "HIGH";
+    case LHDCBT_QUALITY_MID:
+      return "MID";
+    case LHDCBT_QUALITY_LOW:
+      return "LOW";
+    case LHDCBT_QUALITY_LOW4:
+      return "LOW_320";
+    case LHDCBT_QUALITY_LOW3:
+      return "LOW_256";
+    case LHDCBT_QUALITY_LOW2:
+      return "LOW_192";
+    case LHDCBT_QUALITY_LOW1:
+      return "LOW_128";
+    case LHDCBT_QUALITY_LOW0:
+      return "LOW_64";
+    default:
+      return "Unknown";
+  }
+}
+
+void a2dp_vendor_lhdcv3_set_transmit_queue_length(size_t transmit_queue_length) {
+  a2dp_lhdc_encoder_cb.TxQueueLength = transmit_queue_length;
+  tA2DP_LHDC_ENCODER_PARAMS* p_encoder_params = &a2dp_lhdc_encoder_cb.lhdc_encoder_params;
+  if (p_encoder_params->quality_mode_index == LHDCBT_QUALITY_AUTO) {
+      if (lhdc_auto_adjust_bitrate != NULL) {
+          lhdc_auto_adjust_bitrate(a2dp_lhdc_encoder_cb.lhdc_handle, transmit_queue_length);
+      }
+  }
+}
+
+#if 0
+uint64_t A2dpCodecConfigLhdcV3::encoderIntervalMs() const {
+  return a2dp_vendor_lhdcv3_get_encoder_interval_ms();
+}
+#endif
+
+#if 0
+int A2dpCodecConfigLhdcV3::getEffectiveMtu() const {
+  return a2dp_lhdc_encoder_cb.TxAaMtuSize;
+}
+#endif
+
+void A2dpCodecConfigLhdcV3::debug_codec_dump(int fd) {
+  a2dp_lhdc_encoder_stats_t* stats = &a2dp_lhdc_encoder_cb.stats;
+  tA2DP_LHDC_ENCODER_PARAMS* p_encoder_params =
+      &a2dp_lhdc_encoder_cb.lhdc_encoder_params;
+
+  A2dpCodecConfig::debug_codec_dump(fd);
+
+  dprintf(fd,
+          "  Packet counts (expected/dropped)                        : %zu / "
+          "%zu\n",
+          stats->media_read_total_expected_packets,
+          stats->media_read_total_dropped_packets);
+
+  dprintf(fd,
+          "  PCM read counts (expected/actual)                       : %zu / "
+          "%zu\n",
+          stats->media_read_total_expected_reads_count,
+          stats->media_read_total_actual_reads_count);
+
+  dprintf(fd,
+          "  PCM read bytes (expected/actual)                        : %zu / "
+          "%zu\n",
+          stats->media_read_total_expected_read_bytes,
+          stats->media_read_total_actual_read_bytes);
+
+  dprintf(
+      fd, "  LHDC quality mode                                       : %s\n",
+      quality_mode_index_to_name(p_encoder_params->quality_mode_index).c_str());
+
+  dprintf(fd,
+          "  LHDC transmission bitrate (Kbps)                        : %d\n",
+          lhdc_get_bitrate(a2dp_lhdc_encoder_cb.lhdc_handle));
+
+  dprintf(fd,
+          "  LHDC saved transmit queue length                        : %zu\n",
+          a2dp_lhdc_encoder_cb.TxQueueLength);
+/*
+  if (a2dp_lhdc_encoder_cb.has_lhdc_abr_handle) {
+    dprintf(fd,
+            "  LHDC adaptive bit rate encode quality mode index        : %d\n",
+            a2dp_lhdc_encoder_cb.last_lhdc_abr_eqmid);
+    dprintf(fd,
+            "  LHDC adaptive bit rate adjustments                      : %zu\n",
+            a2dp_lhdc_encoder_cb.lhdc_abr_adjustments);
+  }
+  */
+}
diff --git a/system/stack/a2dp/a2dp_vendor_lhdcv5.cc b/system/stack/a2dp/a2dp_vendor_lhdcv5.cc
new file mode 100755
index 0000000000..340755130b
--- /dev/null
+++ b/system/stack/a2dp/a2dp_vendor_lhdcv5.cc
@@ -0,0 +1,3149 @@
+/*
+ * Copyright (C) 2016 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+/******************************************************************************
+ *
+ *  Utility functions to help build and parse the LHDCV5 Codec Information
+ *  Element and Media Payload.
+ *
+ ******************************************************************************/
+
+
+#define LOG_TAG "bluetooth-a2dp"
+
+#include "a2dp_vendor_lhdcv5.h"
+
+#include <bluetooth/log.h>
+#include <string.h>
+
+#include "a2dp_vendor.h"
+#include "a2dp_vendor_lhdcv5_encoder.h"
+#include "a2dp_vendor_lhdcv5_decoder.h"
+
+#include "btif/include/btif_av_co.h"
+#include "internal_include/bt_trace.h"
+
+#include "os/log.h"
+#include "osi/include/osi.h"
+#include "stack/include/bt_hdr.h"
+
+
+using namespace bluetooth;
+
+
+
+// data type for the LHDC Codec Information Element
+typedef struct {
+  uint32_t vendorId;                                    /* Vendor ID */
+  uint16_t codecId;                                     /* Codec ID */
+  uint8_t sampleRate;                                   /* Sampling Frequency Type */
+  uint8_t bitsPerSample;                                /* Bits Per Sample Type */
+  uint8_t channelMode;                                  /* Channel Mode */
+  uint8_t version;                                      /* Codec SubVersion Number */
+  uint8_t frameLenType;                                 /* Frame Length Type */
+  uint8_t maxTargetBitrate;                             /* Max Target Bit Rate Type */
+  uint8_t minTargetBitrate;                             /* Min Target Bit Rate Type */
+  bool hasFeatureAR;                                    /* FeatureSupported: AR */
+  bool hasFeatureJAS;                                   /* FeatureSupported: JAS */
+  bool hasFeatureMETA;                                  /* FeatureSupported: META */
+  bool hasFeatureLL;                                    /* FeatureSupported: Low Latency */
+  bool hasFeatureLLESS48K;                              /* FeatureSupported: Lossless enable/disable (standard 48 KHz) */
+  bool hasFeatureLLESS24Bit;                            /* Lossless extended configurable: 24 bit-per-sample */
+  bool hasFeatureLLESS96K;                              /* Lossless extended configurable: 96 KHz */
+#ifdef LHDC_LOSSLESS_RAW_SUPPORT
+  bool hasFeatureLLESSRaw;                              /* FeatureSupported: Lossless Raw mode (standard 48 KHz) */
+#endif
+} tA2DP_LHDCV5_CIE;
+
+// source capabilities
+static const tA2DP_LHDCV5_CIE a2dp_lhdcv5_source_caps = {
+    A2DP_LHDC_VENDOR_ID,  // vendorId
+    A2DP_LHDCV5_CODEC_ID, // codecId
+    // Sampling Frequency
+    (A2DP_LHDCV5_SAMPLING_FREQ_44100 | A2DP_LHDCV5_SAMPLING_FREQ_48000 | A2DP_LHDCV5_SAMPLING_FREQ_96000 | A2DP_LHDCV5_SAMPLING_FREQ_192000),
+    // Bits Per Sample
+    (A2DP_LHDCV5_BIT_FMT_16 | A2DP_LHDCV5_BIT_FMT_24),
+    // Channel Mode
+    A2DP_LHDCV5_CHANNEL_MODE_STEREO,
+    // Codec SubVersion Number
+    A2DP_LHDCV5_VER_1,
+    // Encoded Frame Length
+    A2DP_LHDCV5_FRAME_LEN_5MS,
+    // Max Target Bit Rate Type
+    A2DP_LHDCV5_MAX_BIT_RATE_1000K,
+    // Min Target Bit Rate Type
+    A2DP_LHDCV5_MIN_BIT_RATE_64K,
+    // FeatureSupported: AR
+    false,
+    // FeatureSupported: JAS
+    false,
+    // FeatureSupported: META
+    false,
+    // FeatureSupported: Low Latency
+    true,
+    // FeatureSupported: Lossless (standard 48 KHz)
+    false,
+    // Lossless extended configurable: 24 bit-per-sample
+    false,
+    // Lossless extended configurable: 96 KHz
+    false,
+#ifdef LHDC_LOSSLESS_RAW_SUPPORT
+    // FeatureSupported: Lossless Raw mode (standard 48 KHz)
+    false,
+#endif
+};
+
+// default source capabilities for best select
+static const tA2DP_LHDCV5_CIE a2dp_lhdcv5_source_default_caps = {
+    A2DP_LHDC_VENDOR_ID,  // vendorId
+    A2DP_LHDCV5_CODEC_ID, // codecId
+    // Sampling Frequency
+    A2DP_LHDCV5_SAMPLING_FREQ_48000,
+    // Bits Per Sample
+    A2DP_LHDCV5_BIT_FMT_24,
+    // Channel Mode
+    A2DP_LHDCV5_CHANNEL_MODE_STEREO,
+    // Codec Version Number
+    A2DP_LHDCV5_VER_1,
+    // Encoded Frame Length
+    A2DP_LHDCV5_FRAME_LEN_5MS,
+    // Max Target Bit Rate Type
+    A2DP_LHDCV5_MAX_BIT_RATE_1000K,
+    // Min Target Bit Rate Type
+    A2DP_LHDCV5_MIN_BIT_RATE_64K,
+    // FeatureSupported: AR
+    false,
+    // FeatureSupported: JAS
+    false,
+    // FeatureSupported: META
+    false,
+    // FeatureSupported: Low Latency
+    true,
+    // FeatureSupported: Lossless (standard 48 KHz)
+    false,
+    // Lossless extended configurable: 24 bit-per-sample
+    false,
+    // Lossless extended configurable: 96 KHz
+    false,
+#ifdef LHDC_LOSSLESS_RAW_SUPPORT
+    // FeatureSupported: Lossless Raw mode (standard 48 KHz)
+    false,
+#endif
+};
+
+// sink capabilities
+static const tA2DP_LHDCV5_CIE a2dp_lhdcv5_sink_caps = {
+    A2DP_LHDC_VENDOR_ID,  // vendorId
+    A2DP_LHDCV5_CODEC_ID, // codecId
+    // Sampling Frequency
+    (A2DP_LHDCV5_SAMPLING_FREQ_44100 | A2DP_LHDCV5_SAMPLING_FREQ_48000 | A2DP_LHDCV5_SAMPLING_FREQ_96000 | A2DP_LHDCV5_SAMPLING_FREQ_192000),
+    // Bits Per Sample
+    (A2DP_LHDCV5_BIT_FMT_16 | A2DP_LHDCV5_BIT_FMT_24 | A2DP_LHDCV5_BIT_FMT_32),
+    // Channel Mode
+    A2DP_LHDCV5_CHANNEL_MODE_STEREO,
+    // Codec Version Number
+    A2DP_LHDCV5_VER_1,
+    // Encoded Frame Length
+    A2DP_LHDCV5_FRAME_LEN_5MS,
+    // Max Target Bit Rate Type
+    A2DP_LHDCV5_MAX_BIT_RATE_1000K,
+    // Min Target Bit Rate Type
+    A2DP_LHDCV5_MIN_BIT_RATE_64K,
+    // FeatureSupported: AR
+    false,
+    // FeatureSupported: JAS
+    false,
+    // FeatureSupported: META
+    false,
+    // FeatureSupported: Low Latency
+    true,
+    // FeatureSupported: Lossless (standard 48 KHz)
+    false,
+    // Lossless extended configurable: 24 bit-per-sample
+    false,
+    // Lossless extended configurable: 96 KHz
+    false,
+#ifdef LHDC_LOSSLESS_RAW_SUPPORT
+    // FeatureSupported: Lossless Raw mode (standard 48 KHz)
+    false,
+#endif
+};
+
+// default sink capabilities
+UNUSED_ATTR static const tA2DP_LHDCV5_CIE a2dp_lhdcv5_sink_default_caps = {
+    A2DP_LHDC_VENDOR_ID,  // vendorId
+    A2DP_LHDCV5_CODEC_ID, // codecId
+    // Sampling Frequency
+    A2DP_LHDCV5_SAMPLING_FREQ_48000,
+    // Bits Per Sample
+    A2DP_LHDCV5_BIT_FMT_24,
+    // Channel Mode
+    A2DP_LHDCV5_CHANNEL_MODE_STEREO,
+    // Codec Version Number
+    A2DP_LHDCV5_VER_1,
+    // Encoded Frame Length
+    A2DP_LHDCV5_FRAME_LEN_5MS,
+    // Max Target Bit Rate Type
+    A2DP_LHDCV5_MAX_BIT_RATE_1000K,
+    // Min Target Bit Rate Type
+    A2DP_LHDCV5_MIN_BIT_RATE_64K,
+    // FeatureSupported: AR
+    false,
+    // FeatureSupported: JAS
+    false,
+    // FeatureSupported: META
+    false,
+    // FeatureSupported: Low Latency
+    true,
+    // FeatureSupported: Lossless (standard 48 KHz)
+    false,
+    // Lossless extended configurable: 24 bit-per-sample
+    false,
+    // Lossless extended configurable: 96 KHz
+    false,
+#ifdef LHDC_LOSSLESS_RAW_SUPPORT
+    // FeatureSupported: Lossless Raw mode (standard 48 KHz)
+    false,
+#endif
+};
+
+//
+// Utilities for LHDC configuration on A2DP specifics - START
+//
+typedef struct {
+  btav_a2dp_codec_config_t *_codec_config_;
+  btav_a2dp_codec_config_t *_codec_capability_;
+  btav_a2dp_codec_config_t *_codec_local_capability_;
+  btav_a2dp_codec_config_t *_codec_selectable_capability_;
+  btav_a2dp_codec_config_t *_codec_user_config_;
+  btav_a2dp_codec_config_t *_codec_audio_config_;
+}tA2DP_CODEC_CONFIGS_PACK;
+
+typedef struct {
+  uint8_t   featureCode;  /* code of LHDC features */
+  uint8_t   inSpecBank;   /* target specific to store the feature flag */
+  uint8_t   bitPos;       /* the bit index(0~63) of the specific(int64_t) that bit store */
+  int64_t   value;        /* real value of the bit position written to the target specific */
+}tA2DP_LHDC_FEATURE_POS;
+
+// default settings of LHDC features configuration on specifics
+// info of feature: JAS
+static const tA2DP_LHDC_FEATURE_POS a2dp_lhdcv5_source_spec_JAS = {
+    LHDCV5_FEATURE_CODE_JAS,
+    LHDCV5_FEATURE_ON_A2DP_SPECIFIC_3,
+    LHDCV5_FEATURE_JAS_SPEC_BIT_POS,
+    (0x1ULL << LHDCV5_FEATURE_JAS_SPEC_BIT_POS),
+};
+
+// info of feature: AR
+static const tA2DP_LHDC_FEATURE_POS a2dp_lhdcv5_source_spec_AR = {
+    LHDCV5_FEATURE_CODE_AR,
+    LHDCV5_FEATURE_ON_A2DP_SPECIFIC_3,
+    LHDCV5_FEATURE_AR_SPEC_BIT_POS,
+    (0x1ULL << LHDCV5_FEATURE_AR_SPEC_BIT_POS),
+};
+
+// info of feature: META
+static const tA2DP_LHDC_FEATURE_POS a2dp_lhdcv5_source_spec_META = {
+    LHDCV5_FEATURE_CODE_META,
+    LHDCV5_FEATURE_ON_A2DP_SPECIFIC_3,
+    LHDCV5_FEATURE_META_SPEC_BIT_POS,
+    (0x1ULL << LHDCV5_FEATURE_META_SPEC_BIT_POS),
+};
+
+// info of feature: Low Latency
+static const tA2DP_LHDC_FEATURE_POS a2dp_lhdcv5_source_spec_LL = {
+    LHDCV5_FEATURE_CODE_LL,
+    LHDCV5_FEATURE_ON_A2DP_SPECIFIC_2,
+    LHDCV5_FEATURE_LL_SPEC_BIT_POS,
+    (0x1ULL << LHDCV5_FEATURE_LL_SPEC_BIT_POS),
+};
+
+// info of feature: LossLess
+static const tA2DP_LHDC_FEATURE_POS a2dp_lhdcv5_source_spec_LLESS = {
+    LHDCV5_FEATURE_CODE_LLESS,
+    LHDCV5_FEATURE_ON_A2DP_SPECIFIC_3,
+    LHDCV5_FEATURE_LLESS_SPEC_BIT_POS,
+    (0x1ULL << LHDCV5_FEATURE_LLESS_SPEC_BIT_POS),
+};
+
+#ifdef LHDC_LOSSLESS_RAW_SUPPORT
+// info of feature: LossLess Raw
+static const tA2DP_LHDC_FEATURE_POS a2dp_lhdcv5_source_spec_LLESS_RAW = {
+    LHDCV5_FEATURE_CODE_LLESS_RAW,
+    LHDCV5_FEATURE_ON_A2DP_SPECIFIC_3,
+    LHDCV5_FEATURE_LLESS_RAW_SPEC_BIT_POS,
+    (0x1ULL << LHDCV5_FEATURE_LLESS_RAW_SPEC_BIT_POS),
+};
+#endif
+
+
+UNUSED_ATTR static const tA2DP_LHDC_FEATURE_POS a2dp_lhdcv5_source_spec_all[] = {
+    a2dp_lhdcv5_source_spec_JAS,
+    a2dp_lhdcv5_source_spec_AR,
+    a2dp_lhdcv5_source_spec_META,
+    a2dp_lhdcv5_source_spec_LL,
+    a2dp_lhdcv5_source_spec_LLESS,
+#ifdef LHDC_LOSSLESS_RAW_SUPPORT
+    a2dp_lhdcv5_source_spec_LLESS_RAW,
+#endif
+};
+
+// to check if target feature bit is set in codec_user_config_
+static bool A2DP_IsFeatureInUserConfigLhdcV5(tA2DP_CODEC_CONFIGS_PACK* cfgsPtr, uint8_t featureCode) {
+  bool ret = false;
+
+  if (cfgsPtr == nullptr) {
+    log::error( ": nullptr input");
+    return false;
+  }
+
+  switch (featureCode) {
+  case LHDCV5_FEATURE_CODE_JAS:
+  {
+    ret = LHDCV5_CHECK_IN_A2DP_SPEC(cfgsPtr->_codec_user_config_,
+        a2dp_lhdcv5_source_spec_JAS.inSpecBank, a2dp_lhdcv5_source_spec_JAS.value);
+    return ret;
+  } break;
+  case LHDCV5_FEATURE_CODE_AR:
+  {
+    return LHDCV5_CHECK_IN_A2DP_SPEC(cfgsPtr->_codec_user_config_,
+        a2dp_lhdcv5_source_spec_AR.inSpecBank, a2dp_lhdcv5_source_spec_AR.value);
+  } break;
+  case LHDCV5_FEATURE_CODE_META:
+  {
+    return LHDCV5_CHECK_IN_A2DP_SPEC(cfgsPtr->_codec_user_config_,
+        a2dp_lhdcv5_source_spec_META.inSpecBank, a2dp_lhdcv5_source_spec_META.value);
+  } break;
+  case LHDCV5_FEATURE_CODE_LL:
+  {
+    return LHDCV5_CHECK_IN_A2DP_SPEC(cfgsPtr->_codec_user_config_,
+        a2dp_lhdcv5_source_spec_LL.inSpecBank, a2dp_lhdcv5_source_spec_LL.value);
+  } break;
+  case LHDCV5_FEATURE_CODE_LLESS:
+  {
+    return LHDCV5_CHECK_IN_A2DP_SPEC(cfgsPtr->_codec_user_config_,
+        a2dp_lhdcv5_source_spec_LLESS.inSpecBank, a2dp_lhdcv5_source_spec_LLESS.value);
+  } break;
+#ifdef LHDC_LOSSLESS_RAW_SUPPORT
+  case LHDCV5_FEATURE_CODE_LLESS_RAW:
+  {
+    return LHDCV5_CHECK_IN_A2DP_SPEC(cfgsPtr->_codec_user_config_,
+        a2dp_lhdcv5_source_spec_LLESS_RAW.inSpecBank, a2dp_lhdcv5_source_spec_LLESS_RAW.value);
+  } break;
+#endif
+  default:
+    break;
+  }
+
+  return false;
+}
+
+// to check if target feature bit is set in codec_config_
+static bool A2DP_IsFeatureInCodecConfigLhdcV5(tA2DP_CODEC_CONFIGS_PACK* cfgsPtr, uint8_t featureCode) {
+  if (cfgsPtr == nullptr) {
+    log::error( ": nullptr input");
+    return false;
+  }
+
+  switch(featureCode) {
+  case LHDCV5_FEATURE_CODE_JAS:
+  {
+    return LHDCV5_CHECK_IN_A2DP_SPEC(cfgsPtr->_codec_config_,
+        a2dp_lhdcv5_source_spec_JAS.inSpecBank, a2dp_lhdcv5_source_spec_JAS.value);
+  } break;
+  case LHDCV5_FEATURE_CODE_AR:
+  {
+    return LHDCV5_CHECK_IN_A2DP_SPEC(cfgsPtr->_codec_config_,
+        a2dp_lhdcv5_source_spec_AR.inSpecBank, a2dp_lhdcv5_source_spec_AR.value);
+  } break;
+  case LHDCV5_FEATURE_CODE_META:
+  {
+    return LHDCV5_CHECK_IN_A2DP_SPEC(cfgsPtr->_codec_config_,
+        a2dp_lhdcv5_source_spec_META.inSpecBank, a2dp_lhdcv5_source_spec_META.value);
+  } break;
+  case LHDCV5_FEATURE_CODE_LL:
+  {
+    return LHDCV5_CHECK_IN_A2DP_SPEC(cfgsPtr->_codec_config_,
+        a2dp_lhdcv5_source_spec_LL.inSpecBank, a2dp_lhdcv5_source_spec_LL.value);
+  } break;
+  case LHDCV5_FEATURE_CODE_LLESS:
+  {
+    return LHDCV5_CHECK_IN_A2DP_SPEC(cfgsPtr->_codec_config_,
+        a2dp_lhdcv5_source_spec_LLESS.inSpecBank, a2dp_lhdcv5_source_spec_LLESS.value);
+  } break;
+#ifdef LHDC_LOSSLESS_RAW_SUPPORT
+  case LHDCV5_FEATURE_CODE_LLESS_RAW:
+  {
+    return LHDCV5_CHECK_IN_A2DP_SPEC(cfgsPtr->_codec_config_,
+        a2dp_lhdcv5_source_spec_LLESS_RAW.inSpecBank, a2dp_lhdcv5_source_spec_LLESS_RAW.value);
+  } break;
+#endif
+  default:
+    break;
+  }
+
+  return false;
+}
+
+static void A2DP_UpdateFeatureToSpecLhdcV5(tA2DP_CODEC_CONFIGS_PACK* cfgsPtr,
+    uint16_t toCodecCfg, bool hasFeature, uint8_t toSpec, int64_t value) {
+  if (cfgsPtr == nullptr) {
+    log::error( ": nullptr input");
+    return;
+  }
+
+  if (toCodecCfg & A2DP_LHDC_TO_A2DP_CODEC_CONFIG_) {
+    LHDC_SETUP_A2DP_SPEC(cfgsPtr->_codec_config_, toSpec, hasFeature, value);
+  }
+  if (toCodecCfg & A2DP_LHDC_TO_A2DP_CODEC_CAP_) {
+    LHDC_SETUP_A2DP_SPEC(cfgsPtr->_codec_capability_, toSpec, hasFeature, value);
+  }
+  if (toCodecCfg & A2DP_LHDC_TO_A2DP_CODEC_LOCAL_CAP_) {
+    LHDC_SETUP_A2DP_SPEC(cfgsPtr->_codec_local_capability_, toSpec, hasFeature, value);
+  }
+  if (toCodecCfg & A2DP_LHDC_TO_A2DP_CODEC_SELECT_CAP_) {
+    LHDC_SETUP_A2DP_SPEC(cfgsPtr->_codec_selectable_capability_, toSpec, hasFeature, value);
+  }
+  if (toCodecCfg & A2DP_LHDC_TO_A2DP_CODEC_USER_) {
+    LHDC_SETUP_A2DP_SPEC(cfgsPtr->_codec_user_config_, toSpec, hasFeature, value);
+  }
+  if (toCodecCfg & A2DP_LHDC_TO_A2DP_CODEC_AUDIO_) {
+    LHDC_SETUP_A2DP_SPEC(cfgsPtr->_codec_audio_config_, toSpec, hasFeature, value);
+  }
+}
+
+// to update feature bit value to target codec config's specific
+static void A2DP_UpdateFeatureToA2dpConfigLhdcV5(tA2DP_CODEC_CONFIGS_PACK *cfgsPtr,
+    uint8_t featureCode,  uint16_t toCodecCfg, bool hasFeature) {
+  if (cfgsPtr == nullptr) {
+    log::error( ": nullptr input");
+    return;
+  }
+
+  switch(featureCode) {
+  case LHDCV5_FEATURE_CODE_JAS:
+    A2DP_UpdateFeatureToSpecLhdcV5(cfgsPtr, toCodecCfg, hasFeature,
+        a2dp_lhdcv5_source_spec_JAS.inSpecBank, a2dp_lhdcv5_source_spec_JAS.value);
+    break;
+  case LHDCV5_FEATURE_CODE_AR:
+    A2DP_UpdateFeatureToSpecLhdcV5(cfgsPtr, toCodecCfg, hasFeature,
+        a2dp_lhdcv5_source_spec_AR.inSpecBank, a2dp_lhdcv5_source_spec_AR.value);
+    break;
+  case LHDCV5_FEATURE_CODE_META:
+    A2DP_UpdateFeatureToSpecLhdcV5(cfgsPtr, toCodecCfg, hasFeature,
+        a2dp_lhdcv5_source_spec_META.inSpecBank, a2dp_lhdcv5_source_spec_META.value);
+    break;
+  case LHDCV5_FEATURE_CODE_LL:
+    A2DP_UpdateFeatureToSpecLhdcV5(cfgsPtr, toCodecCfg, hasFeature,
+        a2dp_lhdcv5_source_spec_LL.inSpecBank, a2dp_lhdcv5_source_spec_LL.value);
+    break;
+  case LHDCV5_FEATURE_CODE_LLESS:
+    A2DP_UpdateFeatureToSpecLhdcV5(cfgsPtr, toCodecCfg, hasFeature,
+        a2dp_lhdcv5_source_spec_LLESS.inSpecBank, a2dp_lhdcv5_source_spec_LLESS.value);
+    break;
+#ifdef LHDC_LOSSLESS_RAW_SUPPORT
+  case LHDCV5_FEATURE_CODE_LLESS_RAW:
+    A2DP_UpdateFeatureToSpecLhdcV5(cfgsPtr, toCodecCfg, hasFeature,
+        a2dp_lhdcv5_source_spec_LLESS_RAW.inSpecBank, a2dp_lhdcv5_source_spec_LLESS_RAW.value);
+    break;
+#endif
+  default:
+    break;
+  }
+}
+//
+// Utilities for LHDC configuration on A2DP specifics - END
+
+static const tA2DP_ENCODER_INTERFACE a2dp_encoder_interface_lhdcv5 = {
+    a2dp_vendor_lhdcv5_encoder_init,
+    a2dp_vendor_lhdcv5_encoder_cleanup,
+    a2dp_vendor_lhdcv5_feeding_reset,
+    a2dp_vendor_lhdcv5_feeding_flush,
+    a2dp_vendor_lhdcv5_get_encoder_interval_ms,
+    a2dp_vendor_lhdcv5_get_effective_frame_size,
+    a2dp_vendor_lhdcv5_send_frames,
+    a2dp_vendor_lhdcv5_set_transmit_queue_length,
+};
+
+static const tA2DP_DECODER_INTERFACE a2dp_decoder_interface_lhdcv5 = {
+    a2dp_vendor_lhdcv5_decoder_init,
+    a2dp_vendor_lhdcv5_decoder_cleanup,
+    a2dp_vendor_lhdcv5_decoder_decode_packet,
+    a2dp_vendor_lhdcv5_decoder_start,
+    a2dp_vendor_lhdcv5_decoder_suspend,
+    a2dp_vendor_lhdcv5_decoder_configure,
+};
+
+UNUSED_ATTR static tA2DP_STATUS A2DP_CodecInfoMatchesCapabilityLhdcV5(
+    const tA2DP_LHDCV5_CIE* p_cap, const uint8_t* p_codec_info,
+    bool is_capability);
+
+
+// check if target version is supported right now
+static bool is_codec_version_supported(uint8_t version, bool is_source) {
+  const tA2DP_LHDCV5_CIE* p_a2dp_lhdcv5_caps =
+      (is_source) ? &a2dp_lhdcv5_source_caps : &a2dp_lhdcv5_sink_caps;
+
+  if ((version & p_a2dp_lhdcv5_caps->version) != A2DP_LHDCV5_VER_NS) {
+    return true;
+  }
+
+  log::info( ": versoin unsupported! peer:{} local:{}",
+       version, p_a2dp_lhdcv5_caps->version);
+  return false;
+}
+
+// Builds the LHDC Media Codec Capabilities byte sequence beginning from the
+// LOSC octet. |media_type| is the media type |AVDT_MEDIA_TYPE_*|.
+// |p_ie| is a pointer to the LHDC Codec Information Element information.
+// The result is stored in |p_result|. Returns A2DP_SUCCESS on success,
+// otherwise the corresponding A2DP error status code.
+static tA2DP_STATUS A2DP_BuildInfoLhdcV5(uint8_t media_type,
+    const tA2DP_LHDCV5_CIE* p_ie,
+    uint8_t* p_result) {
+
+  const uint8_t* tmpInfo = p_result;
+  uint8_t para = 0;
+
+  if (p_ie == nullptr || p_result == nullptr) {
+    log::error( ": nullptr input");
+    return A2DP_INVALID_CODEC_PARAMETER;
+  }
+
+  *p_result++ = A2DP_LHDCV5_CODEC_LEN;  //H0
+  *p_result++ = (media_type << 4);      //H1
+  *p_result++ = A2DP_MEDIA_CT_NON_A2DP; //H2
+
+  // Vendor ID(P0-P3) and Codec ID(P4-P5)
+  *p_result++ = (uint8_t)(p_ie->vendorId & 0x000000FF);
+  *p_result++ = (uint8_t)((p_ie->vendorId & 0x0000FF00) >> 8);
+  *p_result++ = (uint8_t)((p_ie->vendorId & 0x00FF0000) >> 16);
+  *p_result++ = (uint8_t)((p_ie->vendorId & 0xFF000000) >> 24);
+  *p_result++ = (uint8_t)(p_ie->codecId & 0x00FF);
+  *p_result++ = (uint8_t)((p_ie->codecId & 0xFF00) >> 8);
+
+  para = 0;
+  // P6[5:0] Sampling Frequency
+  if ((p_ie->sampleRate & A2DP_LHDCV5_SAMPLING_FREQ_MASK) != A2DP_LHDCV5_SAMPLING_FREQ_NS) {
+    para |= (p_ie->sampleRate & A2DP_LHDCV5_SAMPLING_FREQ_MASK);
+  } else {
+    log::error( ": invalid sample rate (0x{:02x})",  p_ie->sampleRate);
+    return A2DP_INVALID_CODEC_PARAMETER;
+  }
+  // update P6
+  *p_result++ = para; para = 0;
+
+  // P7[2:0] Bit Depth
+  if ((p_ie->bitsPerSample & A2DP_LHDCV5_BIT_FMT_MASK) != A2DP_LHDCV5_BIT_FMT_NS) {
+    para |= (p_ie->bitsPerSample & A2DP_LHDCV5_BIT_FMT_MASK);
+  } else {
+    log::error( ": invalid bits per sample (0x{:02x})",  p_ie->bitsPerSample);
+    return A2DP_INVALID_CODEC_PARAMETER;
+  }
+  // P7[5:4] Max Target Bit Rate
+  para |= (p_ie->maxTargetBitrate & A2DP_LHDCV5_MAX_BIT_RATE_MASK);
+  // P7[7:6] Min Target Bit Rate
+  para |= (p_ie->minTargetBitrate & A2DP_LHDCV5_MIN_BIT_RATE_MASK);
+  // update P7
+  *p_result++ = para; para = 0;
+
+  // P8[3:0] Codec SubVersion
+  if ((p_ie->version & A2DP_LHDCV5_VERSION_MASK) != A2DP_LHDCV5_VER_NS) {
+    para = para | (p_ie->version & A2DP_LHDCV5_VERSION_MASK);
+  } else {
+    log::error( ": invalid codec subversion (0x{:02x})",  p_ie->version);
+    return A2DP_INVALID_CODEC_PARAMETER;
+  }
+  // P8[5:4] Frame Length Type
+  if ((p_ie->frameLenType & A2DP_LHDCV5_FRAME_LEN_MASK) != A2DP_LHDCV5_FRAME_LEN_NS) {
+    para = para | (p_ie->frameLenType & A2DP_LHDCV5_FRAME_LEN_MASK);
+  } else {
+    log::error( ": invalid frame length type (0x{:02x})",  p_ie->frameLenType);
+    return A2DP_INVALID_CODEC_PARAMETER;
+  }
+  // update P8
+  *p_result++ = para; para = 0;
+
+  // P9[0] HasAR
+  // P9[1] HasJAS
+  // P9[2] HasMeta
+  // P9[4] HasLossless96K
+  // P9[5] HasLossless24Bit
+  // P9[6] HasLL
+  // P9[7] HasLossless48K
+  if (p_ie->hasFeatureAR) {
+    para |= A2DP_LHDCV5_FEATURE_AR;
+  }
+  if (p_ie->hasFeatureJAS) {
+    para |= A2DP_LHDCV5_FEATURE_JAS;
+  }
+  if (p_ie->hasFeatureMETA) {
+    para |= A2DP_LHDCV5_FEATURE_META;
+  }
+  if (p_ie->hasFeatureLL) {
+    para |= A2DP_LHDCV5_FEATURE_LL;
+  }
+  if (p_ie->hasFeatureLLESS48K) {
+    para |= A2DP_LHDCV5_FEATURE_LLESS48K;
+  }
+  if (p_ie->hasFeatureLLESS24Bit) {
+    para |= A2DP_LHDCV5_FEATURE_LLESS24BIT;
+  }
+  if (p_ie->hasFeatureLLESS96K) {
+    para |= A2DP_LHDCV5_FEATURE_LLESS96K;
+  }
+  // update P9
+  *p_result++ = para; para = 0;
+
+#ifdef LHDC_LOSSLESS_RAW_SUPPORT
+  // P10[7] HaslosslessRaw
+  if (p_ie->hasFeatureLLESSRaw) {
+    para |= A2DP_LHDCV5_FEATURE_LLESS_RAW;
+  }
+#endif
+  // update P10
+  *p_result++ = para; para = 0;
+
+  log::info( ": codec info built = H0-H2:{} {} {} P0-P3:{} "
+      "{} {} {} P4-P5:{} {} P6:{} P7:{} P8:{} P9:{} P10:{}", 
+      tmpInfo[0], tmpInfo[1], tmpInfo[2], tmpInfo[3], tmpInfo[4], tmpInfo[5], tmpInfo[6], tmpInfo[7],
+      tmpInfo[8], tmpInfo[9], tmpInfo[10], tmpInfo[11], tmpInfo[12], tmpInfo[A2DP_LHDCV5_CODEC_LEN]);
+
+  return A2DP_SUCCESS;
+}
+
+// Parses the LHDC Media Codec Capabilities byte sequence beginning from the
+// LOSC octet. The result is stored in |p_ie|. The byte sequence to parse is
+// |p_codec_info|. If |is_capability| is true, the byte sequence is
+// codec capabilities, otherwise is codec configuration.
+// Returns A2DP_SUCCESS on success, otherwise the corresponding A2DP error
+// status code.
+static tA2DP_STATUS A2DP_ParseInfoLhdcV5(tA2DP_LHDCV5_CIE* p_ie,
+    const uint8_t* p_codec_info,
+    bool is_capability,
+    bool is_source) {
+  uint8_t losc;
+  uint8_t media_type;
+  tA2DP_CODEC_TYPE codec_type;
+  const uint8_t* tmpInfo = p_codec_info;
+  const uint8_t* p_codec_Info_save = p_codec_info;
+
+  if (p_ie == nullptr || p_codec_info == nullptr) {
+    log::error( ": nullptr input");
+    return AVDTP_UNSUPPORTED_CONFIGURATION;
+  }
+
+  // Codec capability length
+  losc = *p_codec_info++;
+  if (losc != A2DP_LHDCV5_CODEC_LEN) {
+    log::error( ": wrong length {}",  losc);
+    return AVDTP_UNSUPPORTED_CONFIGURATION;
+  }
+
+  media_type = (*p_codec_info++) >> 4;
+  codec_type = static_cast<tA2DP_CODEC_TYPE>(*p_codec_info++);
+
+  // Media Type and Media Codec Type
+  if (media_type != AVDT_MEDIA_TYPE_AUDIO ||
+      codec_type != A2DP_MEDIA_CT_NON_A2DP) {
+    log::error( ": invalid media type 0x{:02x} codec_type 0x{:02x}",  media_type, codec_type);
+    return AVDTP_UNSUPPORTED_CONFIGURATION;
+  }
+
+  // Vendor ID(P0-P3) and Codec ID(P4-P5)
+  p_ie->vendorId = (*p_codec_info & 0x000000FF) |
+      (*(p_codec_info + 1) << 8 & 0x0000FF00) |
+      (*(p_codec_info + 2) << 16 & 0x00FF0000) |
+      (*(p_codec_info + 3) << 24 & 0xFF000000);
+  p_codec_info += 4;
+  p_ie->codecId = (*p_codec_info & 0x00FF) | (*(p_codec_info + 1) << 8 & 0xFF00);
+  p_codec_info += 2;
+  if (p_ie->vendorId != A2DP_LHDC_VENDOR_ID ||
+      p_ie->codecId != A2DP_LHDCV5_CODEC_ID) {
+    log::error( ": invalid vendorId 0x{:02x} codecId 0x{:02x}",
+        p_ie->vendorId, p_ie->codecId);
+    return AVDTP_UNSUPPORTED_CONFIGURATION;
+  }
+
+  // P6[5:0] Sampling Frequency
+  p_ie->sampleRate = (*p_codec_info & A2DP_LHDCV5_SAMPLING_FREQ_MASK);
+  if (p_ie->sampleRate == A2DP_LHDCV5_SAMPLING_FREQ_NS) {
+    log::error( ": invalid sample rate 0x{:02x}",  p_ie->sampleRate);
+    return AVDTP_UNSUPPORTED_CONFIGURATION;
+  }
+  p_codec_info += 1;
+
+  // P7[2:0] Bits Per Sample
+  p_ie->bitsPerSample = (*p_codec_info & A2DP_LHDCV5_BIT_FMT_MASK);
+  if (p_ie->bitsPerSample == A2DP_LHDCV5_BIT_FMT_NS) {
+    log::error( ": invalid bit per sample 0x{:02x}",  p_ie->bitsPerSample);
+    return AVDTP_UNSUPPORTED_CONFIGURATION;
+  }
+  // P7[5:4] Max Target Bit Rate
+  p_ie->maxTargetBitrate = (*p_codec_info & A2DP_LHDCV5_MAX_BIT_RATE_MASK);
+  // P7[7:6] Min Target Bit Rate
+  p_ie->minTargetBitrate = (*p_codec_info & A2DP_LHDCV5_MIN_BIT_RATE_MASK);
+  p_codec_info += 1;
+
+  // Channel Mode: stereo only
+  p_ie->channelMode = A2DP_LHDCV5_CHANNEL_MODE_STEREO;
+
+  // P8[3:0] Codec SubVersion
+  p_ie->version = (*p_codec_info & A2DP_LHDCV5_VERSION_MASK);
+  if (p_ie->version == A2DP_LHDCV5_VER_NS) {
+    log::error( ": invalid version 0x{:02x}",  p_ie->version);
+    return AVDTP_UNSUPPORTED_CONFIGURATION;
+  } else {
+    if (!is_codec_version_supported(p_ie->version, is_source)) {
+      log::error( ": unsupported version 0x{:02x}",  p_ie->version);
+      return AVDTP_UNSUPPORTED_CONFIGURATION;
+    }
+  }
+  // P8[5:4] Frame Length Type
+  p_ie->frameLenType = (*p_codec_info & A2DP_LHDCV5_FRAME_LEN_MASK);
+  if (p_ie->frameLenType == A2DP_LHDCV5_FRAME_LEN_NS) {
+    log::error( ": invalid frame length mode 0x{:02x}",  p_ie->frameLenType);
+    return AVDTP_UNSUPPORTED_CONFIGURATION;
+  }
+  p_codec_info += 1;
+
+  // Features:
+  // P9[0] HasAR
+  // P9[1] HasJAS
+  // P9[2] HasMeta
+  // P9[4] HasLossless96K
+  // P9[5] HasLossless24bit
+  // P9[6] HasLL
+  // P9[7] HasLossless
+  p_ie->hasFeatureAR = ((*p_codec_info & A2DP_LHDCV5_FEATURE_AR) != 0) ? true : false;
+  p_ie->hasFeatureJAS = ((*p_codec_info & A2DP_LHDCV5_FEATURE_JAS) != 0) ? true : false;
+  p_ie->hasFeatureMETA = ((*p_codec_info & A2DP_LHDCV5_FEATURE_META) != 0) ? true : false;
+  p_ie->hasFeatureLL = ((*p_codec_info & A2DP_LHDCV5_FEATURE_LL) != 0) ? true : false;
+  p_ie->hasFeatureLLESS48K = ((*p_codec_info & A2DP_LHDCV5_FEATURE_LLESS48K) != 0) ? true : false;
+  p_ie->hasFeatureLLESS24Bit = ((*p_codec_info & A2DP_LHDCV5_FEATURE_LLESS24BIT) != 0) ? true : false;
+  p_ie->hasFeatureLLESS96K = ((*p_codec_info & A2DP_LHDCV5_FEATURE_LLESS96K) != 0) ? true : false;
+  p_codec_info += 1;
+
+#ifdef LHDC_LOSSLESS_RAW_SUPPORT
+  // P10[7] HasLosslessRaw
+  p_ie->hasFeatureLLESSRaw = ((*p_codec_info & A2DP_LHDCV5_FEATURE_LLESS_RAW) != 0) ? true : false;
+#endif
+
+  log::info( ": codec info parsed = H0-H2:{} {} {} P0-P3:{} "
+      "{} {} {} P4-P5:{} {} P6:{} P7:{} P8:{} P9:{} P10:{}", 
+      tmpInfo[0], tmpInfo[1], tmpInfo[2], tmpInfo[3], tmpInfo[4], tmpInfo[5], tmpInfo[6], tmpInfo[7],
+      tmpInfo[8], tmpInfo[9], tmpInfo[10], tmpInfo[11], tmpInfo[12], tmpInfo[A2DP_LHDCV5_CODEC_LEN]);
+
+  log::info( ":  isCap{} SR{} BPS{} Ver{} FL{} "
+      "MBR{} mBR{} FeatureAR({}) JAS({}) META({}) LL({}) LLESS({}) LLESS24({}) LLESS96K({}) LLESSRaw({})",
+      
+      (is_source?"SRC":"SNK"),
+      is_capability,
+      p_ie->sampleRate,
+      p_ie->bitsPerSample,
+      p_ie->version,
+      p_ie->frameLenType,
+      p_ie->maxTargetBitrate,
+      p_ie->minTargetBitrate,
+      p_ie->hasFeatureAR,
+      p_ie->hasFeatureJAS,
+      p_ie->hasFeatureMETA,
+      p_ie->hasFeatureLL,
+      p_ie->hasFeatureLLESS48K,
+      p_ie->hasFeatureLLESS24Bit,
+      p_ie->hasFeatureLLESS96K,
+#ifdef LHDC_LOSSLESS_RAW_SUPPORT
+      p_ie->hasFeatureLLESSRaw);
+#else
+      -1);
+#endif
+
+  //save decoder needed parameters
+#if 1
+  if (!is_source) {
+    if (!a2dp_lhdcv5_decoder_save_codec_info(p_codec_Info_save)) {
+      log::info( ": save decoder parameters error");
+    }
+  }
+#endif
+
+  return A2DP_SUCCESS;
+}
+
+bool A2DP_IsVendorSourceCodecValidLhdcV5(const uint8_t* p_codec_info) {
+  tA2DP_LHDCV5_CIE cfg_cie;
+  /* Use a liberal check when parsing the codec info */
+  return (A2DP_ParseInfoLhdcV5(&cfg_cie, p_codec_info, false, IS_SRC) == A2DP_SUCCESS) ||
+      (A2DP_ParseInfoLhdcV5(&cfg_cie, p_codec_info, true, IS_SRC) == A2DP_SUCCESS);
+}
+bool A2DP_IsVendorSinkCodecValidLhdcV5(const uint8_t* p_codec_info) {
+  tA2DP_LHDCV5_CIE cfg_cie;
+  /* Use a liberal check when parsing the codec info */
+  return (A2DP_ParseInfoLhdcV5(&cfg_cie, p_codec_info, false, IS_SNK) == A2DP_SUCCESS) ||
+      (A2DP_ParseInfoLhdcV5(&cfg_cie, p_codec_info, true, IS_SNK) == A2DP_SUCCESS);
+}
+
+bool A2DP_IsVendorPeerSinkCodecValidLhdcV5(const uint8_t* p_codec_info) {
+  tA2DP_LHDCV5_CIE cfg_cie;
+  /* Use a liberal check when parsing the codec info */
+  return (A2DP_ParseInfoLhdcV5(&cfg_cie, p_codec_info, false, IS_SRC) == A2DP_SUCCESS) ||
+      (A2DP_ParseInfoLhdcV5(&cfg_cie, p_codec_info, true, IS_SRC) == A2DP_SUCCESS);
+}
+bool A2DP_IsVendorPeerSourceCodecValidLhdcV5(const uint8_t* p_codec_info) {
+  tA2DP_LHDCV5_CIE cfg_cie;
+  /* Use a liberal check when parsing the codec info */
+  return (A2DP_ParseInfoLhdcV5(&cfg_cie, p_codec_info, false, IS_SNK) == A2DP_SUCCESS) ||
+      (A2DP_ParseInfoLhdcV5(&cfg_cie, p_codec_info, true, IS_SNK) == A2DP_SUCCESS);
+}
+
+// NOTE: Should be done only for local Sink codec
+tA2DP_STATUS A2DP_IsVendorSinkCodecSupportedLhdcV5(const uint8_t* p_codec_info) {
+  return A2DP_CodecInfoMatchesCapabilityLhdcV5(&a2dp_lhdcv5_sink_caps, p_codec_info, false);
+}
+// NOTE: Should be done only for local Sink codec
+bool A2DP_IsPeerSourceCodecSupportedLhdcV5(const uint8_t* p_codec_info) {
+  return (A2DP_CodecInfoMatchesCapabilityLhdcV5(&a2dp_lhdcv5_sink_caps, p_codec_info,
+      true) == A2DP_SUCCESS);
+}
+
+// Checks whether A2DP LHDC codec configuration matches with a device's codec
+// capabilities.
+//  |p_cap| is the LHDC local codec capabilities.
+//  |p_codec_info| is peer's codec capabilities acting as an A2DP source.
+// If |is_capability| is true, the byte sequence is codec capabilities,
+// otherwise is codec configuration.
+// Returns A2DP_SUCCESS if the codec configuration matches with capabilities,
+// otherwise the corresponding A2DP error status code.
+static tA2DP_STATUS A2DP_CodecInfoMatchesCapabilityLhdcV5(
+    const tA2DP_LHDCV5_CIE* p_cap, const uint8_t* p_codec_info, bool is_capability) {
+  tA2DP_STATUS status;
+  tA2DP_LHDCV5_CIE cfg_cie;
+
+  if (p_cap == nullptr || p_codec_info == nullptr) {
+    log::error( ": nullptr input");
+    return A2DP_INVALID_CODEC_PARAMETER;
+  }
+
+  // parse configuration
+  status = A2DP_ParseInfoLhdcV5(&cfg_cie, p_codec_info, is_capability, IS_SNK);
+  if (status != A2DP_SUCCESS) {
+    log::error( ": parsing failed {}",  status);
+    return status;
+  }
+
+  // verify that each parameter is in range
+  log::info( ": FREQ peer: 0x{:02x}, capability 0x{:02x}",
+      cfg_cie.sampleRate, p_cap->sampleRate);
+
+  log::info( ": BIT_FMT peer: 0x{:02x}, capability 0x{:02x}",
+      cfg_cie.bitsPerSample, p_cap->bitsPerSample);
+
+  // sampling frequency
+  if ((cfg_cie.sampleRate & p_cap->sampleRate) == 0) return A2DP_NOT_SUPPORTED_SAMPLING_FREQUENCY;
+
+  // bits per sample
+  if ((cfg_cie.bitsPerSample & p_cap->bitsPerSample) == 0) return A2DP_NOT_SUPPORTED_BIT_RATE;
+
+  return A2DP_SUCCESS;
+}
+
+bool A2DP_VendorUsesRtpHeaderLhdcV5(UNUSED_ATTR bool content_protection_enabled,
+    UNUSED_ATTR const uint8_t* p_codec_info) {
+  // TODO: Is this correct? The RTP header is always included?
+  return true;
+}
+
+const char* A2DP_VendorCodecNameLhdcV5(UNUSED_ATTR const uint8_t* p_codec_info) {
+  return "LHDC V5";
+}
+
+bool A2DP_VendorCodecTypeEqualsLhdcV5(const uint8_t* p_codec_info_a,
+    const uint8_t* p_codec_info_b) {
+  tA2DP_LHDCV5_CIE lhdc_cie_a;
+  tA2DP_LHDCV5_CIE lhdc_cie_b;
+  tA2DP_STATUS a2dp_status;
+
+  if (p_codec_info_a == nullptr || p_codec_info_b == nullptr) {
+    log::error( ": nullptr input");
+    return false;
+  }
+
+  // Check whether the codec info contains valid data
+  a2dp_status =
+      A2DP_ParseInfoLhdcV5(&lhdc_cie_a, p_codec_info_a, true, IS_SRC);
+  if (a2dp_status != A2DP_SUCCESS) {
+    log::error( ": cannot decode codec information: {}", 
+        a2dp_status);
+    return false;
+  }
+  a2dp_status = A2DP_ParseInfoLhdcV5(&lhdc_cie_b, p_codec_info_b, true, IS_SRC);
+  if (a2dp_status != A2DP_SUCCESS) {
+    log::error( ": cannot decode codec information: {}", 
+        a2dp_status);
+    return false;
+  }
+
+  return true;
+}
+
+bool A2DP_VendorCodecEqualsLhdcV5(const uint8_t* p_codec_info_a,
+    const uint8_t* p_codec_info_b) {
+  tA2DP_LHDCV5_CIE lhdc_cie_a;
+  tA2DP_LHDCV5_CIE lhdc_cie_b;
+  tA2DP_STATUS a2dp_status;
+
+  if (p_codec_info_a == nullptr || p_codec_info_b == nullptr) {
+    log::error( ": nullptr input");
+    return false;
+  }
+
+  // Check whether the codec info contains valid data
+  a2dp_status =
+      A2DP_ParseInfoLhdcV5(&lhdc_cie_a, p_codec_info_a, true, IS_SRC);
+  if (a2dp_status != A2DP_SUCCESS) {
+    log::error( ": cannot decode codec information of a: {}", 
+        a2dp_status);
+    return false;
+  }
+  a2dp_status =
+      A2DP_ParseInfoLhdcV5(&lhdc_cie_b, p_codec_info_b, true, IS_SRC);
+  if (a2dp_status != A2DP_SUCCESS) {
+    log::error( ": cannot decode codec information of b: {}", 
+        a2dp_status);
+    return false;
+  }
+
+  // exam items that require to update codec config with peer if different
+  return (lhdc_cie_a.sampleRate == lhdc_cie_b.sampleRate) &&
+      (lhdc_cie_a.bitsPerSample == lhdc_cie_b.bitsPerSample) &&
+      (lhdc_cie_a.channelMode == lhdc_cie_b.channelMode) &&
+      (lhdc_cie_a.frameLenType == lhdc_cie_b.frameLenType) &&
+      (lhdc_cie_a.hasFeatureLL == lhdc_cie_b.hasFeatureLL) &&
+#ifdef LHDC_LOSSLESS_RAW_SUPPORT
+      (lhdc_cie_a.hasFeatureLLESS48K == lhdc_cie_b.hasFeatureLLESS48K &&
+      (lhdc_cie_a.hasFeatureLLESSRaw == lhdc_cie_b.hasFeatureLLESSRaw));
+#else
+      (lhdc_cie_a.hasFeatureLLESS48K == lhdc_cie_b.hasFeatureLLESS48K);
+#endif
+}
+
+int A2DP_VendorGetBitRateLhdcV5(UNUSED_ATTR const uint8_t* p_codec_info) {
+
+  A2dpCodecConfig* current_codec = bta_av_get_a2dp_current_codec();
+  btav_a2dp_codec_config_t codec_config_ = current_codec->getCodecConfig();
+  uint8_t bitRateIndex = 0;
+
+  if ((codec_config_.codec_specific_1 & A2DP_LHDC_VENDOR_CMD_MASK) ==
+      A2DP_LHDC_QUALITY_MAGIC_NUM) {
+    bitRateIndex = codec_config_.codec_specific_1 & A2DP_LHDC_QUALITY_MASK;
+    switch (bitRateIndex) {
+      case A2DP_LHDC_QUALITY_LOW0:
+        return 64000;
+      case A2DP_LHDC_QUALITY_LOW1:
+        return 160000;
+      case A2DP_LHDC_QUALITY_LOW2:
+        return 192000;
+      case A2DP_LHDC_QUALITY_LOW3:
+        return 256000;
+      case A2DP_LHDC_QUALITY_LOW4:
+        return 320000;
+      case A2DP_LHDC_QUALITY_LOW:
+        return 400000;
+      case A2DP_LHDC_QUALITY_MID:
+        return 500000;
+      case A2DP_LHDC_QUALITY_HIGH:
+        return 900000;
+      case A2DP_LHDC_QUALITY_HIGH1:
+        return 1000000;
+      case A2DP_LHDC_QUALITY_ABR:
+        return 9999999;
+      default:
+        log::info(": non-supported bitrate index ({})",  bitRateIndex);
+        return -1;
+    }
+  }
+  return 400000;
+}
+
+int A2DP_VendorGetTrackSampleRateLhdcV5(const uint8_t* p_codec_info) {
+  tA2DP_LHDCV5_CIE lhdc_cie;
+  tA2DP_STATUS a2dp_status;
+
+  if (p_codec_info == nullptr) {
+    log::error( ": nullptr input");
+    return -1;
+  }
+
+  // Check whether the codec info contains valid data
+  a2dp_status = A2DP_ParseInfoLhdcV5(&lhdc_cie, p_codec_info, false, IS_SRC);
+  if (a2dp_status != A2DP_SUCCESS) {
+    log::error( ": cannot decode codec information: {}", 
+        a2dp_status);
+    return -1;
+  }
+
+  switch (lhdc_cie.sampleRate) {
+  case A2DP_LHDCV5_SAMPLING_FREQ_44100:
+    return 44100;
+  case A2DP_LHDCV5_SAMPLING_FREQ_48000:
+    return 48000;
+  case A2DP_LHDCV5_SAMPLING_FREQ_96000:
+    return 96000;
+  case A2DP_LHDCV5_SAMPLING_FREQ_192000:
+    return 192000;
+  }
+
+  return -1;
+}
+
+int A2DP_VendorGetTrackBitsPerSampleLhdcV5(const uint8_t* p_codec_info) {
+  tA2DP_LHDCV5_CIE lhdc_cie;
+  tA2DP_STATUS a2dp_status;
+
+  if (p_codec_info == nullptr) {
+    log::error( ": nullptr input");
+    return -1;
+  }
+
+  // Check whether the codec info contains valid data
+  a2dp_status = A2DP_ParseInfoLhdcV5(&lhdc_cie, p_codec_info, false, IS_SRC);
+  if (a2dp_status != A2DP_SUCCESS) {
+    log::error( ": cannot decode codec information: {}", 
+        a2dp_status);
+    return -1;
+  }
+
+  switch (lhdc_cie.bitsPerSample) {
+  case A2DP_LHDCV5_BIT_FMT_16:
+    return 16;
+  case A2DP_LHDCV5_BIT_FMT_24:
+    return 24;
+  case A2DP_LHDCV5_BIT_FMT_32:
+    return 32;
+  }
+
+  return -1;
+}
+
+int A2DP_VendorGetTrackChannelCountLhdcV5(const uint8_t* p_codec_info) {
+  tA2DP_LHDCV5_CIE lhdc_cie;
+  tA2DP_STATUS a2dp_status;
+
+  if (p_codec_info == nullptr) {
+    log::error( ": nullptr input");
+    return -1;
+  }
+
+  // Check whether the codec info contains valid data
+  a2dp_status = A2DP_ParseInfoLhdcV5(&lhdc_cie, p_codec_info, false, IS_SRC);
+  if (a2dp_status != A2DP_SUCCESS) {
+    log::error( ": cannot decode codec information: {}", 
+        a2dp_status);
+    return -1;
+  }
+
+  switch (lhdc_cie.channelMode) {
+  case A2DP_LHDCV5_CHANNEL_MODE_MONO:
+    return 1;
+  case A2DP_LHDCV5_CHANNEL_MODE_DUAL:
+    return 2;
+  case A2DP_LHDCV5_CHANNEL_MODE_STEREO:
+    return 2;
+  }
+
+  return -1;
+}
+
+int A2DP_VendorGetSinkTrackChannelTypeLhdcV5(const uint8_t* p_codec_info) {
+  tA2DP_LHDCV5_CIE lhdc_cie;
+  tA2DP_STATUS a2dp_status;
+
+  if (p_codec_info == nullptr) {
+    log::error( ": nullptr input");
+    return -1;
+  }
+
+  // Check whether the codec info contains valid data
+  a2dp_status = A2DP_ParseInfoLhdcV5(&lhdc_cie, p_codec_info, false, IS_SNK);
+  if (a2dp_status != A2DP_SUCCESS) {
+    log::error( ": cannot decode codec information: {}", 
+        a2dp_status);
+    return -1;
+  }
+
+  switch (lhdc_cie.channelMode) {
+  case A2DP_LHDCV5_CHANNEL_MODE_MONO:
+    return 1;
+  case A2DP_LHDCV5_CHANNEL_MODE_DUAL:
+    return 3;
+  case A2DP_LHDCV5_CHANNEL_MODE_STEREO:
+    return 3;
+  }
+
+  return -1;
+}
+
+int A2DP_VendorGetChannelModeCodeLhdcV5(const uint8_t* p_codec_info) {
+  tA2DP_LHDCV5_CIE lhdc_cie;
+  tA2DP_STATUS a2dp_status;
+
+  if (p_codec_info == nullptr) {
+    log::error( ": nullptr input");
+    return -1;
+  }
+
+  // Check whether the codec info contains valid data
+  a2dp_status = A2DP_ParseInfoLhdcV5(&lhdc_cie, p_codec_info, false, IS_SRC);
+  if (a2dp_status != A2DP_SUCCESS) {
+    log::error( ": cannot decode codec information: {}", 
+        a2dp_status);
+    return -1;
+  }
+
+  switch (lhdc_cie.channelMode) {
+  case A2DP_LHDCV5_CHANNEL_MODE_MONO:
+  case A2DP_LHDCV5_CHANNEL_MODE_DUAL:
+  case A2DP_LHDCV5_CHANNEL_MODE_STEREO:
+    return lhdc_cie.channelMode;
+  default:
+    break;
+  }
+
+  return -1;
+}
+
+bool A2DP_VendorGetPacketTimestampLhdcV5(UNUSED_ATTR const uint8_t* p_codec_info,
+    const uint8_t* p_data,
+    uint32_t* p_timestamp) {
+  if (p_codec_info == nullptr || p_data == nullptr || p_timestamp == nullptr) {
+    log::error( ": nullptr input");
+    return false;
+  }
+
+  // TODO: Is this function really codec-specific?
+  *p_timestamp = *(const uint32_t*)p_data;
+  return true;
+}
+
+bool A2DP_VendorBuildCodecHeaderLhdcV5(UNUSED_ATTR const uint8_t* p_codec_info,
+    BT_HDR* p_buf,
+    uint16_t frames_per_packet) {
+  uint8_t* p;
+
+  if (p_codec_info == nullptr || p_buf == nullptr) {
+    log::error( ": nullptr input");
+    return false;
+  }
+
+  p_buf->offset -= A2DP_LHDC_MPL_HDR_LEN;
+  p = (uint8_t*)(p_buf + 1) + p_buf->offset;
+  p_buf->len += A2DP_LHDC_MPL_HDR_LEN;
+
+  // Not support fragmentation
+  p[0] = ( uint8_t)( frames_per_packet & 0xff);
+  p[1] = ( uint8_t)( ( frames_per_packet >> 8) & 0xff);
+
+  return true;
+}
+
+void A2DP_VendorDumpCodecInfoLhdcV5(const uint8_t* p_codec_info) {
+  tA2DP_STATUS a2dp_status;
+  tA2DP_LHDCV5_CIE lhdc_cie;
+
+  a2dp_status = A2DP_ParseInfoLhdcV5(&lhdc_cie, p_codec_info, true, IS_SRC);
+  if (a2dp_status != A2DP_SUCCESS) {
+    log::error( ": A2DP_ParseInfoLhdcV5 fail:{}",  a2dp_status);
+    return;
+  }
+
+  log::info( "\tsamp_freq: 0x{:02x} ", lhdc_cie.sampleRate);
+  if (lhdc_cie.sampleRate & A2DP_LHDCV5_SAMPLING_FREQ_44100) {
+    log::info( "\tsamp_freq: (44100)");
+  }
+  if (lhdc_cie.sampleRate & A2DP_LHDCV5_SAMPLING_FREQ_48000) {
+    log::info( "\tsamp_freq: (48000)");
+  }
+  if (lhdc_cie.sampleRate & A2DP_LHDCV5_SAMPLING_FREQ_96000) {
+    log::info( "\tsamp_freq: (96000)");
+  }
+  if (lhdc_cie.sampleRate & A2DP_LHDCV5_SAMPLING_FREQ_192000) {
+    log::info( "\tsamp_freq: (19200)");
+  }
+
+  log::info( "\tbitsPerSample: 0x{} ", lhdc_cie.bitsPerSample);
+  if (lhdc_cie.bitsPerSample & A2DP_LHDCV5_BIT_FMT_16) {
+    log::info( "\tbit_depth: (16)");
+  }
+  if (lhdc_cie.bitsPerSample & A2DP_LHDCV5_BIT_FMT_24) {
+    log::info( "\tbit_depth: (24)");
+  }
+  if (lhdc_cie.bitsPerSample & A2DP_LHDCV5_BIT_FMT_32) {
+    log::info( "\tbit_depth: (32)");
+  }
+
+  log::info( "\tchannelMode: 0x{:02x} ", lhdc_cie.channelMode);
+  if (lhdc_cie.channelMode & A2DP_LHDCV5_CHANNEL_MODE_MONO) {
+    log::info( "\tchannle_mode: (mono)");
+  }
+  if (lhdc_cie.channelMode & A2DP_LHDCV5_CHANNEL_MODE_DUAL) {
+    log::info( "\tchannle_mode: (dual)");
+  }
+  if (lhdc_cie.channelMode & A2DP_LHDCV5_CHANNEL_MODE_STEREO) {
+    log::info( "\tchannle_mode: (stereo)");
+  }
+}
+
+std::string A2DP_VendorCodecInfoStringLhdcV5(const uint8_t* p_codec_info) {
+  std::stringstream res;
+  std::string field;
+  tA2DP_STATUS a2dp_status;
+  tA2DP_LHDCV5_CIE lhdc_cie;
+
+  if (p_codec_info == nullptr) {
+    res << "A2DP_VendorCodecInfoStringLhdcV5 nullptr";
+    return res.str();
+  }
+
+  a2dp_status = A2DP_ParseInfoLhdcV5(&lhdc_cie, p_codec_info, true, IS_SRC);
+  if (a2dp_status != A2DP_SUCCESS) {
+    res << "A2DP_ParseInfoLhdcV5 fail: " << loghex(static_cast<uint8_t>(a2dp_status));
+    return res.str();
+  }
+
+  res << "\tname: LHDC V5\n";
+
+  // Sample frequency
+  field.clear();
+  AppendField(&field, (lhdc_cie.sampleRate == A2DP_LHDCV5_SAMPLING_FREQ_NS), "NONE");
+  AppendField(&field, (lhdc_cie.sampleRate & A2DP_LHDCV5_SAMPLING_FREQ_44100),
+      "44100");
+  AppendField(&field, (lhdc_cie.sampleRate & A2DP_LHDCV5_SAMPLING_FREQ_48000),
+      "48000");
+  AppendField(&field, (lhdc_cie.sampleRate & A2DP_LHDCV5_SAMPLING_FREQ_96000),
+      "96000");
+  AppendField(&field, (lhdc_cie.sampleRate & A2DP_LHDCV5_SAMPLING_FREQ_192000),
+      "192000");
+  res << "\tsamp_freq: " << field << " (" << loghex(lhdc_cie.sampleRate)
+                                                                      << ")\n";
+
+  // bits per sample
+  field.clear();
+  AppendField(&field, (lhdc_cie.bitsPerSample == A2DP_LHDCV5_BIT_FMT_NS), "NONE");
+  AppendField(&field, (lhdc_cie.bitsPerSample & A2DP_LHDCV5_BIT_FMT_16),
+      "16");
+  AppendField(&field, (lhdc_cie.bitsPerSample & A2DP_LHDCV5_BIT_FMT_24),
+      "24");
+  AppendField(&field, (lhdc_cie.bitsPerSample & A2DP_LHDCV5_BIT_FMT_32),
+      "24");
+  res << "\tbits_depth: " << field << " bits (" << loghex((int)lhdc_cie.bitsPerSample)
+                                                                      << ")\n";
+
+  // Channel mode
+  field.clear();
+  AppendField(&field, (lhdc_cie.channelMode == A2DP_LHDCV5_CHANNEL_MODE_NS), "NONE");
+  AppendField(&field, (lhdc_cie.channelMode & A2DP_LHDCV5_CHANNEL_MODE_MONO),
+      "Mono");
+  AppendField(&field, (lhdc_cie.channelMode & A2DP_LHDCV5_CHANNEL_MODE_DUAL),
+      "Dual");
+  AppendField(&field, (lhdc_cie.channelMode & A2DP_LHDCV5_CHANNEL_MODE_STEREO),
+      "Stereo");
+  res << "\tch_mode: " << field << " (" << loghex(lhdc_cie.channelMode)
+                                                                      << ")\n";
+
+  // Version
+  field.clear();
+  AppendField(&field, (lhdc_cie.version == A2DP_LHDCV5_VER_NS), "NONE");
+  AppendField(&field, (lhdc_cie.version == A2DP_LHDCV5_VER_1),
+      "LHDC V5 Ver1");
+  res << "\tversion: " << field << " (" << loghex(lhdc_cie.version)
+                                                                      << ")\n";
+
+  // Max target bit rate...
+  field.clear();
+  AppendField(&field, ((lhdc_cie.maxTargetBitrate & A2DP_LHDCV5_MAX_BIT_RATE_MASK) == A2DP_LHDCV5_MAX_BIT_RATE_1000K),
+      "1000Kbps");
+  AppendField(&field, ((lhdc_cie.maxTargetBitrate & A2DP_LHDCV5_MAX_BIT_RATE_MASK) == A2DP_LHDCV5_MAX_BIT_RATE_900K),
+      "900Kbps");
+  AppendField(&field, ((lhdc_cie.maxTargetBitrate & A2DP_LHDCV5_MAX_BIT_RATE_MASK) == A2DP_LHDCV5_MAX_BIT_RATE_500K),
+      "500Kbps");
+  AppendField(&field, ((lhdc_cie.maxTargetBitrate & A2DP_LHDCV5_MAX_BIT_RATE_MASK) == A2DP_LHDCV5_MAX_BIT_RATE_400K),
+      "400Kbps");
+  res << "\tMax target-rate: " << field << " (" << loghex((lhdc_cie.maxTargetBitrate & A2DP_LHDCV5_MAX_BIT_RATE_MASK))
+                                                                      << ")\n";
+
+  // Min target bit rate...
+  field.clear();
+  AppendField(&field, ((lhdc_cie.minTargetBitrate & A2DP_LHDCV5_MIN_BIT_RATE_MASK) == A2DP_LHDCV5_MIN_BIT_RATE_400K),
+      "400Kbps");
+  AppendField(&field, ((lhdc_cie.minTargetBitrate & A2DP_LHDCV5_MIN_BIT_RATE_MASK) == A2DP_LHDCV5_MIN_BIT_RATE_256K),
+      "256Kbps");
+  AppendField(&field, ((lhdc_cie.minTargetBitrate & A2DP_LHDCV5_MIN_BIT_RATE_MASK) == A2DP_LHDCV5_MIN_BIT_RATE_160K),
+      "160Kbps");
+  AppendField(&field, ((lhdc_cie.minTargetBitrate & A2DP_LHDCV5_MIN_BIT_RATE_MASK) == A2DP_LHDCV5_MIN_BIT_RATE_64K),
+      "64Kbps");
+  res << "\tMin target-rate: " << field << " (" << loghex((lhdc_cie.minTargetBitrate & A2DP_LHDCV5_MIN_BIT_RATE_MASK))
+                                                                      << ")\n";
+
+  return res.str();
+}
+
+const tA2DP_ENCODER_INTERFACE* A2DP_VendorGetEncoderInterfaceLhdcV5(
+    const uint8_t* p_codec_info) {
+  if (p_codec_info == nullptr) {
+    log::error( ": nullptr input");
+    return NULL;
+  }
+
+  if (!A2DP_IsVendorSourceCodecValidLhdcV5(p_codec_info)) return NULL;
+
+  return &a2dp_encoder_interface_lhdcv5;
+}
+
+const tA2DP_DECODER_INTERFACE* A2DP_VendorGetDecoderInterfaceLhdcV5(
+    const uint8_t* p_codec_info) {
+  if (p_codec_info == nullptr) {
+    log::error( ": nullptr input");
+    return NULL;
+  }
+
+  if (!A2DP_IsVendorSinkCodecValidLhdcV5(p_codec_info)) return NULL;
+
+  return &a2dp_decoder_interface_lhdcv5;
+}
+
+bool A2DP_VendorAdjustCodecLhdcV5(uint8_t* p_codec_info) {
+  tA2DP_LHDCV5_CIE cfg_cie;
+  if (p_codec_info == nullptr) {
+    log::error( ": nullptr input");
+    return false;
+  }
+
+  // Nothing to do: just verify the codec info is valid
+  if (A2DP_ParseInfoLhdcV5(&cfg_cie, p_codec_info, true, IS_SRC) != A2DP_SUCCESS)
+    return false;
+
+  return true;
+}
+
+btav_a2dp_codec_index_t A2DP_VendorSourceCodecIndexLhdcV5(
+    UNUSED_ATTR const uint8_t* p_codec_info) {
+  return BTAV_A2DP_CODEC_INDEX_SOURCE_LHDCV5;
+}
+
+btav_a2dp_codec_index_t A2DP_VendorSinkCodecIndexLhdcV5(
+    UNUSED_ATTR const uint8_t* p_codec_info) {
+  return BTAV_A2DP_CODEC_INDEX_SINK_LHDCV5;
+}
+
+const char* A2DP_VendorCodecIndexStrLhdcV5(void) { return "LHDC V5"; }
+
+const char* A2DP_VendorCodecIndexStrLhdcV5Sink(void) { return "LHDC V5 SINK"; }
+
+bool A2DP_VendorInitCodecConfigLhdcV5(AvdtpSepConfig* p_cfg) {
+  if (p_cfg == nullptr) {
+    log::error( ": nullptr input");
+    return false;
+  }
+
+  if (A2DP_BuildInfoLhdcV5(AVDT_MEDIA_TYPE_AUDIO, &a2dp_lhdcv5_source_caps,
+      p_cfg->codec_info) != A2DP_SUCCESS) {
+    return false;
+  }
+
+#if (BTA_AV_CO_CP_SCMS_T == TRUE)
+  /* Content protection info - support SCMS-T */
+  uint8_t* p = p_cfg->protect_info;
+  *p++ = AVDT_CP_LOSC;
+  UINT16_TO_STREAM(p, AVDT_CP_SCMS_T_ID);
+  p_cfg->num_protect = 1;
+#endif
+
+  return true;
+}
+
+bool A2DP_VendorInitCodecConfigLhdcV5Sink(AvdtpSepConfig* p_cfg) {
+  if (p_cfg == nullptr) {
+    log::error( ": nullptr input");
+    return false;
+  }
+
+  if (A2DP_BuildInfoLhdcV5(AVDT_MEDIA_TYPE_AUDIO, &a2dp_lhdcv5_sink_caps,
+      p_cfg->codec_info) != A2DP_SUCCESS) {
+    return false;
+  }
+
+  return true;
+}
+
+UNUSED_ATTR static void build_codec_config(const tA2DP_LHDCV5_CIE& config_cie,
+    btav_a2dp_codec_config_t* result) {
+  if (result == nullptr) {
+    log::error( ": nullptr input");
+    return;
+  }
+
+  // sample rate
+  result->sample_rate = BTAV_A2DP_CODEC_SAMPLE_RATE_NONE;
+  if (config_cie.sampleRate & A2DP_LHDCV5_SAMPLING_FREQ_44100)
+    result->sample_rate |= BTAV_A2DP_CODEC_SAMPLE_RATE_44100;
+  if (config_cie.sampleRate & A2DP_LHDCV5_SAMPLING_FREQ_48000)
+    result->sample_rate |= BTAV_A2DP_CODEC_SAMPLE_RATE_48000;
+  if (config_cie.sampleRate & A2DP_LHDCV5_SAMPLING_FREQ_96000)
+    result->sample_rate |= BTAV_A2DP_CODEC_SAMPLE_RATE_96000;
+  if (config_cie.sampleRate & A2DP_LHDCV5_SAMPLING_FREQ_192000)
+    result->sample_rate |= BTAV_A2DP_CODEC_SAMPLE_RATE_192000;
+
+  // bits per sample
+  result->bits_per_sample = BTAV_A2DP_CODEC_BITS_PER_SAMPLE_NONE;
+  if (config_cie.bitsPerSample & A2DP_LHDCV5_BIT_FMT_16)
+    result->bits_per_sample |= BTAV_A2DP_CODEC_BITS_PER_SAMPLE_16;
+  if (config_cie.bitsPerSample & A2DP_LHDCV5_BIT_FMT_24)
+    result->bits_per_sample |= BTAV_A2DP_CODEC_BITS_PER_SAMPLE_24;
+  if (config_cie.bitsPerSample & A2DP_LHDCV5_BIT_FMT_32)
+    result->bits_per_sample |= BTAV_A2DP_CODEC_BITS_PER_SAMPLE_32;
+
+  // channel mode
+  result->channel_mode = BTAV_A2DP_CODEC_CHANNEL_MODE_NONE;
+  if (config_cie.channelMode & A2DP_LHDCV5_CHANNEL_MODE_MONO)
+    result->channel_mode |= BTAV_A2DP_CODEC_CHANNEL_MODE_MONO;
+  if (config_cie.channelMode &
+      (A2DP_LHDCV5_CHANNEL_MODE_DUAL | A2DP_LHDCV5_CHANNEL_MODE_STEREO)) {
+    result->channel_mode |= BTAV_A2DP_CODEC_CHANNEL_MODE_STEREO;
+  }
+}
+
+A2dpCodecConfigLhdcV5Source::A2dpCodecConfigLhdcV5Source(
+    btav_a2dp_codec_priority_t codec_priority)
+: A2dpCodecConfigLhdcV5Base(BTAV_A2DP_CODEC_INDEX_SOURCE_LHDCV5,
+    A2DP_VendorCodecIndexStrLhdcV5(),
+    codec_priority, true) {
+
+  // Compute the local capability
+  codec_local_capability_.sample_rate = BTAV_A2DP_CODEC_SAMPLE_RATE_NONE;
+  if (a2dp_lhdcv5_source_caps.sampleRate & A2DP_LHDCV5_SAMPLING_FREQ_44100) {
+    codec_local_capability_.sample_rate |= BTAV_A2DP_CODEC_SAMPLE_RATE_44100;
+  }
+  if (a2dp_lhdcv5_source_caps.sampleRate & A2DP_LHDCV5_SAMPLING_FREQ_48000) {
+    codec_local_capability_.sample_rate |= BTAV_A2DP_CODEC_SAMPLE_RATE_48000;
+  }
+  if (a2dp_lhdcv5_source_caps.sampleRate & A2DP_LHDCV5_SAMPLING_FREQ_96000) {
+    codec_local_capability_.sample_rate |= BTAV_A2DP_CODEC_SAMPLE_RATE_96000;
+  }
+  if (a2dp_lhdcv5_source_caps.sampleRate & A2DP_LHDCV5_SAMPLING_FREQ_192000) {
+    codec_local_capability_.sample_rate |= BTAV_A2DP_CODEC_SAMPLE_RATE_192000;
+  }
+
+  codec_local_capability_.bits_per_sample = BTAV_A2DP_CODEC_BITS_PER_SAMPLE_NONE;
+  if (a2dp_lhdcv5_source_caps.bitsPerSample & A2DP_LHDCV5_BIT_FMT_16) {
+    codec_local_capability_.bits_per_sample |= BTAV_A2DP_CODEC_BITS_PER_SAMPLE_16;
+  }
+  if (a2dp_lhdcv5_source_caps.bitsPerSample & A2DP_LHDCV5_BIT_FMT_24) {
+    codec_local_capability_.bits_per_sample |= BTAV_A2DP_CODEC_BITS_PER_SAMPLE_24;
+  }
+  if (a2dp_lhdcv5_source_caps.bitsPerSample & A2DP_LHDCV5_BIT_FMT_32) {
+    codec_local_capability_.bits_per_sample |= BTAV_A2DP_CODEC_BITS_PER_SAMPLE_32;
+  }
+
+  codec_local_capability_.channel_mode = BTAV_A2DP_CODEC_CHANNEL_MODE_NONE;
+  if (a2dp_lhdcv5_source_caps.channelMode & A2DP_LHDCV5_CHANNEL_MODE_MONO) {
+    codec_local_capability_.channel_mode |= BTAV_A2DP_CODEC_CHANNEL_MODE_MONO;
+  }
+  if (a2dp_lhdcv5_source_caps.channelMode & A2DP_LHDCV5_CHANNEL_MODE_DUAL) {
+    codec_local_capability_.channel_mode |= BTAV_A2DP_CODEC_CHANNEL_MODE_STEREO;
+  }
+  if (a2dp_lhdcv5_source_caps.channelMode & A2DP_LHDCV5_CHANNEL_MODE_STEREO) {
+    codec_local_capability_.channel_mode |= BTAV_A2DP_CODEC_CHANNEL_MODE_STEREO;
+  }
+}
+
+A2dpCodecConfigLhdcV5Source::~A2dpCodecConfigLhdcV5Source() {}
+
+bool A2dpCodecConfigLhdcV5Source::init() {
+  // Load the encoder
+  if (!A2DP_VendorLoadEncoderLhdcV5()) {
+    log::error( ": cannot load the encoder");
+    return false;
+  }
+
+  return true;
+}
+
+bool A2dpCodecConfigLhdcV5Source::useRtpHeaderMarkerBit() const { return false; }
+
+//
+// Selects the best sample rate from |sampleRate|.
+// The result is stored in |p_result| and |p_codec_config|.
+// Returns true if a selection was made, otherwise false.
+//
+static bool select_best_sample_rate(uint8_t sampleRate,
+    tA2DP_LHDCV5_CIE* p_result,
+    btav_a2dp_codec_config_t* p_codec_config) {
+  if (p_codec_config == nullptr || p_result == nullptr) {
+    log::error( ": nullptr input");
+    return false;
+  }
+
+  // LHDC V5 priority: 48K > 44.1K > 96K > 192K > others(min to max)
+  if (sampleRate & A2DP_LHDCV5_SAMPLING_FREQ_48000) {
+    p_result->sampleRate = A2DP_LHDCV5_SAMPLING_FREQ_48000;
+    p_codec_config->sample_rate = BTAV_A2DP_CODEC_SAMPLE_RATE_48000;
+    return true;
+  }
+  if (sampleRate & A2DP_LHDCV5_SAMPLING_FREQ_44100) {
+    p_result->sampleRate = A2DP_LHDCV5_SAMPLING_FREQ_44100;
+    p_codec_config->sample_rate = BTAV_A2DP_CODEC_SAMPLE_RATE_44100;
+    return true;
+  }
+  if (sampleRate & A2DP_LHDCV5_SAMPLING_FREQ_96000) {
+    p_result->sampleRate = A2DP_LHDCV5_SAMPLING_FREQ_96000;
+    p_codec_config->sample_rate = BTAV_A2DP_CODEC_SAMPLE_RATE_96000;
+    return true;
+  }
+  if (sampleRate & A2DP_LHDCV5_SAMPLING_FREQ_192000) {
+    p_result->sampleRate = A2DP_LHDCV5_SAMPLING_FREQ_192000;
+    p_codec_config->sample_rate = BTAV_A2DP_CODEC_SAMPLE_RATE_192000;
+    return true;
+  }
+  return false;
+}
+
+//
+// Selects the audio sample rate from |p_codec_audio_config|.
+// |sampleRate| contains the capability.
+// The result is stored in |p_result| and |p_codec_config|.
+// Returns true if a selection was made, otherwise false.
+//
+static bool select_audio_sample_rate(
+    const btav_a2dp_codec_config_t* p_codec_audio_config, uint8_t sampleRate,
+    tA2DP_LHDCV5_CIE* p_result, btav_a2dp_codec_config_t* p_codec_config) {
+  if (p_codec_audio_config == nullptr || p_result == nullptr || p_codec_config == nullptr) {
+    log::error( ": nullptr input");
+    return false;
+  }
+
+  // LHDC V5 priority: 48K > 44.1K > 96K > 192K > others(min to max)
+  switch (p_codec_audio_config->sample_rate) {
+  case BTAV_A2DP_CODEC_SAMPLE_RATE_48000:
+    if (sampleRate & A2DP_LHDCV5_SAMPLING_FREQ_48000) {
+      p_result->sampleRate = A2DP_LHDCV5_SAMPLING_FREQ_48000;
+      p_codec_config->sample_rate = BTAV_A2DP_CODEC_SAMPLE_RATE_48000;
+      return true;
+    }
+    break;
+  case BTAV_A2DP_CODEC_SAMPLE_RATE_44100:
+    if (sampleRate & A2DP_LHDCV5_SAMPLING_FREQ_44100) {
+      p_result->sampleRate = A2DP_LHDCV5_SAMPLING_FREQ_44100;
+      p_codec_config->sample_rate = BTAV_A2DP_CODEC_SAMPLE_RATE_44100;
+      return true;
+    }
+    break;
+  case BTAV_A2DP_CODEC_SAMPLE_RATE_96000:
+    if (sampleRate & A2DP_LHDCV5_SAMPLING_FREQ_96000) {
+      p_result->sampleRate = A2DP_LHDCV5_SAMPLING_FREQ_96000;
+      p_codec_config->sample_rate = BTAV_A2DP_CODEC_SAMPLE_RATE_96000;
+      return true;
+    }
+    break;
+  case BTAV_A2DP_CODEC_SAMPLE_RATE_192000:
+    if (sampleRate & A2DP_LHDCV5_SAMPLING_FREQ_192000) {
+      p_result->sampleRate = A2DP_LHDCV5_SAMPLING_FREQ_192000;
+      p_codec_config->sample_rate = BTAV_A2DP_CODEC_SAMPLE_RATE_192000;
+      return true;
+    }
+    break;
+  case BTAV_A2DP_CODEC_SAMPLE_RATE_16000:
+  case BTAV_A2DP_CODEC_SAMPLE_RATE_24000:
+  case BTAV_A2DP_CODEC_SAMPLE_RATE_176400:
+  case BTAV_A2DP_CODEC_SAMPLE_RATE_88200:
+  case BTAV_A2DP_CODEC_SAMPLE_RATE_NONE:
+    break;
+  }
+  return false;
+}
+
+//
+// Selects the best bits per sample from |bitsPerSample|.
+// |bitsPerSample| contains the capability.
+// The result is stored in |p_result| and |p_codec_config|.
+// Returns true if a selection was made, otherwise false.
+//
+static bool select_best_bits_per_sample(
+    uint8_t bitsPerSample, tA2DP_LHDCV5_CIE* p_result,
+    btav_a2dp_codec_config_t* p_codec_config) {
+
+  if (p_result == nullptr || p_codec_config == nullptr) {
+    log::error( ": nullptr input");
+    return false;
+  }
+
+  // LHDC V5 priority: 24 > 16 > 32
+  if (bitsPerSample & A2DP_LHDCV5_BIT_FMT_24) {
+    p_codec_config->bits_per_sample = BTAV_A2DP_CODEC_BITS_PER_SAMPLE_24;
+    p_result->bitsPerSample = A2DP_LHDCV5_BIT_FMT_24;
+    return true;
+  }
+  if (bitsPerSample & A2DP_LHDCV5_BIT_FMT_16) {
+    p_codec_config->bits_per_sample = BTAV_A2DP_CODEC_BITS_PER_SAMPLE_16;
+    p_result->bitsPerSample = A2DP_LHDCV5_BIT_FMT_16;
+    return true;
+  }
+  if (bitsPerSample & A2DP_LHDCV5_BIT_FMT_32) {
+    p_codec_config->bits_per_sample = BTAV_A2DP_CODEC_BITS_PER_SAMPLE_32;
+    p_result->bitsPerSample = A2DP_LHDCV5_BIT_FMT_32;
+    return true;
+  }
+  return false;
+}
+
+//
+// Selects the audio bits per sample from |p_codec_audio_config|.
+// |bitsPerSample| contains the capability.
+// The result is stored in |p_result| and |p_codec_config|.
+// Returns true if a selection was made, otherwise false.
+//
+static bool select_audio_bits_per_sample(
+    const btav_a2dp_codec_config_t* p_codec_audio_config,
+    uint8_t bitsPerSample, tA2DP_LHDCV5_CIE* p_result,
+    btav_a2dp_codec_config_t* p_codec_config) {
+
+  if (p_codec_audio_config == nullptr || p_result == nullptr || p_codec_config == nullptr) {
+    log::error( ": nullptr input");
+    return false;
+  }
+
+  // LHDC V5 priority: 24 > 16 > 32
+  switch (p_codec_audio_config->bits_per_sample) {
+  case BTAV_A2DP_CODEC_BITS_PER_SAMPLE_24:
+    if (bitsPerSample & A2DP_LHDCV5_BIT_FMT_24) {
+      p_codec_config->bits_per_sample = BTAV_A2DP_CODEC_BITS_PER_SAMPLE_24;
+      p_result->bitsPerSample = A2DP_LHDCV5_BIT_FMT_24;
+      return true;
+    }
+    break;
+  case BTAV_A2DP_CODEC_BITS_PER_SAMPLE_16:
+    if (bitsPerSample & A2DP_LHDCV5_BIT_FMT_16) {
+      p_codec_config->bits_per_sample = BTAV_A2DP_CODEC_BITS_PER_SAMPLE_16;
+      p_result->bitsPerSample = A2DP_LHDCV5_BIT_FMT_16;
+      return true;
+    }
+    break;
+  case BTAV_A2DP_CODEC_BITS_PER_SAMPLE_32:
+    if (bitsPerSample & A2DP_LHDCV5_BIT_FMT_32) {
+      p_codec_config->bits_per_sample = BTAV_A2DP_CODEC_BITS_PER_SAMPLE_32;
+      p_result->bitsPerSample = A2DP_LHDCV5_BIT_FMT_32;
+      return true;
+    }
+    break;
+  case BTAV_A2DP_CODEC_BITS_PER_SAMPLE_NONE:
+    break;
+  }
+  return false;
+}
+
+static bool A2DP_MaxBitRatetoQualityLevelLhdcV5(uint8_t *mode, uint8_t bitrate) {
+  if (mode == nullptr) {
+    log::error( ": nullptr input");
+    return false;
+  }
+
+  switch (bitrate & A2DP_LHDCV5_MAX_BIT_RATE_MASK) {
+  case A2DP_LHDCV5_MAX_BIT_RATE_1000K:
+    *mode = A2DP_LHDC_QUALITY_HIGH1;
+    return true;
+  case A2DP_LHDCV5_MAX_BIT_RATE_900K:
+    *mode = A2DP_LHDC_QUALITY_HIGH;
+    return true;
+  case A2DP_LHDCV5_MAX_BIT_RATE_500K:
+    *mode = A2DP_LHDC_QUALITY_MID;
+    return true;
+  case A2DP_LHDCV5_MAX_BIT_RATE_400K:
+    *mode = A2DP_LHDC_QUALITY_LOW;
+    return true;
+  }
+  return false;
+}
+
+static bool A2DP_MinBitRatetoQualityLevelLhdcV5(uint8_t *mode, uint8_t bitrate) {
+  if (mode == nullptr) {
+    log::error( ": nullptr input");
+    return false;
+  }
+
+  switch (bitrate & A2DP_LHDCV5_MIN_BIT_RATE_MASK) {
+  case A2DP_LHDCV5_MIN_BIT_RATE_400K:
+    *mode = A2DP_LHDC_QUALITY_LOW;
+    return true;
+  case A2DP_LHDCV5_MIN_BIT_RATE_256K:
+    *mode = A2DP_LHDC_QUALITY_LOW3;
+    return true;
+  case A2DP_LHDCV5_MIN_BIT_RATE_160K:
+    *mode = A2DP_LHDC_QUALITY_LOW1;
+    return true;
+  case A2DP_LHDCV5_MIN_BIT_RATE_64K:
+    *mode = A2DP_LHDC_QUALITY_LOW0;
+    return true;
+  }
+  return false;
+}
+
+static std::string lhdcV5_sampleRate_toString(uint8_t value) {
+  switch((int)value)
+  {
+  case A2DP_LHDCV5_SAMPLING_FREQ_44100:
+    return "44.1 KHz";
+  case A2DP_LHDCV5_SAMPLING_FREQ_48000:
+    return "48 KHz";
+  case A2DP_LHDCV5_SAMPLING_FREQ_96000:
+    return "96 KHz";
+  case A2DP_LHDCV5_SAMPLING_FREQ_192000:
+    return "192 KHz";
+  default:
+    return "Unknown Sample Rate";
+  }
+}
+
+static std::string lhdcV5_bitPerSample_toString(uint8_t value) {
+  switch((int)value)
+  {
+  case A2DP_LHDCV5_BIT_FMT_16:
+    return "16";
+  case A2DP_LHDCV5_BIT_FMT_24:
+    return "24";
+  case A2DP_LHDCV5_BIT_FMT_32:
+    return "32";
+  default:
+    return "Unknown Bit Per Sample";
+  }
+}
+
+static std::string lhdcV5_frameLenType_toString(uint8_t value) {
+  switch((int)value)
+  {
+  case A2DP_LHDCV5_FRAME_LEN_5MS:
+    return "5ms";
+  default:
+    return "Unknown frame length type";
+  }
+}
+
+static std::string lhdcV5_MaxTargetBitRate_toString(uint8_t value) {
+  switch((int)value)
+  {
+  case A2DP_LHDCV5_MAX_BIT_RATE_900K:
+    return "900Kbps";
+  case A2DP_LHDCV5_MAX_BIT_RATE_500K:
+    return "500Kbps";
+  case A2DP_LHDCV5_MAX_BIT_RATE_400K:
+    return "400Kbps";
+  case A2DP_LHDCV5_MAX_BIT_RATE_1000K:
+    return "1000Kbps";
+  default:
+    return "Unknown Max Bit Rate";
+  }
+}
+
+static std::string lhdcV5_MinTargetBitRate_toString(uint8_t value) {
+  switch((int)value)
+  {
+  case A2DP_LHDCV5_MIN_BIT_RATE_400K:
+    return "400Kbps";
+  case A2DP_LHDCV5_MIN_BIT_RATE_256K:
+    return "256Kbps";
+  case A2DP_LHDCV5_MIN_BIT_RATE_160K:
+    return "160Kbps";
+  case A2DP_LHDCV5_MIN_BIT_RATE_64K:
+    return "64Kbps";
+  default:
+    return "Unknown Min Bit Rate";
+  }
+}
+
+static std::string lhdcV5_QualityModeBitRate_toString(uint8_t value) {
+  switch((int)value)
+  {
+  case A2DP_LHDC_QUALITY_ABR:
+    return "ABR";
+  case A2DP_LHDC_QUALITY_HIGH1:
+    return "HIGH 1 (1000 Kbps)";
+  case A2DP_LHDC_QUALITY_HIGH:
+    return "HIGH (900 Kbps)";
+  case A2DP_LHDC_QUALITY_MID:
+    return "MID (500 Kbps)";
+  case A2DP_LHDC_QUALITY_LOW:
+    return "LOW (400 Kbps)";
+  case A2DP_LHDC_QUALITY_LOW4:
+    return "LOW 4 (320 Kbps)";
+  case A2DP_LHDC_QUALITY_LOW3:
+    return "LOW 3 (256 Kbps)";
+  case A2DP_LHDC_QUALITY_LOW2:
+    return "LOW 2 (192 Kbps)";
+  case A2DP_LHDC_QUALITY_LOW1:
+    return "LOW 1 (160 Kbps)";
+  case A2DP_LHDC_QUALITY_LOW0:
+    return "LOW 0 (64 Kbps)";
+  default:
+    return "Unknown Bit Rate Mode";
+  }
+}
+
+
+tA2DP_STATUS A2dpCodecConfigLhdcV5Base::setCodecConfig(const uint8_t* p_peer_codec_info,
+    bool is_capability,
+    uint8_t* p_result_codec_config) {
+  std::lock_guard<std::recursive_mutex> lock(codec_mutex_);
+  tA2DP_LHDCV5_CIE sink_info_cie;
+  tA2DP_LHDCV5_CIE result_config_cie;
+  uint8_t sampleRate = 0;
+  uint8_t bitsPerSample = 0;
+  bool hasFeature = false;
+  bool hasUserSet = false;
+  uint8_t qualityMode = 0;
+  uint8_t bitRateQmode = 0;
+  tA2DP_STATUS status;
+
+  const tA2DP_LHDCV5_CIE* p_a2dp_lhdcv5_caps =
+      (is_source_) ? &a2dp_lhdcv5_source_caps : &a2dp_lhdcv5_sink_caps;
+
+  // Save the internal state
+  btav_a2dp_codec_config_t saved_codec_config = codec_config_;
+  btav_a2dp_codec_config_t saved_codec_capability = codec_capability_;
+  btav_a2dp_codec_config_t saved_codec_selectable_capability =
+      codec_selectable_capability_;
+  btav_a2dp_codec_config_t saved_codec_user_config = codec_user_config_;
+  btav_a2dp_codec_config_t saved_codec_audio_config = codec_audio_config_;
+  uint8_t saved_ota_codec_config[AVDT_CODEC_SIZE];
+  uint8_t saved_ota_codec_peer_capability[AVDT_CODEC_SIZE];
+  uint8_t saved_ota_codec_peer_config[AVDT_CODEC_SIZE];
+  memcpy(saved_ota_codec_config, ota_codec_config_, sizeof(ota_codec_config_));
+  memcpy(saved_ota_codec_peer_capability, ota_codec_peer_capability_,
+      sizeof(ota_codec_peer_capability_));
+  memcpy(saved_ota_codec_peer_config, ota_codec_peer_config_,
+      sizeof(ota_codec_peer_config_));
+
+  tA2DP_CODEC_CONFIGS_PACK allCfgPack;
+  allCfgPack._codec_config_ = &codec_config_;
+  allCfgPack._codec_capability_ = &codec_capability_;
+  allCfgPack._codec_local_capability_ = &codec_local_capability_;
+  allCfgPack._codec_selectable_capability_ = &codec_selectable_capability_;
+  allCfgPack._codec_user_config_ = &codec_user_config_;
+  allCfgPack._codec_audio_config_ = &codec_audio_config_;
+
+  if (p_peer_codec_info == nullptr || p_result_codec_config == nullptr) {
+    log::error( ": nullptr input");
+    status = AVDTP_UNSUPPORTED_CONFIGURATION;
+    goto fail;
+  }
+
+  status = A2DP_ParseInfoLhdcV5(&sink_info_cie, p_peer_codec_info, is_capability, IS_SRC);
+  if (status != A2DP_SUCCESS) {
+    log::error( ": can't parse peer's Sink capabilities: error = {}",
+         status);
+    goto fail;
+  }
+
+  //
+  // Build the preferred configuration
+  //
+  memset(&result_config_cie, 0, sizeof(result_config_cie));
+  result_config_cie.vendorId = p_a2dp_lhdcv5_caps->vendorId;
+  result_config_cie.codecId = p_a2dp_lhdcv5_caps->codecId;
+  result_config_cie.version = sink_info_cie.version;
+
+  //
+  // Select the sample frequency
+  //
+  sampleRate = p_a2dp_lhdcv5_caps->sampleRate & sink_info_cie.sampleRate;
+  log::info( ": sampleRate:peer:0x{:02x} local:0x{:02x} cap:0x{:02x} user:0x{:02x}",
+       sink_info_cie.sampleRate, p_a2dp_lhdcv5_caps->sampleRate,
+      sampleRate, codec_user_config_.sample_rate);
+
+  codec_config_.sample_rate = BTAV_A2DP_CODEC_SAMPLE_RATE_NONE;
+  switch (codec_user_config_.sample_rate) {
+  case BTAV_A2DP_CODEC_SAMPLE_RATE_44100:
+    if (sampleRate & A2DP_LHDCV5_SAMPLING_FREQ_44100) {
+      result_config_cie.sampleRate = A2DP_LHDCV5_SAMPLING_FREQ_44100;
+      codec_capability_.sample_rate = codec_user_config_.sample_rate;
+      codec_config_.sample_rate = codec_user_config_.sample_rate;
+    }
+    break;
+  case BTAV_A2DP_CODEC_SAMPLE_RATE_48000:
+    if (sampleRate & A2DP_LHDCV5_SAMPLING_FREQ_48000) {
+      result_config_cie.sampleRate = A2DP_LHDCV5_SAMPLING_FREQ_48000;
+      codec_capability_.sample_rate = codec_user_config_.sample_rate;
+      codec_config_.sample_rate = codec_user_config_.sample_rate;
+    }
+    break;
+  case BTAV_A2DP_CODEC_SAMPLE_RATE_96000:
+    if (sampleRate & A2DP_LHDCV5_SAMPLING_FREQ_96000) {
+      result_config_cie.sampleRate = A2DP_LHDCV5_SAMPLING_FREQ_96000;
+      codec_capability_.sample_rate = codec_user_config_.sample_rate;
+      codec_config_.sample_rate = codec_user_config_.sample_rate;
+    }
+    break;
+  case BTAV_A2DP_CODEC_SAMPLE_RATE_192000:
+    if (sampleRate & A2DP_LHDCV5_SAMPLING_FREQ_192000) {
+      result_config_cie.sampleRate = A2DP_LHDCV5_SAMPLING_FREQ_192000;
+      codec_capability_.sample_rate = codec_user_config_.sample_rate;
+      codec_config_.sample_rate = codec_user_config_.sample_rate;
+    }
+    break;
+  case BTAV_A2DP_CODEC_SAMPLE_RATE_16000:
+  case BTAV_A2DP_CODEC_SAMPLE_RATE_24000:
+  case BTAV_A2DP_CODEC_SAMPLE_RATE_88200:
+  case BTAV_A2DP_CODEC_SAMPLE_RATE_176400:
+  case BTAV_A2DP_CODEC_SAMPLE_RATE_NONE:
+    codec_capability_.sample_rate = BTAV_A2DP_CODEC_SAMPLE_RATE_NONE;
+    codec_config_.sample_rate = BTAV_A2DP_CODEC_SAMPLE_RATE_NONE;
+    break;
+  }
+
+  // Select the sample frequency if there is no user preference
+  do {
+    // Compute the selectable capability
+    if (sampleRate & A2DP_LHDCV5_SAMPLING_FREQ_44100)
+      codec_selectable_capability_.sample_rate |= BTAV_A2DP_CODEC_SAMPLE_RATE_44100;
+    if (sampleRate & A2DP_LHDCV5_SAMPLING_FREQ_48000)
+      codec_selectable_capability_.sample_rate |= BTAV_A2DP_CODEC_SAMPLE_RATE_48000;
+    if (sampleRate & A2DP_LHDCV5_SAMPLING_FREQ_96000)
+      codec_selectable_capability_.sample_rate |= BTAV_A2DP_CODEC_SAMPLE_RATE_96000;
+    if (sampleRate & A2DP_LHDCV5_SAMPLING_FREQ_192000)
+      codec_selectable_capability_.sample_rate |= BTAV_A2DP_CODEC_SAMPLE_RATE_192000;
+
+    if (codec_config_.sample_rate != BTAV_A2DP_CODEC_SAMPLE_RATE_NONE) {
+      log::info( ": sample rate configured by UI successfully 0x{:02x}",
+           result_config_cie.sampleRate);
+      break;
+    }
+    // Ignore follows if codec config is setup, otherwise pick a best one from default rules
+
+    // Compute the common capability
+    if (sampleRate & A2DP_LHDCV5_SAMPLING_FREQ_44100)
+      codec_capability_.sample_rate |= BTAV_A2DP_CODEC_SAMPLE_RATE_44100;
+    if (sampleRate & A2DP_LHDCV5_SAMPLING_FREQ_48000)
+      codec_capability_.sample_rate |= BTAV_A2DP_CODEC_SAMPLE_RATE_48000;
+    if (sampleRate & A2DP_LHDCV5_SAMPLING_FREQ_96000)
+      codec_capability_.sample_rate |= BTAV_A2DP_CODEC_SAMPLE_RATE_96000;
+    if (sampleRate & A2DP_LHDCV5_SAMPLING_FREQ_192000)
+      codec_capability_.sample_rate |= BTAV_A2DP_CODEC_SAMPLE_RATE_192000;
+
+    // No user preference - try the codec audio config
+    if (select_audio_sample_rate(&codec_audio_config_, sampleRate,
+        &result_config_cie, &codec_config_)) {
+      log::info( ": select sample rate from audio: 0x{:02x}",
+          result_config_cie.sampleRate);
+      break;
+    }
+
+    // No user preference - try the default config
+    if (select_best_sample_rate(
+        a2dp_lhdcv5_source_default_caps.sampleRate & sink_info_cie.sampleRate,
+        &result_config_cie, &codec_config_)) {
+      log::info( ": select sample rate from default: 0x{:02x}",
+          result_config_cie.sampleRate);
+      break;
+    }
+
+    // No user preference - use the best match
+    if (select_best_sample_rate(sampleRate, &result_config_cie,
+        &codec_config_)) {
+      log::info( ": select sample rate from best match: 0x{:02x}",
+          result_config_cie.sampleRate);
+      break;
+    }
+  } while (false);
+
+  if (codec_config_.sample_rate == BTAV_A2DP_CODEC_SAMPLE_RATE_NONE) {
+    log::error(
+        ": cannot match sample frequency: local caps = 0x{:02x} "
+        "peer info = 0x{:02x}",
+         p_a2dp_lhdcv5_caps->sampleRate, sink_info_cie.sampleRate);
+    goto fail;
+  }
+  codec_user_config_.sample_rate = codec_config_.sample_rate;
+  log::info( ": => sample rate(0x{:02x}) = {}",
+      result_config_cie.sampleRate,
+      lhdcV5_sampleRate_toString(result_config_cie.sampleRate).c_str());
+
+  //
+  // Select the bits per sample
+  //
+  bitsPerSample = p_a2dp_lhdcv5_caps->bitsPerSample & sink_info_cie.bitsPerSample;
+  log::info( ": bitsPerSample:peer:0x{:02x} local:0x{:02x} cap:0x{:02x} user:0x{:02x}",
+       sink_info_cie.bitsPerSample, p_a2dp_lhdcv5_caps->bitsPerSample,
+      bitsPerSample, codec_user_config_.bits_per_sample);
+
+  codec_config_.bits_per_sample = BTAV_A2DP_CODEC_BITS_PER_SAMPLE_NONE;
+  switch (codec_user_config_.bits_per_sample) {
+  case BTAV_A2DP_CODEC_BITS_PER_SAMPLE_16:
+    if (bitsPerSample & A2DP_LHDCV5_BIT_FMT_16) {
+      result_config_cie.bitsPerSample = A2DP_LHDCV5_BIT_FMT_16;
+      codec_capability_.bits_per_sample = codec_user_config_.bits_per_sample;
+      codec_config_.bits_per_sample = codec_user_config_.bits_per_sample;
+    }
+    break;
+  case BTAV_A2DP_CODEC_BITS_PER_SAMPLE_24:
+    if (bitsPerSample & A2DP_LHDCV5_BIT_FMT_24) {
+      result_config_cie.bitsPerSample = A2DP_LHDCV5_BIT_FMT_24;
+      codec_capability_.bits_per_sample = codec_user_config_.bits_per_sample;
+      codec_config_.bits_per_sample = codec_user_config_.bits_per_sample;
+    }
+    break;
+  case BTAV_A2DP_CODEC_BITS_PER_SAMPLE_32:
+    if (bitsPerSample & A2DP_LHDCV5_BIT_FMT_32) {
+      result_config_cie.bitsPerSample = A2DP_LHDCV5_BIT_FMT_32;
+      codec_capability_.bits_per_sample = codec_user_config_.bits_per_sample;
+      codec_config_.bits_per_sample = codec_user_config_.bits_per_sample;
+    }
+    break;
+  case BTAV_A2DP_CODEC_BITS_PER_SAMPLE_NONE:
+    result_config_cie.bitsPerSample = A2DP_LHDCV5_BIT_FMT_NS;
+    codec_capability_.bits_per_sample = BTAV_A2DP_CODEC_BITS_PER_SAMPLE_NONE;
+    codec_config_.bits_per_sample = BTAV_A2DP_CODEC_BITS_PER_SAMPLE_NONE;
+    break;
+  }
+
+  // Select the bits per sample if there is no user preference
+  do {
+    // Compute the selectable capability
+    if (bitsPerSample & A2DP_LHDCV5_BIT_FMT_16)
+      codec_selectable_capability_.bits_per_sample |= BTAV_A2DP_CODEC_BITS_PER_SAMPLE_16;
+    if (bitsPerSample & A2DP_LHDCV5_BIT_FMT_24)
+      codec_selectable_capability_.bits_per_sample |= BTAV_A2DP_CODEC_BITS_PER_SAMPLE_24;
+    if (bitsPerSample & A2DP_LHDCV5_BIT_FMT_32)
+      codec_selectable_capability_.bits_per_sample |= BTAV_A2DP_CODEC_BITS_PER_SAMPLE_32;
+
+    if (codec_config_.bits_per_sample != BTAV_A2DP_CODEC_BITS_PER_SAMPLE_NONE) {
+      log::info( ": bit_per_sample configured by UI successfully 0x{:02x}",
+           result_config_cie.bitsPerSample);
+      break;
+    }
+    // Ignore follows if codec config is setup, otherwise pick a best one from default rules
+
+    // Compute the common capability
+    if (bitsPerSample & A2DP_LHDCV5_BIT_FMT_16)
+      codec_capability_.bits_per_sample |= BTAV_A2DP_CODEC_BITS_PER_SAMPLE_16;
+    if (bitsPerSample & A2DP_LHDCV5_BIT_FMT_24)
+      codec_capability_.bits_per_sample |= BTAV_A2DP_CODEC_BITS_PER_SAMPLE_24;
+    if (bitsPerSample & A2DP_LHDCV5_BIT_FMT_32)
+      codec_capability_.bits_per_sample |= BTAV_A2DP_CODEC_BITS_PER_SAMPLE_32;
+
+    // No user preference - the the codec audio config
+    if (select_audio_bits_per_sample(&codec_audio_config_, bitsPerSample,
+        &result_config_cie, &codec_config_)) {
+      log::info( ": select bit per sample from audio: 0x{:02x}",
+          result_config_cie.bitsPerSample);
+      break;
+    }
+
+    // No user preference - try the default config
+    if (select_best_bits_per_sample(
+        a2dp_lhdcv5_source_default_caps.bitsPerSample & sink_info_cie.bitsPerSample,
+        &result_config_cie, &codec_config_)) {
+      log::info( ": select bit per sample from default: 0x{:02x}",
+          result_config_cie.bitsPerSample);
+      break;
+    }
+
+    // No user preference - use the best match
+    if (select_best_bits_per_sample(bitsPerSample, &result_config_cie,
+        &codec_config_)) {
+      log::info( ": select sample rate from best match: 0x{:02x}",
+          result_config_cie.bitsPerSample);
+      break;
+    }
+  } while (false);
+
+  if (codec_config_.bits_per_sample == BTAV_A2DP_CODEC_BITS_PER_SAMPLE_NONE) {
+    log::error(
+        ": cannot match bits per sample: local caps = 0x{:02x} "
+        "peer info = 0x{:02x}",
+         p_a2dp_lhdcv5_caps->bitsPerSample,
+        sink_info_cie.bitsPerSample);
+    goto fail;
+  }
+  codec_user_config_.bits_per_sample = codec_config_.bits_per_sample;
+  log::info( ": => bit per sample(0x{:02x}) = {}",
+      result_config_cie.bitsPerSample,
+      lhdcV5_bitPerSample_toString(result_config_cie.bitsPerSample).c_str());
+
+  // Select the channel mode
+  codec_user_config_.channel_mode = BTAV_A2DP_CODEC_CHANNEL_MODE_STEREO;
+  codec_selectable_capability_.channel_mode = BTAV_A2DP_CODEC_CHANNEL_MODE_STEREO;
+  codec_capability_.channel_mode = BTAV_A2DP_CODEC_CHANNEL_MODE_STEREO;
+  codec_config_.channel_mode = BTAV_A2DP_CODEC_CHANNEL_MODE_STEREO;
+  log::info( ": channelMode = Only supported stereo");
+
+  // Update frameLenType
+  result_config_cie.frameLenType = sink_info_cie.frameLenType;
+  log::info( ": => frame length type(0x{:02x}) = {}",
+      result_config_cie.frameLenType,
+      lhdcV5_frameLenType_toString(result_config_cie.frameLenType).c_str());
+
+  // Update maxTargetBitrate
+  result_config_cie.maxTargetBitrate = sink_info_cie.maxTargetBitrate;
+  log::info( ": => peer Max Bit Rate(0x{:02x}) = {}",
+      result_config_cie.maxTargetBitrate,
+      lhdcV5_MaxTargetBitRate_toString(result_config_cie.maxTargetBitrate).c_str());
+
+  // Update minTargetBitrate
+  result_config_cie.minTargetBitrate = sink_info_cie.minTargetBitrate;
+  log::info( ": => peer Min Bit Rate(0x{:02x}) = {}",
+      result_config_cie.minTargetBitrate,
+      lhdcV5_MinTargetBitRate_toString(result_config_cie.minTargetBitrate).c_str());
+
+  //
+  // Update Feature/Capabilities to A2DP specifics
+  //
+  /*******************************************
+   * for features that can be enabled by user-control, exam features tag on the specific.
+   * current user-control enabling features:
+   *    Feature: AR
+   *    Feature: Lossless
+   *******************************************/
+  //features on specific 3
+  if ((codec_user_config_.codec_specific_3 & A2DP_LHDC_VENDOR_FEATURE_MASK) != A2DP_LHDCV5_FEATURE_MAGIC_NUM)
+  {
+    // reset the specific and apply tag
+    codec_user_config_.codec_specific_3 = A2DP_LHDCV5_FEATURE_MAGIC_NUM;
+
+    // get previous status of user-control enabling features from codec_config, then restore to user settings
+    //
+    // Feature: LL
+    hasUserSet = A2DP_IsFeatureInCodecConfigLhdcV5(&allCfgPack, LHDCV5_FEATURE_CODE_LL);
+    A2DP_UpdateFeatureToA2dpConfigLhdcV5(
+        &allCfgPack,
+        LHDCV5_FEATURE_CODE_LL,
+        A2DP_LHDC_TO_A2DP_CODEC_USER_,
+        (hasUserSet?true:false));
+    log::info( ": LHDC features tag check fail, default UI status[LL] => {}",  hasUserSet?"true":"false");
+
+    // Feature: AR (default UI: OFF)
+    hasUserSet = false;
+    A2DP_UpdateFeatureToA2dpConfigLhdcV5(
+        &allCfgPack,
+        LHDCV5_FEATURE_CODE_AR,
+        A2DP_LHDC_TO_A2DP_CODEC_USER_,
+        (hasUserSet?true:false));
+    log::info( ": LHDC features tag check fail, default UI status[AR] => {}",  hasUserSet?"true":"false");
+
+    // Feature: Lossless (default UI: OFF)
+    hasUserSet = false;
+    A2DP_UpdateFeatureToA2dpConfigLhdcV5(
+      &allCfgPack,
+      LHDCV5_FEATURE_CODE_LLESS,
+      A2DP_LHDC_TO_A2DP_CODEC_USER_,
+      (hasUserSet?true:false));
+    log::info( ": LHDC features tag check fail, default UI status[LLESS] => {}",  hasUserSet?"true":"false");
+
+#ifdef LHDC_LOSSLESS_RAW_SUPPORT
+    // Feature: Lossless Raw(default UI: OFF)
+    hasUserSet = false;
+    A2DP_UpdateFeatureToA2dpConfigLhdcV5(
+      &allCfgPack,
+      LHDCV5_FEATURE_CODE_LLESS_RAW,
+      A2DP_LHDC_TO_A2DP_CODEC_USER_,
+      (hasUserSet?true:false));
+    log::info( ": LHDC features tag check fail, default UI status[LLESS Raw] => {}",  hasUserSet?"true":"false");
+#endif
+  }
+
+  /*************************************************
+   *  quality mode initialize
+   *************************************************/
+  if ((codec_user_config_.codec_specific_1 & A2DP_LHDC_VENDOR_CMD_MASK) != A2DP_LHDC_QUALITY_MAGIC_NUM) {
+    codec_user_config_.codec_specific_1 &= ~(A2DP_LHDC_VENDOR_CMD_MASK | A2DP_LHDC_QUALITY_MASK);
+    codec_user_config_.codec_specific_1 |= (A2DP_LHDC_QUALITY_MAGIC_NUM | A2DP_LHDC_QUALITY_ABR);
+    log::info( ": tag not match, use default Quality Mode: ABR");
+  }
+  qualityMode = (uint8_t)codec_user_config_.codec_specific_1 & A2DP_LHDC_QUALITY_MASK;
+
+  /*******************************************
+   *  JAS: caps-control enabling
+   *******************************************/
+  {
+    hasFeature = (p_a2dp_lhdcv5_caps->hasFeatureJAS & sink_info_cie.hasFeatureJAS);
+    // reset first
+    result_config_cie.hasFeatureJAS = false;
+    hasUserSet = true;  //caps-control enabling case => always true
+
+    A2DP_UpdateFeatureToA2dpConfigLhdcV5(
+        &allCfgPack,
+        LHDCV5_FEATURE_CODE_JAS,
+        (A2DP_LHDC_TO_A2DP_CODEC_CONFIG_ | A2DP_LHDC_TO_A2DP_CODEC_CAP_ |
+            A2DP_LHDC_TO_A2DP_CODEC_SELECT_CAP_ | A2DP_LHDC_TO_A2DP_CODEC_USER_),
+            false);
+    // update
+    if (hasFeature && hasUserSet) {
+      result_config_cie.hasFeatureJAS = true;
+      A2DP_UpdateFeatureToA2dpConfigLhdcV5(
+          &allCfgPack,
+          LHDCV5_FEATURE_CODE_JAS,
+          (A2DP_LHDC_TO_A2DP_CODEC_CAP_ |
+              A2DP_LHDC_TO_A2DP_CODEC_SELECT_CAP_ | A2DP_LHDC_TO_A2DP_CODEC_USER_),
+              true);
+    }
+    log::info( ": featureJAS: enabled? <{}> Peer:0x{:02x} Local:0x{:02x}",
+        (result_config_cie.hasFeatureJAS?"Y":"N"),
+        sink_info_cie.hasFeatureJAS,
+        p_a2dp_lhdcv5_caps->hasFeatureJAS);
+  }
+
+  /*******************************************
+   *  AR: user-control/peer-OTA control enabling
+   *******************************************/
+  {
+    hasFeature = (p_a2dp_lhdcv5_caps->hasFeatureAR & sink_info_cie.hasFeatureAR);
+    // reset first
+    result_config_cie.hasFeatureAR = false;
+    hasUserSet = A2DP_IsFeatureInUserConfigLhdcV5(&allCfgPack, LHDCV5_FEATURE_CODE_AR);
+
+    A2DP_UpdateFeatureToA2dpConfigLhdcV5(
+        &allCfgPack,
+        LHDCV5_FEATURE_CODE_AR,
+        (A2DP_LHDC_TO_A2DP_CODEC_CONFIG_ | A2DP_LHDC_TO_A2DP_CODEC_CAP_ |
+            A2DP_LHDC_TO_A2DP_CODEC_SELECT_CAP_ | A2DP_LHDC_TO_A2DP_CODEC_USER_),
+        false);
+    // update
+    // default AR turning on condition: (customizable)
+    //  1. both sides have the capabilities
+    //  2. (UI on SRC side turns on) || (SNK set AR_ON in codec info)
+    if (hasFeature && hasUserSet) {
+      result_config_cie.hasFeatureAR = true;  //decide to turn on feature in encoder
+      A2DP_UpdateFeatureToA2dpConfigLhdcV5(
+          &allCfgPack,
+          LHDCV5_FEATURE_CODE_AR,
+          (A2DP_LHDC_TO_A2DP_CODEC_CAP_ |
+              A2DP_LHDC_TO_A2DP_CODEC_SELECT_CAP_ | A2DP_LHDC_TO_A2DP_CODEC_USER_),
+              true);
+    }
+    log::info( ": featureAR: enabled? <{}> Peer:0x{:02x} Local:0x{:02x} User:{}",
+        (result_config_cie.hasFeatureAR?"Y":"N"),
+        sink_info_cie.hasFeatureAR,
+        p_a2dp_lhdcv5_caps->hasFeatureAR,
+        (hasUserSet?"Y":"N"));
+  }
+
+  /*******************************************
+   *  META: caps-control enabling
+   *******************************************/
+  {
+    hasFeature = (p_a2dp_lhdcv5_caps->hasFeatureMETA & sink_info_cie.hasFeatureMETA);
+    // reset first
+    result_config_cie.hasFeatureMETA = false;
+    hasUserSet = true;  //caps-control enabling, always true
+
+    A2DP_UpdateFeatureToA2dpConfigLhdcV5(
+        &allCfgPack,
+        LHDCV5_FEATURE_CODE_META,
+        (A2DP_LHDC_TO_A2DP_CODEC_CONFIG_ | A2DP_LHDC_TO_A2DP_CODEC_CAP_ |
+            A2DP_LHDC_TO_A2DP_CODEC_SELECT_CAP_ | A2DP_LHDC_TO_A2DP_CODEC_USER_),
+        false);
+    // update
+    if (hasFeature && hasUserSet) {
+      result_config_cie.hasFeatureMETA = true;
+      A2DP_UpdateFeatureToA2dpConfigLhdcV5(
+          &allCfgPack,
+          LHDCV5_FEATURE_CODE_META,
+          (A2DP_LHDC_TO_A2DP_CODEC_CAP_ |
+              A2DP_LHDC_TO_A2DP_CODEC_SELECT_CAP_ | A2DP_LHDC_TO_A2DP_CODEC_USER_),
+              true);
+    }
+    log::info( ": featureMETA: enabled? <{}> Peer:0x{:02x} Local:0x{:02x}",
+        (result_config_cie.hasFeatureMETA?"Y":"N"),
+        sink_info_cie.hasFeatureMETA,
+        p_a2dp_lhdcv5_caps->hasFeatureMETA);
+  }
+
+  /*******************************************
+   *  Low Latency: user-control enabling
+   *******************************************/
+  {
+    hasFeature = (p_a2dp_lhdcv5_caps->hasFeatureLL & sink_info_cie.hasFeatureLL);
+    // reset first
+    result_config_cie.hasFeatureLL = false;
+    hasUserSet = A2DP_IsFeatureInUserConfigLhdcV5(&allCfgPack, LHDCV5_FEATURE_CODE_LL);
+
+    A2DP_UpdateFeatureToA2dpConfigLhdcV5(
+        &allCfgPack,
+        LHDCV5_FEATURE_CODE_LL,
+        (A2DP_LHDC_TO_A2DP_CODEC_CONFIG_ | A2DP_LHDC_TO_A2DP_CODEC_CAP_ |
+            A2DP_LHDC_TO_A2DP_CODEC_SELECT_CAP_ | A2DP_LHDC_TO_A2DP_CODEC_USER_),
+        false);
+    // update
+    if (hasFeature && hasUserSet) {
+      result_config_cie.hasFeatureLL = true;
+      A2DP_UpdateFeatureToA2dpConfigLhdcV5(
+          &allCfgPack,
+          LHDCV5_FEATURE_CODE_LL,
+          (A2DP_LHDC_TO_A2DP_CODEC_CAP_ |
+              A2DP_LHDC_TO_A2DP_CODEC_SELECT_CAP_ | A2DP_LHDC_TO_A2DP_CODEC_USER_),
+              true);
+    }
+    log::info( ": featureLL: enabled? <{}> Peer:0x{:02x} Local:0x{:02x} User:{}",
+        (result_config_cie.hasFeatureLL?"Y":"N"),
+        sink_info_cie.hasFeatureLL,
+        p_a2dp_lhdcv5_caps->hasFeatureLL,
+        (hasUserSet?"Y":"N"));
+  }
+
+  /*******************************************
+   *  LLESS (normal mode): user-control enabling
+   *******************************************/
+  {
+    hasFeature = (p_a2dp_lhdcv5_caps->hasFeatureLLESS48K & sink_info_cie.hasFeatureLLESS48K);
+    // reset first
+    result_config_cie.hasFeatureLLESS48K = false;
+    result_config_cie.hasFeatureLLESS24Bit = false;
+    result_config_cie.hasFeatureLLESS96K = false;
+    hasUserSet = A2DP_IsFeatureInUserConfigLhdcV5(&allCfgPack, LHDCV5_FEATURE_CODE_LLESS);  //UI-control
+
+    A2DP_UpdateFeatureToA2dpConfigLhdcV5(
+        &allCfgPack,
+        LHDCV5_FEATURE_CODE_LLESS,
+        (A2DP_LHDC_TO_A2DP_CODEC_CONFIG_ | A2DP_LHDC_TO_A2DP_CODEC_CAP_ |
+            A2DP_LHDC_TO_A2DP_CODEC_SELECT_CAP_ | A2DP_LHDC_TO_A2DP_CODEC_USER_),
+        false);
+
+    // update
+    if (hasFeature && hasUserSet) {
+      result_config_cie.hasFeatureLLESS48K = true;
+      A2DP_UpdateFeatureToA2dpConfigLhdcV5(
+          &allCfgPack,
+          LHDCV5_FEATURE_CODE_LLESS,
+          (A2DP_LHDC_TO_A2DP_CODEC_CAP_ |
+              A2DP_LHDC_TO_A2DP_CODEC_SELECT_CAP_ | A2DP_LHDC_TO_A2DP_CODEC_USER_),
+              true);
+
+      if (p_a2dp_lhdcv5_caps->hasFeatureLLESS24Bit & sink_info_cie.hasFeatureLLESS24Bit) {
+        result_config_cie.hasFeatureLLESS24Bit = true;
+      }
+
+      if (p_a2dp_lhdcv5_caps->hasFeatureLLESS96K & sink_info_cie.hasFeatureLLESS96K) {
+        result_config_cie.hasFeatureLLESS96K = true;
+      }
+    }
+
+    log::info( ": featureLLESS: enabled? <{}> Peer:0x{:02x} Local:0x{:02x} User:{} 24bit:{} 96K:{}",
+        (result_config_cie.hasFeatureLLESS48K?"Y":"N"),
+        sink_info_cie.hasFeatureLLESS48K,
+        p_a2dp_lhdcv5_caps->hasFeatureLLESS48K,
+        (hasUserSet?"Y":"N"),
+        (result_config_cie.hasFeatureLLESS24Bit?"Y":"N"),
+        (result_config_cie.hasFeatureLLESS96K?"Y":"N"));
+  }
+
+#ifdef LHDC_LOSSLESS_RAW_SUPPORT
+  /*******************************************
+   *  LLESS (RAW mode): user-control enabling
+   *******************************************/
+  {
+    hasFeature = (p_a2dp_lhdcv5_caps->hasFeatureLLESSRaw & sink_info_cie.hasFeatureLLESSRaw);
+    // reset first
+    result_config_cie.hasFeatureLLESSRaw = false;
+    hasUserSet = A2DP_IsFeatureInUserConfigLhdcV5(&allCfgPack, LHDCV5_FEATURE_CODE_LLESS_RAW);  //UI-control
+
+    A2DP_UpdateFeatureToA2dpConfigLhdcV5(
+        &allCfgPack,
+        LHDCV5_FEATURE_CODE_LLESS_RAW,
+        (A2DP_LHDC_TO_A2DP_CODEC_CONFIG_ | A2DP_LHDC_TO_A2DP_CODEC_CAP_ |
+            A2DP_LHDC_TO_A2DP_CODEC_SELECT_CAP_ | A2DP_LHDC_TO_A2DP_CODEC_USER_),
+        false);
+
+    // update, lossless must be enabled first for raw mode
+    if (hasFeature && hasUserSet && result_config_cie.hasFeatureLLESS48K) {
+      result_config_cie.hasFeatureLLESSRaw = true;
+      A2DP_UpdateFeatureToA2dpConfigLhdcV5(
+          &allCfgPack,
+          LHDCV5_FEATURE_CODE_LLESS_RAW,
+          (A2DP_LHDC_TO_A2DP_CODEC_CAP_ |
+              A2DP_LHDC_TO_A2DP_CODEC_SELECT_CAP_ | A2DP_LHDC_TO_A2DP_CODEC_USER_),
+              true);
+    }
+
+    log::info( ": featureLLESSRaw: enabled? <{}> Peer:0x{:02x} Local:0x{:02x} User:{}",
+        (result_config_cie.hasFeatureLLESSRaw?"Y":"N"),
+        sink_info_cie.hasFeatureLLESSRaw,
+        p_a2dp_lhdcv5_caps->hasFeatureLLESSRaw,
+        (hasUserSet?"Y":"N"));
+  }
+#endif
+
+
+  log::info(": current quality_mode = 0x{:02x}",  qualityMode);
+
+  /*******************************************
+   * Update LHDC Peer Max Bitrate Index to specific 1
+   *******************************************/
+  // store peer cap: max target bitrate index for UI reference
+  codec_user_config_.codec_specific_1 &= ~(A2DP_LHDC_PEER_MAX_BITRATE_MASK);
+  switch(result_config_cie.maxTargetBitrate)
+  {
+    case A2DP_LHDCV5_MAX_BIT_RATE_400K:
+    {
+      codec_user_config_.codec_specific_1 |= (A2DP_LHDCV5_MAX_BIT_RATE_400K << 4);
+      break;
+    }
+    case A2DP_LHDCV5_MAX_BIT_RATE_500K:
+    {
+      codec_user_config_.codec_specific_1 |= (A2DP_LHDCV5_MAX_BIT_RATE_500K << 4);
+      break;
+    }
+    case A2DP_LHDCV5_MAX_BIT_RATE_900K:
+    {
+      codec_user_config_.codec_specific_1 |= (A2DP_LHDCV5_MAX_BIT_RATE_900K << 4);
+      break;
+    }
+    case A2DP_LHDCV5_MAX_BIT_RATE_1000K:
+    {
+      codec_user_config_.codec_specific_1 |= (A2DP_LHDCV5_MAX_BIT_RATE_1000K << 4);
+      break;
+    }
+  }
+
+  /*******************************************
+   * Update LHDC Peer Min Bitrate Index to specific 1
+   *******************************************/
+  // store peer cap: max target bitrate index for UI reference
+  codec_user_config_.codec_specific_1 &= ~(A2DP_LHDC_PEER_MIN_BITRATE_MASK);
+  switch(result_config_cie.minTargetBitrate)
+  {
+    case A2DP_LHDCV5_MIN_BIT_RATE_64K:
+    {
+      codec_user_config_.codec_specific_1 |= (A2DP_LHDCV5_MIN_BIT_RATE_64K << 12);
+      break;
+    }
+    case A2DP_LHDCV5_MIN_BIT_RATE_160K:
+    {
+      codec_user_config_.codec_specific_1 |= (A2DP_LHDCV5_MIN_BIT_RATE_160K << 12);
+      break;
+    }
+    case A2DP_LHDCV5_MIN_BIT_RATE_256K:
+    {
+      codec_user_config_.codec_specific_1 |= (A2DP_LHDCV5_MIN_BIT_RATE_256K << 12);
+      break;
+    }
+    case A2DP_LHDCV5_MIN_BIT_RATE_400K:
+    {
+      codec_user_config_.codec_specific_1 |= (A2DP_LHDCV5_MIN_BIT_RATE_400K << 12);
+      break;
+    }
+  }
+
+
+  //
+  // special rules: Lossless enable/disable re-adjustion
+  //
+  if(result_config_cie.hasFeatureLLESS48K == true) {
+    //Rule: (lossless enabled): only runs at "no limit" maxTargetBitrate
+    //    reason:  operational bit rate of lossless requires at least 900kbps.
+    if (!A2DP_MaxBitRatetoQualityLevelLhdcV5(&bitRateQmode, result_config_cie.maxTargetBitrate)) {
+      log::error( ": get quality mode from maxTargetBitrate error");
+      goto fail;
+    }
+    //HIGH1 ==> A2DP_LHDC_MAX_BIT_RATE_1000K, equivalent to "no upper limit"
+    if (bitRateQmode != A2DP_LHDC_QUALITY_HIGH1) {
+      A2DP_UpdateFeatureToA2dpConfigLhdcV5(
+          &allCfgPack,
+          LHDCV5_FEATURE_CODE_LLESS,
+          (A2DP_LHDC_TO_A2DP_CODEC_CAP_ |
+              A2DP_LHDC_TO_A2DP_CODEC_SELECT_CAP_ | A2DP_LHDC_TO_A2DP_CODEC_USER_),
+              false);
+      result_config_cie.hasFeatureLLESS48K = false;
+      result_config_cie.hasFeatureLLESS24Bit = false;
+      result_config_cie.hasFeatureLLESS96K = false;
+#ifdef LHDC_LOSSLESS_RAW_SUPPORT
+      A2DP_UpdateFeatureToA2dpConfigLhdcV5(
+          &allCfgPack,
+          LHDCV5_FEATURE_CODE_LLESS_RAW,
+          (A2DP_LHDC_TO_A2DP_CODEC_CAP_ |
+              A2DP_LHDC_TO_A2DP_CODEC_SELECT_CAP_ | A2DP_LHDC_TO_A2DP_CODEC_USER_),
+              false);
+      result_config_cie.hasFeatureLLESSRaw = false;
+#endif
+      log::info( ": disable lossless due to peer Max Bit Rate not NO LIMIT");
+    }
+    // Rule: AR feature is mutex with lossless feature (lossless prior to AR)
+    if (result_config_cie.hasFeatureLLESS48K == true && result_config_cie.hasFeatureAR) {
+      result_config_cie.hasFeatureAR = false;
+      A2DP_UpdateFeatureToA2dpConfigLhdcV5(
+          &allCfgPack,
+          LHDCV5_FEATURE_CODE_AR,
+          (A2DP_LHDC_TO_A2DP_CODEC_CAP_ |
+              A2DP_LHDC_TO_A2DP_CODEC_SELECT_CAP_ | A2DP_LHDC_TO_A2DP_CODEC_USER_),
+              false);
+    }
+  }
+
+  //
+  // special rules: sample rate re-adjustion
+  //
+  if(result_config_cie.hasFeatureAR == true) {
+    // set (48KHz sample rate) when AR
+    if (codec_user_config_.sample_rate != BTAV_A2DP_CODEC_SAMPLE_RATE_48000) {
+      codec_config_.sample_rate = BTAV_A2DP_CODEC_SAMPLE_RATE_48000;
+      codec_capability_.sample_rate = BTAV_A2DP_CODEC_SAMPLE_RATE_48000;
+      codec_user_config_.sample_rate = BTAV_A2DP_CODEC_SAMPLE_RATE_48000;
+      result_config_cie.sampleRate = A2DP_LHDCV5_SAMPLING_FREQ_48000;
+      log::info( ": set 48KHz sample Rate for running AR");
+    }
+  }
+
+  if (result_config_cie.hasFeatureLLESS48K == true) {
+#ifdef LHDC_LOSSLESS_RAW_SUPPORT
+    if (result_config_cie.hasFeatureLLESSRaw == true) {
+      // lossless (raw mode)
+      //   => 48 or 96KHz for lossless raw mode
+      if (result_config_cie.hasFeatureLLESS96K == false) {
+        // only have capability of 48KHz lossless raw mode (not have 96KHz lossless)
+        codec_config_.sample_rate = BTAV_A2DP_CODEC_SAMPLE_RATE_48000;
+        codec_capability_.sample_rate = BTAV_A2DP_CODEC_SAMPLE_RATE_48000;
+        codec_user_config_.sample_rate = BTAV_A2DP_CODEC_SAMPLE_RATE_48000;
+        result_config_cie.sampleRate = A2DP_LHDCV5_SAMPLING_FREQ_48000;
+        log::info( ": (lossless raw) set 48KHz sample rate");
+      } else {
+        // have 96KHz lossless capabilities
+        if (codec_user_config_.sample_rate != BTAV_A2DP_CODEC_SAMPLE_RATE_48000 &&
+            codec_user_config_.sample_rate != BTAV_A2DP_CODEC_SAMPLE_RATE_96000) {
+          //  => set default 48KHz when user-configured sample rate is not supported
+          codec_config_.sample_rate = BTAV_A2DP_CODEC_SAMPLE_RATE_48000;
+          codec_capability_.sample_rate = BTAV_A2DP_CODEC_SAMPLE_RATE_48000;
+          codec_user_config_.sample_rate = BTAV_A2DP_CODEC_SAMPLE_RATE_48000;
+          result_config_cie.sampleRate = A2DP_LHDCV5_SAMPLING_FREQ_48000;
+          log::info( ": (lossless raw) default 48KHz sample rate");
+        } else {
+          //  48 or 96KHz => use sample rate from user
+          log::info( ": (lossless raw) apply  sample rate", 
+              lhdcV5_sampleRate_toString(result_config_cie.sampleRate).c_str());
+        }
+      }
+    } else {
+#endif
+      // lossless (normal mode):
+      if (result_config_cie.hasFeatureLLESS96K == false) {
+        // only have capability of 48KHz lossless (not have 96KHz lossless)
+        //   => fixed 48KHz
+        codec_config_.sample_rate = BTAV_A2DP_CODEC_SAMPLE_RATE_48000;
+        codec_capability_.sample_rate = BTAV_A2DP_CODEC_SAMPLE_RATE_48000;
+        codec_user_config_.sample_rate = BTAV_A2DP_CODEC_SAMPLE_RATE_48000;
+        result_config_cie.sampleRate = A2DP_LHDCV5_SAMPLING_FREQ_48000;
+        log::info( ": (lossless) fixed 48KHz sample rate");
+      } else {
+        // user configure other sample rates(not 48KHz and 96KHz)
+        //  => default 48KHz
+        if (codec_user_config_.sample_rate != BTAV_A2DP_CODEC_SAMPLE_RATE_48000 &&
+            codec_user_config_.sample_rate != BTAV_A2DP_CODEC_SAMPLE_RATE_96000) {
+          //  => set default 48KHz when user-configured sample rate is not supported
+          codec_config_.sample_rate = BTAV_A2DP_CODEC_SAMPLE_RATE_48000;
+          codec_capability_.sample_rate = BTAV_A2DP_CODEC_SAMPLE_RATE_48000;
+          codec_user_config_.sample_rate = BTAV_A2DP_CODEC_SAMPLE_RATE_48000;
+          result_config_cie.sampleRate = A2DP_LHDCV5_SAMPLING_FREQ_48000;
+          log::info( ": (lossless) default 48KHz sample rate");
+        } else {
+          // user configure 48/96KHz
+          //  => use sample rate from user
+          log::info( ": (lossless) apply  sample rate", 
+              lhdcV5_sampleRate_toString(result_config_cie.sampleRate).c_str());
+        }
+      }
+#ifdef LHDC_LOSSLESS_RAW_SUPPORT
+    }
+#endif
+  }
+
+  //
+  // special rules: bit per sample re-adjustion
+  //
+  if (result_config_cie.hasFeatureAR == true) {
+    // set (default 24 bits per sample) if not in 16 or 24 when AR
+    if (codec_user_config_.bits_per_sample != BTAV_A2DP_CODEC_BITS_PER_SAMPLE_16 &&
+        codec_user_config_.bits_per_sample != BTAV_A2DP_CODEC_BITS_PER_SAMPLE_24) {
+      codec_config_.bits_per_sample = BTAV_A2DP_CODEC_BITS_PER_SAMPLE_24;
+      codec_capability_.bits_per_sample = BTAV_A2DP_CODEC_BITS_PER_SAMPLE_24;
+      codec_user_config_.bits_per_sample = BTAV_A2DP_CODEC_BITS_PER_SAMPLE_24;
+      result_config_cie.bitsPerSample = A2DP_LHDCV5_BIT_FMT_24;
+      log::info( ": set 24 bits per sample for running AR");
+    }
+  }
+
+  if (result_config_cie.hasFeatureLLESS48K == true) {
+    if (result_config_cie.hasFeatureLLESS24Bit == true) {
+      if (codec_user_config_.bits_per_sample != BTAV_A2DP_CODEC_BITS_PER_SAMPLE_16 &&
+          codec_user_config_.bits_per_sample != BTAV_A2DP_CODEC_BITS_PER_SAMPLE_24) {
+        // check bit-per-sample capability
+        bitsPerSample = p_a2dp_lhdcv5_caps->bitsPerSample & sink_info_cie.bitsPerSample;
+
+        if (bitsPerSample & A2DP_LHDCV5_BIT_FMT_24) {
+          // unsupported bitrate, use 24bit as default
+          codec_config_.bits_per_sample = BTAV_A2DP_CODEC_BITS_PER_SAMPLE_24;
+          codec_capability_.bits_per_sample = BTAV_A2DP_CODEC_BITS_PER_SAMPLE_24;
+          codec_user_config_.bits_per_sample = BTAV_A2DP_CODEC_BITS_PER_SAMPLE_24;
+          result_config_cie.bitsPerSample = A2DP_LHDCV5_BIT_FMT_24;
+          log::info( ": (lossless-24bit): use default 24 mode");
+        } else {
+          // unsupported bitrate, use 16bit as default
+          codec_config_.bits_per_sample = BTAV_A2DP_CODEC_BITS_PER_SAMPLE_16;
+          codec_capability_.bits_per_sample = BTAV_A2DP_CODEC_BITS_PER_SAMPLE_16;
+          codec_user_config_.bits_per_sample = BTAV_A2DP_CODEC_BITS_PER_SAMPLE_16;
+          result_config_cie.bitsPerSample = A2DP_LHDCV5_BIT_FMT_16;
+          log::info( ": (lossless-24bit): use default 16 bit mode");
+        }
+      } else {
+        // bitrate supported, adopt user's configuration
+        if (codec_user_config_.bits_per_sample == BTAV_A2DP_CODEC_BITS_PER_SAMPLE_24) {
+          log::info( ": (lossless-24bit): use 24 bit mode");
+        } else {
+          log::info( ": (lossless-24bit): use 16 bit mode");
+        }
+      }
+    } else {
+      // hasFeatureLLESS24Bit not supported, always use 16bit
+      codec_config_.bits_per_sample = BTAV_A2DP_CODEC_BITS_PER_SAMPLE_16;
+      codec_capability_.bits_per_sample = BTAV_A2DP_CODEC_BITS_PER_SAMPLE_16;
+      codec_user_config_.bits_per_sample = BTAV_A2DP_CODEC_BITS_PER_SAMPLE_16;
+      result_config_cie.bitsPerSample = A2DP_LHDCV5_BIT_FMT_16;
+      log::info( ": (lossless-16bit): 16 bit mode only");
+    }
+  }
+
+  // lossless and lossless raw mode 96KHz case:
+  // Current lossless and lossless raw mode support 96KHz 24bit only.
+  //   reconfigure to other config if user configures (96KHz + 16bit)
+  if ((result_config_cie.hasFeatureLLESS48K == true) &&
+      (result_config_cie.hasFeatureLLESS96K == true) &&
+      (result_config_cie.sampleRate == A2DP_LHDCV5_SAMPLING_FREQ_96000)) {
+    if (result_config_cie.hasFeatureLLESS24Bit == true) {
+      if (result_config_cie.bitsPerSample == A2DP_LHDCV5_BIT_FMT_24) {
+        log::info( ": (lossless 96KHz) : 24bit OK");
+      } else {
+        codec_config_.bits_per_sample = BTAV_A2DP_CODEC_BITS_PER_SAMPLE_24;
+        codec_capability_.bits_per_sample = BTAV_A2DP_CODEC_BITS_PER_SAMPLE_24;
+        codec_user_config_.bits_per_sample = BTAV_A2DP_CODEC_BITS_PER_SAMPLE_24;
+        result_config_cie.bitsPerSample = A2DP_LHDCV5_BIT_FMT_24;
+        log::info( ": (lossless 96KHz) : unsupported bit depth but 24bit capable, reconfigure to 24bit");
+      }
+    } else {
+      codec_config_.sample_rate = BTAV_A2DP_CODEC_SAMPLE_RATE_48000;
+      codec_capability_.sample_rate = BTAV_A2DP_CODEC_SAMPLE_RATE_48000;
+      codec_user_config_.sample_rate = BTAV_A2DP_CODEC_SAMPLE_RATE_48000;
+      result_config_cie.sampleRate = A2DP_LHDCV5_SAMPLING_FREQ_48000;
+
+      codec_config_.bits_per_sample = BTAV_A2DP_CODEC_BITS_PER_SAMPLE_16;
+      codec_capability_.bits_per_sample = BTAV_A2DP_CODEC_BITS_PER_SAMPLE_16;
+      codec_user_config_.bits_per_sample = BTAV_A2DP_CODEC_BITS_PER_SAMPLE_16;
+      result_config_cie.bitsPerSample = A2DP_LHDCV5_BIT_FMT_16;
+      log::info( ": (lossless 96KHz) : 16 and 24bit not capable, reconfigure to 48KHz 16bit");
+    }
+  }
+
+  //
+  // special rules: quality mode re-adjustion
+  //
+  if (result_config_cie.hasFeatureLLESS48K == true) {
+    // (lossless enabled): re-adjusting by maxTargetBitrate, minTargetBitrate is not supported now
+    // (lossless enabled): can only run in ABR mode
+    if ((qualityMode != A2DP_LHDC_QUALITY_ABR)) {
+      log::info( ": reset non-supported quality mode () to () for lossless", 
+          lhdcV5_QualityModeBitRate_toString(qualityMode).c_str(),
+          lhdcV5_QualityModeBitRate_toString(A2DP_LHDC_QUALITY_ABR).c_str());
+      codec_user_config_.codec_specific_1 &= ~(A2DP_LHDC_VENDOR_CMD_MASK | A2DP_LHDC_QUALITY_MASK);
+      codec_user_config_.codec_specific_1 |= (A2DP_LHDC_QUALITY_MAGIC_NUM | A2DP_LHDC_QUALITY_ABR);
+      qualityMode = A2DP_LHDC_QUALITY_ABR;
+    }
+  } else {
+    // (lossless disabled):
+    // non-ABR qualityMode re-adjusting
+    if (qualityMode != A2DP_LHDC_QUALITY_ABR) {
+      // get corresponding quality mode of the max target bit rate
+      if (!A2DP_MaxBitRatetoQualityLevelLhdcV5(&bitRateQmode, result_config_cie.maxTargetBitrate)) {
+        log::error( ": get quality mode from maxTargetBitrate error");
+        goto fail;
+      }
+      // downgrade audio quality according to the max target bit rate
+      if (qualityMode > bitRateQmode) {
+        codec_user_config_.codec_specific_1 &= ~(A2DP_LHDC_VENDOR_CMD_MASK | A2DP_LHDC_QUALITY_MASK);
+        codec_user_config_.codec_specific_1 |= (A2DP_LHDC_QUALITY_MAGIC_NUM | bitRateQmode);
+        qualityMode = bitRateQmode;
+        log::info( ": downgrade quality mode to 0x{:02x}",  qualityMode);
+      }
+
+      // get corresponding quality mode of the min target bit rate
+      if (!A2DP_MinBitRatetoQualityLevelLhdcV5(&bitRateQmode, result_config_cie.minTargetBitrate)) {
+        log::error( ": get quality mode from minTargetBitrate error");
+        goto fail;
+      }
+      // upgrade audio quality according to the min target bit rate
+      if (qualityMode < bitRateQmode) {
+        codec_user_config_.codec_specific_1 &= ~(A2DP_LHDC_VENDOR_CMD_MASK | A2DP_LHDC_QUALITY_MASK);
+        codec_user_config_.codec_specific_1 |= (A2DP_LHDC_QUALITY_MAGIC_NUM | bitRateQmode);
+        qualityMode = bitRateQmode;
+        log::info( ": upgrade quality mode to 0x{:02x}",  qualityMode);
+      }
+
+      // rule: if (sample rate >= 96KHz) fixed bitrate must be at least 256kbps(LOW3),
+      if (result_config_cie.sampleRate == A2DP_LHDCV5_SAMPLING_FREQ_96000 ||
+          result_config_cie.sampleRate == A2DP_LHDCV5_SAMPLING_FREQ_192000) {
+        if (qualityMode < A2DP_LHDC_QUALITY_LOW3) {
+          codec_user_config_.codec_specific_1 &= ~(A2DP_LHDC_VENDOR_CMD_MASK | A2DP_LHDC_QUALITY_MASK);
+          codec_user_config_.codec_specific_1 |= (A2DP_LHDC_QUALITY_MAGIC_NUM | A2DP_LHDC_QUALITY_LOW3);
+          qualityMode = A2DP_LHDC_QUALITY_LOW3;
+          log::info( ": upgrade quality mode to 0x{:02x} due to higher sample rates",  qualityMode);
+        }
+      }
+
+      // rule: if (sample rate <= 48KHz) fixed bitrate must be at most 900kbps(HIGH),
+      if (result_config_cie.sampleRate == A2DP_LHDCV5_SAMPLING_FREQ_44100 ||
+          result_config_cie.sampleRate == A2DP_LHDCV5_SAMPLING_FREQ_48000) {
+        if (qualityMode >= A2DP_LHDC_QUALITY_HIGH1 &&
+            qualityMode != A2DP_LHDC_QUALITY_ABR) {
+          codec_user_config_.codec_specific_1 &= ~(A2DP_LHDC_VENDOR_CMD_MASK | A2DP_LHDC_QUALITY_MASK);
+          codec_user_config_.codec_specific_1 = (A2DP_LHDC_QUALITY_MAGIC_NUM | A2DP_LHDC_QUALITY_HIGH);
+          qualityMode = A2DP_LHDC_QUALITY_HIGH;
+          log::info( ": downgrade quality mode to 0x{:02x} due to lower sample rates",  qualityMode);
+        }
+      }
+    }
+  }
+
+  log::info( ": => final quality mode(0x{:02x}) = {}",
+      qualityMode,
+      lhdcV5_QualityModeBitRate_toString(qualityMode).c_str());
+
+  /* Setup final nego result config to peer */
+  if (A2DP_BuildInfoLhdcV5(AVDT_MEDIA_TYPE_AUDIO, &result_config_cie,
+      p_result_codec_config) != A2DP_SUCCESS) {
+    log::error( ": A2DP build info fail");
+    goto fail;
+  }
+
+  //
+  // Copy the codec-specific fields if they are not zero
+  //
+  if (codec_user_config_.codec_specific_1 != 0)
+    codec_config_.codec_specific_1 = codec_user_config_.codec_specific_1;
+  if (codec_user_config_.codec_specific_2 != 0)
+    codec_config_.codec_specific_2 = codec_user_config_.codec_specific_2;
+  if (codec_user_config_.codec_specific_3 != 0)
+    codec_config_.codec_specific_3 = codec_user_config_.codec_specific_3;
+  if (codec_user_config_.codec_specific_4 != 0)
+    codec_config_.codec_specific_4 = codec_user_config_.codec_specific_4;
+
+  // Create a local copy of the peer codec capability, and the
+  // result codec config.
+  if (is_capability) {
+    status = A2DP_BuildInfoLhdcV5(AVDT_MEDIA_TYPE_AUDIO, &sink_info_cie,
+        ota_codec_peer_capability_);
+  } else {
+    status = A2DP_BuildInfoLhdcV5(AVDT_MEDIA_TYPE_AUDIO, &sink_info_cie,
+        ota_codec_peer_config_);
+  }
+  CHECK(status == A2DP_SUCCESS);
+
+  status = A2DP_BuildInfoLhdcV5(AVDT_MEDIA_TYPE_AUDIO, &result_config_cie,
+      ota_codec_config_);
+  CHECK(status == A2DP_SUCCESS);
+  return A2DP_SUCCESS;
+
+  fail:
+  // Restore the internal state
+  codec_config_ = saved_codec_config;
+  codec_capability_ = saved_codec_capability;
+  codec_selectable_capability_ = saved_codec_selectable_capability;
+  codec_user_config_ = saved_codec_user_config;
+  codec_audio_config_ = saved_codec_audio_config;
+  memcpy(ota_codec_config_, saved_ota_codec_config, sizeof(ota_codec_config_));
+  memcpy(ota_codec_peer_capability_, saved_ota_codec_peer_capability,
+      sizeof(ota_codec_peer_capability_));
+  memcpy(ota_codec_peer_config_, saved_ota_codec_peer_config,
+      sizeof(ota_codec_peer_config_));
+  return status;
+}
+
+bool A2dpCodecConfigLhdcV5Base::setPeerCodecCapabilities(
+    const uint8_t* p_peer_codec_capabilities) {
+  std::lock_guard<std::recursive_mutex> lock(codec_mutex_);
+  tA2DP_LHDCV5_CIE peer_info_cie;
+  uint8_t sampleRate;
+  uint8_t bits_per_sample;
+  tA2DP_STATUS status;
+  const tA2DP_LHDCV5_CIE* p_a2dp_lhdcv5_caps =
+      (is_source_) ? &a2dp_lhdcv5_source_caps : &a2dp_lhdcv5_sink_caps;
+
+  // Save the internal state
+  btav_a2dp_codec_config_t saved_codec_selectable_capability =
+      codec_selectable_capability_;
+  uint8_t saved_ota_codec_peer_capability[AVDT_CODEC_SIZE];
+  memcpy(saved_ota_codec_peer_capability, ota_codec_peer_capability_,
+      sizeof(ota_codec_peer_capability_));
+
+  if (p_peer_codec_capabilities == nullptr) {
+    log::error( ": nullptr input");
+    status = AVDTP_UNSUPPORTED_CONFIGURATION;
+    goto fail;
+  }
+
+  status = A2DP_ParseInfoLhdcV5(&peer_info_cie, p_peer_codec_capabilities, true, IS_SRC);
+  if (status != A2DP_SUCCESS) {
+    log::error( ": can't parse peer's capabilities: error = {}",
+         status);
+    goto fail;
+  }
+
+  // Compute the selectable capability - sample rate
+  sampleRate = p_a2dp_lhdcv5_caps->sampleRate & peer_info_cie.sampleRate;
+  if (sampleRate & A2DP_LHDCV5_SAMPLING_FREQ_44100) {
+    codec_selectable_capability_.sample_rate |=
+        BTAV_A2DP_CODEC_SAMPLE_RATE_44100;
+  }
+  if (sampleRate & A2DP_LHDCV5_SAMPLING_FREQ_48000) {
+    codec_selectable_capability_.sample_rate |=
+        BTAV_A2DP_CODEC_SAMPLE_RATE_48000;
+  }
+  if (sampleRate & A2DP_LHDCV5_SAMPLING_FREQ_96000) {
+    codec_selectable_capability_.sample_rate |=
+        BTAV_A2DP_CODEC_SAMPLE_RATE_96000;
+  }
+  if (sampleRate & A2DP_LHDCV5_SAMPLING_FREQ_192000) {
+    codec_selectable_capability_.sample_rate |=
+        BTAV_A2DP_CODEC_SAMPLE_RATE_192000;
+  }
+
+  // Compute the selectable capability - bits per sample
+  bits_per_sample = p_a2dp_lhdcv5_caps->bitsPerSample & peer_info_cie.bitsPerSample;
+  if (bits_per_sample & A2DP_LHDCV5_BIT_FMT_16) {
+    codec_selectable_capability_.bits_per_sample |= BTAV_A2DP_CODEC_BITS_PER_SAMPLE_16;
+  }
+  if (bits_per_sample & A2DP_LHDCV5_BIT_FMT_24) {
+    codec_selectable_capability_.bits_per_sample |= BTAV_A2DP_CODEC_BITS_PER_SAMPLE_24;
+  }
+  if (bits_per_sample & A2DP_LHDCV5_BIT_FMT_32) {
+    codec_selectable_capability_.bits_per_sample |= BTAV_A2DP_CODEC_BITS_PER_SAMPLE_32;
+  }
+
+  // Compute the selectable capability - channel mode
+  codec_selectable_capability_.channel_mode = BTAV_A2DP_CODEC_CHANNEL_MODE_STEREO;
+
+  status = A2DP_BuildInfoLhdcV5(AVDT_MEDIA_TYPE_AUDIO, &peer_info_cie,
+      ota_codec_peer_capability_);
+  CHECK(status == A2DP_SUCCESS);
+  return A2DP_SUCCESS;
+
+  fail:
+  // Restore the internal state
+  codec_selectable_capability_ = saved_codec_selectable_capability;
+  memcpy(ota_codec_peer_capability_, saved_ota_codec_peer_capability,
+      sizeof(ota_codec_peer_capability_));
+  return status;
+}
+
+////////
+//    class implementation for LHDC V5 Sink
+////////
+A2dpCodecConfigLhdcV5Sink::A2dpCodecConfigLhdcV5Sink(
+    btav_a2dp_codec_priority_t codec_priority)
+: A2dpCodecConfigLhdcV5Base(BTAV_A2DP_CODEC_INDEX_SINK_LHDCV5,
+    A2DP_VendorCodecIndexStrLhdcV5Sink(),
+    codec_priority, false) {}
+
+A2dpCodecConfigLhdcV5Sink::~A2dpCodecConfigLhdcV5Sink() {}
+
+bool A2dpCodecConfigLhdcV5Sink::init() {
+  // Load the decoder
+  if (!A2DP_VendorLoadDecoderLhdcV5()) {
+    log::error( ": cannot load the decoder");
+    return false;
+  }
+
+  return true;
+}
+
+bool A2dpCodecConfigLhdcV5Sink::useRtpHeaderMarkerBit() const {
+  // TODO: This method applies only to Source codecs
+  return false;
+}
+
+#if 0
+bool A2dpCodecConfigLhdcV5Sink::updateEncoderUserConfig(
+    UNUSED_ATTR const tA2DP_ENCODER_INIT_PEER_PARAMS* p_peer_params,
+    UNUSED_ATTR bool* p_restart_input, UNUSED_ATTR bool* p_restart_output,
+    UNUSED_ATTR bool* p_config_updated) {
+  // TODO: This method applies only to Source codecs
+  return false;
+}
+#endif
+
+#if 0
+uint64_t A2dpCodecConfigLhdcV5Sink::encoderIntervalMs() const {
+  // TODO: This method applies only to Source codecs
+  return 0;
+}
+#endif
+
+#if 0
+int A2dpCodecConfigLhdcV5Sink::getEffectiveMtu() const {
+  // TODO: This method applies only to Source codecs
+  return 0;
+}
+#endif
+
+////////
+//    APIs for calling from encoder/decoder module - START
+////////
+bool A2DP_VendorGetMaxBitRateLhdcV5(uint32_t *retval, const uint8_t* p_codec_info){
+  tA2DP_LHDCV5_CIE lhdc_cie;
+  tA2DP_STATUS a2dp_status;
+
+  if (p_codec_info == nullptr || retval == nullptr) {
+    log::error( ": nullptr input");
+    return false;
+  }
+
+  // Check whether the codec info contains valid data
+  a2dp_status = A2DP_ParseInfoLhdcV5(&lhdc_cie, p_codec_info, true, IS_SRC);
+  if (a2dp_status != A2DP_SUCCESS) {
+    log::error( ": cannot decode codec information: {}", 
+        a2dp_status);
+    return false;
+  }
+
+  switch (lhdc_cie.maxTargetBitrate) {
+  case A2DP_LHDCV5_MAX_BIT_RATE_1000K:
+    *retval = (uint32_t)A2DP_LHDC_QUALITY_HIGH1;
+    return true;
+  case A2DP_LHDCV5_MAX_BIT_RATE_900K:
+    *retval = (uint32_t)A2DP_LHDC_QUALITY_HIGH;
+    return true;
+  case A2DP_LHDCV5_MAX_BIT_RATE_500K:
+    *retval = (uint32_t)A2DP_LHDC_QUALITY_MID;
+    return true;
+  case A2DP_LHDCV5_MAX_BIT_RATE_400K:
+    *retval = (uint32_t)A2DP_LHDC_QUALITY_LOW;
+    return true;
+  }
+
+  return false;
+}
+
+bool A2DP_VendorGetMinBitRateLhdcV5(uint32_t *retval, const uint8_t* p_codec_info){
+  tA2DP_LHDCV5_CIE lhdc_cie;
+  tA2DP_STATUS a2dp_status;
+
+  if (p_codec_info == nullptr || retval == nullptr) {
+    log::error( ": nullptr input");
+    return false;
+  }
+
+  // Check whether the codec info contains valid data
+  a2dp_status = A2DP_ParseInfoLhdcV5(&lhdc_cie, p_codec_info, true, IS_SRC);
+  if (a2dp_status != A2DP_SUCCESS) {
+    log::error( ": cannot decode codec information: {}", 
+        a2dp_status);
+    return false;
+  }
+
+  switch (lhdc_cie.minTargetBitrate) {
+  case A2DP_LHDCV5_MIN_BIT_RATE_400K:
+    *retval = (uint32_t)A2DP_LHDC_QUALITY_LOW;
+    return true;
+  case A2DP_LHDCV5_MIN_BIT_RATE_256K:
+    *retval = (uint32_t)A2DP_LHDC_QUALITY_LOW3;
+    return true;
+  case A2DP_LHDCV5_MIN_BIT_RATE_160K:
+    *retval = (uint32_t)A2DP_LHDC_QUALITY_LOW1;
+    return true;
+  case A2DP_LHDCV5_MIN_BIT_RATE_64K:
+    *retval = (uint32_t)A2DP_LHDC_QUALITY_LOW0;
+    return true;
+  }
+
+  return false;
+}
+
+bool A2DP_VendorGetVersionLhdcV5(uint32_t *retval, const uint8_t* p_codec_info){
+  tA2DP_LHDCV5_CIE lhdc_cie;
+  tA2DP_STATUS a2dp_status;
+
+  if (p_codec_info == nullptr || retval == nullptr) {
+    log::error( ": nullptr input");
+    return false;
+  }
+
+  // Check whether the codec info contains valid data
+  a2dp_status = A2DP_ParseInfoLhdcV5(&lhdc_cie, p_codec_info, false, IS_SRC);
+  if (a2dp_status != A2DP_SUCCESS) {
+    log::error( ": cannot decode codec information: {}", 
+        a2dp_status);
+    return false;
+  }
+
+  *retval = (uint32_t)lhdc_cie.version;
+
+  return true;
+}
+
+bool A2DP_VendorGetBitPerSampleLhdcV5(uint8_t *retval, const uint8_t* p_codec_info){
+  tA2DP_LHDCV5_CIE lhdc_cie;
+  tA2DP_STATUS a2dp_status;
+
+  if (p_codec_info == nullptr || retval == nullptr) {
+    log::error( ": nullptr input");
+    return false;
+  }
+
+  // Check whether the codec info contains valid data
+  a2dp_status = A2DP_ParseInfoLhdcV5(&lhdc_cie, p_codec_info, false, IS_SRC);
+  if (a2dp_status != A2DP_SUCCESS) {
+    log::error( ": cannot decode codec information: {}", 
+        a2dp_status);
+    return false;
+  }
+
+  *retval = (uint32_t)lhdc_cie.bitsPerSample;
+
+  return true;
+}
+
+bool A2DP_VendorHasJASFlagLhdcV5(uint8_t *retval, const uint8_t* p_codec_info) {
+  tA2DP_LHDCV5_CIE lhdc_cie;
+  tA2DP_STATUS a2dp_status;
+
+  if (p_codec_info == nullptr || retval == nullptr) {
+    log::error( ": nullptr input");
+    return false;
+  }
+
+  // Check whether the codec info contains valid data
+  a2dp_status = A2DP_ParseInfoLhdcV5(&lhdc_cie, p_codec_info, false, IS_SRC);
+  if (a2dp_status != A2DP_SUCCESS) {
+    log::error( ": cannot decode codec information: {}", 
+        a2dp_status);
+    return false;
+  }
+  *retval = lhdc_cie.hasFeatureJAS ? 1 : 0;
+
+  return true;
+}
+
+bool A2DP_VendorHasARFlagLhdcV5(uint8_t *retval, const uint8_t* p_codec_info) {
+  tA2DP_LHDCV5_CIE lhdc_cie;
+  tA2DP_STATUS a2dp_status;
+
+  if (p_codec_info == nullptr || retval == nullptr) {
+    log::error( ": nullptr input");
+    return false;
+  }
+
+  // Check whether the codec info contains valid data
+  a2dp_status = A2DP_ParseInfoLhdcV5(&lhdc_cie, p_codec_info, false, IS_SRC);
+  if (a2dp_status != A2DP_SUCCESS) {
+    log::error( ": cannot decode codec information: {}", 
+        a2dp_status);
+    return false;
+  }
+  *retval = lhdc_cie.hasFeatureAR ? 1 : 0;
+
+  return true;
+}
+
+bool A2DP_VendorHasMETAFlagLhdcV5(uint8_t *retval, const uint8_t* p_codec_info) {
+  tA2DP_LHDCV5_CIE lhdc_cie;
+  tA2DP_STATUS a2dp_status;
+
+  if (p_codec_info == nullptr || retval == nullptr) {
+    log::error( ": nullptr input");
+    return false;
+  }
+
+  // Check whether the codec info contains valid data
+  a2dp_status = A2DP_ParseInfoLhdcV5(&lhdc_cie, p_codec_info, false, IS_SRC);
+  if (a2dp_status != A2DP_SUCCESS) {
+    log::error( ": cannot decode codec information: {}", 
+        a2dp_status);
+    return false;
+  }
+  *retval = lhdc_cie.hasFeatureMETA ? 1 : 0;
+
+  return true;
+}
+
+//orig A2DP_VendorGetLowLatencyStateLhdcV5
+bool A2DP_VendorHasLLFlagLhdcV5(uint8_t *retval, const uint8_t* p_codec_info){
+  tA2DP_LHDCV5_CIE lhdc_cie;
+  tA2DP_STATUS a2dp_status;
+
+  if (p_codec_info == nullptr || retval == nullptr) {
+    log::error( ": nullptr input");
+    return false;
+  }
+
+  // Check whether the codec info contains valid data
+  a2dp_status = A2DP_ParseInfoLhdcV5(&lhdc_cie, p_codec_info, false, IS_SRC);
+  if (a2dp_status != A2DP_SUCCESS) {
+    log::error( ": cannot decode codec information: {}", 
+        a2dp_status);
+    return false;
+  }
+  *retval = lhdc_cie.hasFeatureLL ? 1 : 0;
+
+  return true;
+}
+
+bool A2DP_VendorHasLLessFlagLhdcV5(uint8_t *retval, const uint8_t* p_codec_info){
+  tA2DP_LHDCV5_CIE lhdc_cie;
+  tA2DP_STATUS a2dp_status;
+
+  if (p_codec_info == nullptr || retval == nullptr) {
+    log::error( ": nullptr input");
+    return false;
+  }
+
+  // Check whether the codec info contains valid data
+  a2dp_status = A2DP_ParseInfoLhdcV5(&lhdc_cie, p_codec_info, false, IS_SRC);
+  if (a2dp_status != A2DP_SUCCESS) {
+    log::error( ": cannot decode codec information: {}", 
+        a2dp_status);
+    return false;
+  }
+  *retval = lhdc_cie.hasFeatureLLESS48K ? 1 : 0;
+
+  return true;
+}
+
+#ifdef LHDC_LOSSLESS_RAW_SUPPORT
+bool A2DP_VendorHasLLessRawFlagLhdcV5(uint8_t *retval, const uint8_t* p_codec_info){
+  tA2DP_LHDCV5_CIE lhdc_cie;
+  tA2DP_STATUS a2dp_status;
+
+  if (p_codec_info == nullptr || retval == nullptr) {
+    log::error( ": nullptr input");
+    return false;
+  }
+
+  // Check whether the codec info contains valid data
+  a2dp_status = A2DP_ParseInfoLhdcV5(&lhdc_cie, p_codec_info, false, IS_SRC);
+  if (a2dp_status != A2DP_SUCCESS) {
+    log::error( ": cannot decode codec information: {}", 
+        a2dp_status);
+    return false;
+  }
+  *retval = lhdc_cie.hasFeatureLLESSRaw ? 1 : 0;
+
+  return true;
+}
+#endif
+////////
+//    APIs for calling from encoder/decoder module - END
+////////
diff --git a/system/stack/a2dp/a2dp_vendor_lhdcv5_decoder.cc b/system/stack/a2dp/a2dp_vendor_lhdcv5_decoder.cc
new file mode 100755
index 0000000000..dc15a4ac7f
--- /dev/null
+++ b/system/stack/a2dp/a2dp_vendor_lhdcv5_decoder.cc
@@ -0,0 +1,617 @@
+/*
+ * Copyright (C) 2022 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+#define LOG_TAG "bluetooth-a2dp"
+#include "a2dp_vendor_lhdcv5_decoder.h"
+
+#include <dlfcn.h>
+#include <inttypes.h>
+#include <pthread.h>
+#include <stdio.h>
+#include <string.h>
+
+#include <lhdcv5BT_dec.h>
+
+#include "a2dp_vendor_lhdcv5.h"
+#include "common/time_util.h"
+#include "btif/include/btif_av_co.h"
+#include "internal_include/bt_trace.h"
+#include "stack/include/bt_hdr.h"
+#include "osi/include/osi.h"
+#include <bluetooth/log.h>
+#include "os/log.h"
+using namespace bluetooth;
+
+
+
+
+#define A2DP_LHDC_FUNC_DISABLE		0
+#define A2DP_LHDC_FUNC_ENABLE		1
+
+#define LHDCV5_DEC_MAX_SAMPLES_PER_FRAME  256
+#define LHDCV5_DEC_MAX_CHANNELS           2
+#define LHDCV5_DEC_MAX_BIT_DEPTH          32
+#define LHDCV5_DEC_FRAME_NUM              16
+#define LHDCV5_DEC_BUF_BYTES              (LHDCV5_DEC_FRAME_NUM * \
+                                           LHDCV5_DEC_MAX_SAMPLES_PER_FRAME * \
+                                           LHDCV5_DEC_MAX_CHANNELS * \
+                                           (LHDCV5_DEC_MAX_BIT_DEPTH >> 3))
+#define LHDCV5_DEC_PACKET_NUM             8
+#define LHDCV5_DEC_INPUT_BUF_BYTES        1024
+#define LHDCV5_DEC_PKT_HDR_BYTES          2
+
+typedef struct {
+  pthread_mutex_t mutex;
+  HANDLE_LHDCV5_BT lhdc_handle;
+  bool has_lhdc_handle;  // True if lhdc_handle is valid
+
+  uint32_t    sample_rate;
+  uint8_t     bits_per_sample;
+  lhdc_ver_t  version;
+  uint8_t     func_ar;
+  uint8_t     func_jas;
+  uint8_t     func_meta;
+  uint8_t     func_lless;
+#ifdef LHDC_LOSSLESS_RAW_SUPPORT
+  uint8_t     func_lless_raw;
+#endif
+  uint8_t     func_lless96K;
+
+  uint8_t     decode_buf[LHDCV5_DEC_PACKET_NUM][LHDCV5_DEC_BUF_BYTES];
+  uint32_t    dec_buf_idx;
+
+  uint8_t     dec_input_buf[LHDCV5_DEC_INPUT_BUF_BYTES];
+  uint32_t    dec_input_buf_bytes;
+
+  decoded_data_callback_t decode_callback;
+} tA2DP_LHDCV5_DECODER_CB;
+
+static tA2DP_LHDCV5_DECODER_CB a2dp_lhdcv5_decoder_cb;
+
+
+//#define _V5DEC_REC_FILE_
+#if defined(_V5DEC_REC_FILE_)
+#define V5RAW_FILE_NAME "/sdcard/Download/lhdcv5dec.raw"
+#define V5PCM_FILE_NAME "/sdcard/Download/v5decoded.pcm"
+static FILE *rawFile = NULL;
+static FILE *pcmFile = NULL;
+#endif
+
+//
+// The LHDCV5 decoder shared library, and the functions to use
+//
+static const char* LHDC_DECODER_LIB_NAME = "liblhdcv5BT_dec.so";
+static void* lhdc_decoder_lib_handle = NULL;
+
+static const char* LHDCDEC_INIT_DECODER_NAME = "lhdcv5BT_dec_init_decoder";
+typedef int32_t (*tLHDCDEC_INIT_DECODER)(HANDLE_LHDCV5_BT *handle,
+    tLHDCV5_DEC_CONFIG *config);
+
+static const char* LHDCDEC_CHECK_FRAME_DATA_ENOUGH_NAME =
+    "lhdcv5BT_dec_check_frame_data_enough";
+typedef int32_t (*tLHDCDEC_CHECK_FRAME_DATA_ENOUGH)(const uint8_t *frameData,
+    uint32_t frameBytes, uint32_t *packetBytes);
+
+static const char* LHDCDEC_DECODE_NAME = "lhdcv5BT_dec_decode";
+typedef int32_t (*tLHDCDEC_DECODE)(const uint8_t *frameData, uint32_t frameBytes,
+    uint8_t* pcmData, uint32_t* pcmBytes, uint32_t bits_depth);
+
+static const char* LHDCDEC_DEINIT_DECODER_NAME = "lhdcv5BT_dec_deinit_decoder";
+typedef int32_t (*tLHDCDEC_DEINIT_DECODER)(HANDLE_LHDCV5_BT handle);
+
+static tLHDCDEC_INIT_DECODER lhdcv5dec_init_decoder;
+static tLHDCDEC_CHECK_FRAME_DATA_ENOUGH lhdcv5dec_check_frame_data_enough;
+static tLHDCDEC_DECODE lhdcv5dec_decode;
+static tLHDCDEC_DEINIT_DECODER lhdcv5dec_deinit_decoder;
+
+//LHDCV5 codec info (capabilities) format: refer in a2dp_vendor_lhdcv5_constants.h
+#define A2DP_LHDCV5_CODEC_INFO_ATTR_1 (3+6) //P6
+#define A2DP_LHDCV5_CODEC_INFO_ATTR_2 (3+7) //P7
+#define A2DP_LHDCV5_CODEC_INFO_ATTR_3 (3+8) //P8
+#define A2DP_LHDCV5_CODEC_INFO_ATTR_4 (3+9) //P9
+#define A2DP_LHDCV5_CODEC_INFO_ATTR_5 (3+10) //P10
+
+
+bool a2dp_lhdcv5_decoder_save_codec_info (const uint8_t* p_codec_info)
+{
+  if (p_codec_info == NULL) {
+    return false;
+  }
+
+  if (lhdc_decoder_lib_handle == NULL) {
+    return false;
+  }
+
+  // Sampling Frequency
+  if (p_codec_info[A2DP_LHDCV5_CODEC_INFO_ATTR_1] &
+      A2DP_LHDCV5_SAMPLING_FREQ_44100) {
+    a2dp_lhdcv5_decoder_cb.sample_rate = 44100;
+  } else if (p_codec_info[A2DP_LHDCV5_CODEC_INFO_ATTR_1] &
+      A2DP_LHDCV5_SAMPLING_FREQ_48000) {
+    a2dp_lhdcv5_decoder_cb.sample_rate = 48000;
+  } else if (p_codec_info[A2DP_LHDCV5_CODEC_INFO_ATTR_1] &
+      A2DP_LHDCV5_SAMPLING_FREQ_96000) {
+    a2dp_lhdcv5_decoder_cb.sample_rate = 96000;
+  } else if (p_codec_info[A2DP_LHDCV5_CODEC_INFO_ATTR_1] &
+      A2DP_LHDCV5_SAMPLING_FREQ_192000) {
+    a2dp_lhdcv5_decoder_cb.sample_rate = 192000;
+  } else {
+    return false;
+  }
+
+  // Bit Depth
+  if (p_codec_info[A2DP_LHDCV5_CODEC_INFO_ATTR_2] &
+      A2DP_LHDCV5_BIT_FMT_16) {
+    a2dp_lhdcv5_decoder_cb.bits_per_sample = 16;
+  } else if (p_codec_info[A2DP_LHDCV5_CODEC_INFO_ATTR_2] &
+      A2DP_LHDCV5_BIT_FMT_24) {
+    a2dp_lhdcv5_decoder_cb.bits_per_sample = 24;
+  } else if (p_codec_info[A2DP_LHDCV5_CODEC_INFO_ATTR_2] &
+      A2DP_LHDCV5_BIT_FMT_32) {
+    a2dp_lhdcv5_decoder_cb.bits_per_sample = 32;
+  } else {
+    return false;
+  }
+
+  // version
+  if (p_codec_info[A2DP_LHDCV5_CODEC_INFO_ATTR_3] &
+      A2DP_LHDCV5_VER_1) {
+    a2dp_lhdcv5_decoder_cb.version = VERSION_5;
+  } else {
+    return false;
+  }
+
+  // AR
+  if (p_codec_info[A2DP_LHDCV5_CODEC_INFO_ATTR_4] &
+      A2DP_LHDCV5_FEATURE_AR) {
+    a2dp_lhdcv5_decoder_cb.func_ar = A2DP_LHDC_FUNC_ENABLE;
+  } else {
+    a2dp_lhdcv5_decoder_cb.func_ar = A2DP_LHDC_FUNC_DISABLE;
+  }
+
+  // JAS
+  if (p_codec_info[A2DP_LHDCV5_CODEC_INFO_ATTR_4] &
+      A2DP_LHDCV5_FEATURE_JAS) {
+    a2dp_lhdcv5_decoder_cb.func_jas = A2DP_LHDC_FUNC_ENABLE;
+  } else {
+    a2dp_lhdcv5_decoder_cb.func_jas = A2DP_LHDC_FUNC_DISABLE;
+  }
+
+  // META
+  if (p_codec_info[A2DP_LHDCV5_CODEC_INFO_ATTR_4] &
+      A2DP_LHDCV5_FEATURE_META) {
+    a2dp_lhdcv5_decoder_cb.func_meta = A2DP_LHDC_FUNC_ENABLE;
+  } else {
+    a2dp_lhdcv5_decoder_cb.func_meta = A2DP_LHDC_FUNC_DISABLE;
+  }
+
+  // LOSSLESS 48KHz
+  if (p_codec_info[A2DP_LHDCV5_CODEC_INFO_ATTR_4] &
+      A2DP_LHDCV5_FEATURE_LLESS48K) {
+    a2dp_lhdcv5_decoder_cb.func_lless = A2DP_LHDC_FUNC_ENABLE;
+  } else {
+    a2dp_lhdcv5_decoder_cb.func_lless = A2DP_LHDC_FUNC_DISABLE;
+  }
+
+#ifdef LHDC_LOSSLESS_RAW_SUPPORT
+  // LOSSLESS RAW Mode: can be enabled when lossless is already enabled
+  if (p_codec_info[A2DP_LHDCV5_CODEC_INFO_ATTR_5] & A2DP_LHDCV5_FEATURE_LLESS_RAW) {
+    if (a2dp_lhdcv5_decoder_cb.func_lless == A2DP_LHDC_FUNC_ENABLE) {
+      a2dp_lhdcv5_decoder_cb.func_lless_raw = A2DP_LHDC_FUNC_ENABLE;
+    } else {
+      a2dp_lhdcv5_decoder_cb.func_lless_raw = A2DP_LHDC_FUNC_DISABLE;
+    }
+  } else {
+    a2dp_lhdcv5_decoder_cb.func_lless_raw = A2DP_LHDC_FUNC_DISABLE;
+  }
+#endif
+
+  // LOSSLESS 96KHz can be enabled when lossless is already enabled
+  if (p_codec_info[A2DP_LHDCV5_CODEC_INFO_ATTR_4] &
+      A2DP_LHDCV5_FEATURE_LLESS96K) {
+    if (a2dp_lhdcv5_decoder_cb.func_lless == A2DP_LHDC_FUNC_ENABLE) {
+      a2dp_lhdcv5_decoder_cb.func_lless96K = A2DP_LHDC_FUNC_ENABLE;
+    } else {
+      a2dp_lhdcv5_decoder_cb.func_lless96K = A2DP_LHDC_FUNC_DISABLE;
+    }
+  } else {
+    a2dp_lhdcv5_decoder_cb.func_lless96K = A2DP_LHDC_FUNC_DISABLE;
+  }
+
+  return true;
+}
+
+
+static void* load_func(const char* func_name) {
+
+  void* func_ptr = NULL;
+
+  if ((func_name == NULL) ||
+      (lhdc_decoder_lib_handle == NULL)) {
+    log::error( ": null ptr");
+    return NULL;
+  }
+
+  func_ptr = dlsym(lhdc_decoder_lib_handle, func_name);
+
+  if (func_ptr == NULL) {
+    log::error(
+        ": cannot find function '{}' in the encoder library: {}",
+         func_name, dlerror());
+    A2DP_VendorUnloadDecoderLhdcV5();
+    return NULL;
+  }
+
+  return func_ptr;
+}
+
+
+bool A2DP_VendorLoadDecoderLhdcV5(void) {
+
+  if (lhdc_decoder_lib_handle != NULL) {
+    return true;  // Already loaded
+  }
+
+  // Initialize the control block
+  memset(&a2dp_lhdcv5_decoder_cb, 0, sizeof(a2dp_lhdcv5_decoder_cb));
+
+  pthread_mutex_init(&(a2dp_lhdcv5_decoder_cb.mutex), NULL);
+
+  // Open the encoder library
+  lhdc_decoder_lib_handle = dlopen(LHDC_DECODER_LIB_NAME, RTLD_NOW);
+  if (lhdc_decoder_lib_handle == NULL) {
+    log::error( ": cannot open LHDCV5 decoder library ", dlerror());
+    return false;
+  }
+
+  // Load all functions
+  lhdcv5dec_init_decoder = (tLHDCDEC_INIT_DECODER)load_func(LHDCDEC_INIT_DECODER_NAME);
+  if (lhdcv5dec_init_decoder == NULL) return false;
+
+  lhdcv5dec_check_frame_data_enough =
+      (tLHDCDEC_CHECK_FRAME_DATA_ENOUGH)load_func(LHDCDEC_CHECK_FRAME_DATA_ENOUGH_NAME);
+  if (lhdcv5dec_check_frame_data_enough == NULL) return false;
+
+  lhdcv5dec_decode = (tLHDCDEC_DECODE)load_func(LHDCDEC_DECODE_NAME);
+  if (lhdcv5dec_decode == NULL) return false;
+
+  lhdcv5dec_deinit_decoder =
+      (tLHDCDEC_DEINIT_DECODER)load_func(LHDCDEC_DEINIT_DECODER_NAME);
+  if (lhdcv5dec_deinit_decoder == NULL) return false;
+
+  log::info( ": LHDCV5 decoder library loaded");
+  return true;
+}
+
+
+void A2DP_VendorUnloadDecoderLhdcV5(void) {
+
+  a2dp_vendor_lhdcv5_decoder_cleanup();
+
+  pthread_mutex_destroy(&(a2dp_lhdcv5_decoder_cb.mutex));
+  memset(&a2dp_lhdcv5_decoder_cb, 0, sizeof(a2dp_lhdcv5_decoder_cb));
+
+  lhdcv5dec_init_decoder = NULL;
+  lhdcv5dec_check_frame_data_enough = NULL;
+  lhdcv5dec_decode = NULL;
+  lhdcv5dec_deinit_decoder = NULL;
+
+  if (lhdc_decoder_lib_handle != NULL) {
+    dlclose(lhdc_decoder_lib_handle);
+    lhdc_decoder_lib_handle = NULL;
+  }
+
+#if defined(_V5DEC_REC_FILE_)
+  if (rawFile != NULL) {
+    fclose(rawFile);
+    rawFile = NULL;
+    remove(V5RAW_FILE_NAME);
+  }
+  if (pcmFile != NULL) {
+    fclose(pcmFile);
+    pcmFile = NULL;
+    remove(V5PCM_FILE_NAME);
+  }
+#endif
+  log::info( ": unload LHDC V5 decoder");
+}
+
+
+bool a2dp_vendor_lhdcv5_decoder_init(decoded_data_callback_t decode_callback) {
+  int32_t api_ret;
+  tLHDCV5_DEC_CONFIG lhdcdec_config;
+
+  if ((lhdc_decoder_lib_handle == NULL) ||
+      (lhdcv5dec_init_decoder == NULL) ||
+      (lhdcv5dec_deinit_decoder == NULL)) {
+    return false;
+  }
+
+  pthread_mutex_lock(&(a2dp_lhdcv5_decoder_cb.mutex));
+
+  //log::info( ": has_lhdc_handle({}) handle_base ({}) handle({})",
+     // a2dp_lhdcv5_decoder_cb.has_lhdc_handle,
+    //  &(a2dp_lhdcv5_decoder_cb.lhdc_handle),
+     // a2dp_lhdcv5_decoder_cb.lhdc_handle);
+
+  if (a2dp_lhdcv5_decoder_cb.has_lhdc_handle) {
+    api_ret = lhdcv5dec_deinit_decoder(a2dp_lhdcv5_decoder_cb.lhdc_handle);
+    if (api_ret != LHDCV5BT_DEC_API_SUCCEED) {
+      log::error( ": fail to deinit decoder {}", api_ret);
+      pthread_mutex_unlock(&(a2dp_lhdcv5_decoder_cb.mutex));
+      return false;
+    }
+    a2dp_lhdcv5_decoder_cb.has_lhdc_handle = false;
+    a2dp_lhdcv5_decoder_cb.lhdc_handle = NULL;
+    log::info( ": handle cleaned");
+  }
+
+  lhdcdec_config.version = a2dp_lhdcv5_decoder_cb.version;
+  lhdcdec_config.sample_rate = a2dp_lhdcv5_decoder_cb.sample_rate;
+  lhdcdec_config.bits_depth = a2dp_lhdcv5_decoder_cb.bits_per_sample;
+  lhdcdec_config.bit_rate = 400000;
+  lhdcdec_config.lossless_enable = a2dp_lhdcv5_decoder_cb.func_lless;
+#ifdef LHDC_LOSSLESS_RAW_SUPPORT
+  lhdcdec_config.lossless_raw_enable = a2dp_lhdcv5_decoder_cb.func_lless_raw;
+#endif
+
+  //check supported configuration for lossless 96KHz (24bit)
+  if (a2dp_lhdcv5_decoder_cb.func_lless == 1 &&
+      a2dp_lhdcv5_decoder_cb.func_lless96K == 1 &&
+      a2dp_lhdcv5_decoder_cb.sample_rate == 96000) {
+    if (a2dp_lhdcv5_decoder_cb.bits_per_sample != 24) {
+      log::error( ": wrong configuration for lossless 96KHz 24bit!");
+      pthread_mutex_unlock(&(a2dp_lhdcv5_decoder_cb.mutex));
+      return false;
+    }
+  }
+
+  if (a2dp_lhdcv5_decoder_cb.has_lhdc_handle == false &&
+      a2dp_lhdcv5_decoder_cb.lhdc_handle == NULL) {
+    log::info( ": to init decoder...");
+    api_ret = lhdcv5dec_init_decoder(&(a2dp_lhdcv5_decoder_cb.lhdc_handle), &lhdcdec_config);
+    if (api_ret != LHDCV5BT_DEC_API_SUCCEED) {
+      log::error( ": falied to init decoder {}", api_ret);
+      pthread_mutex_unlock(&(a2dp_lhdcv5_decoder_cb.mutex));
+      return false;
+    }
+    a2dp_lhdcv5_decoder_cb.has_lhdc_handle = true;
+  }
+
+  a2dp_lhdcv5_decoder_cb.dec_buf_idx = 0;
+  a2dp_lhdcv5_decoder_cb.dec_input_buf_bytes = 0;
+  a2dp_lhdcv5_decoder_cb.decode_callback = decode_callback;
+
+#if defined(_V5DEC_REC_FILE_)
+  if (rawFile == NULL) {
+    rawFile = fopen(V5RAW_FILE_NAME,"wb");
+    log::info( ": create recode file = {}", rawFile);
+  }
+  if (pcmFile == NULL) {
+    pcmFile = fopen(V5PCM_FILE_NAME,"wb");
+    log::info( ": create recode file = {}", pcmFile);
+  }
+#endif
+
+  log::info( ": init LHDCV5 decoder success");
+
+  pthread_mutex_unlock(&(a2dp_lhdcv5_decoder_cb.mutex));
+  return true;
+}
+
+
+void a2dp_vendor_lhdcv5_decoder_cleanup(void) {
+  int32_t api_ret;
+
+  pthread_mutex_lock(&(a2dp_lhdcv5_decoder_cb.mutex));
+
+  if (a2dp_lhdcv5_decoder_cb.has_lhdc_handle) {
+    api_ret = lhdcv5dec_deinit_decoder(a2dp_lhdcv5_decoder_cb.lhdc_handle);
+    if (api_ret != LHDCV5BT_DEC_API_SUCCEED) {
+      log::error( ": fail to deinit LHDCV5 decoder {}", api_ret);
+      pthread_mutex_unlock(&(a2dp_lhdcv5_decoder_cb.mutex));
+      return;
+    }
+  }
+
+  a2dp_lhdcv5_decoder_cb.has_lhdc_handle = false;
+  a2dp_lhdcv5_decoder_cb.lhdc_handle = NULL;
+
+  log::info( ": deinit LHDCV5 decoder success");
+  pthread_mutex_unlock(&(a2dp_lhdcv5_decoder_cb.mutex));
+}
+
+
+bool a2dp_vendor_lhdcv5_decoder_decode_packet(BT_HDR* p_buf) {
+  int32_t api_ret;
+  uint8_t *data;
+  size_t data_size;
+  uint32_t out_used = 0;
+  uint32_t dec_buf_idx;
+  uint8_t *ptr_src;
+  uint8_t *ptr_dst;
+  uint32_t packet_bytes;
+  uint32_t i;
+
+  log::info( ": enter");
+
+
+  if ((lhdc_decoder_lib_handle == NULL) ||
+      (lhdcv5dec_decode == NULL)) {
+    log::error( ": lib not loaded!");
+    return false;
+  }
+
+  // check handle
+  if (!a2dp_lhdcv5_decoder_cb.has_lhdc_handle || !a2dp_lhdcv5_decoder_cb.lhdc_handle) {
+    log::error( ": handle not existed!");
+    return false;
+  }
+
+  if (p_buf == NULL) {
+    return false;
+  }
+
+  pthread_mutex_lock(&(a2dp_lhdcv5_decoder_cb.mutex));
+
+  data = p_buf->data + p_buf->offset;
+  data_size = p_buf->len;
+
+  if (data_size == 0) {
+    log::error( ": Empty packet");
+    pthread_mutex_unlock(&(a2dp_lhdcv5_decoder_cb.mutex));
+    return false;
+  }
+
+
+  dec_buf_idx = a2dp_lhdcv5_decoder_cb.dec_buf_idx++;
+  if (a2dp_lhdcv5_decoder_cb.dec_buf_idx >= LHDCV5_DEC_PACKET_NUM) {
+    a2dp_lhdcv5_decoder_cb.dec_buf_idx = 0;
+  }
+
+#if defined(_V5DEC_REC_FILE_)
+  if (rawFile != NULL && data_size > 0) {
+    fwrite(data + LHDCV5_DEC_PKT_HDR_BYTES, sizeof(uint8_t),
+        data_size - LHDCV5_DEC_PKT_HDR_BYTES, rawFile);
+  }
+#endif
+
+  if ((a2dp_lhdcv5_decoder_cb.dec_input_buf_bytes + data_size) > LHDCV5_DEC_INPUT_BUF_BYTES) {
+    // the data queued is useless
+    // discard them
+    a2dp_lhdcv5_decoder_cb.dec_input_buf_bytes = 0;
+
+    if (data_size > LHDCV5_DEC_INPUT_BUF_BYTES)
+    {
+      // input data is too big (more than buffer size)!!
+      // just ingore it, and do nothing
+      pthread_mutex_unlock(&(a2dp_lhdcv5_decoder_cb.mutex));
+      return true;
+    }
+  }
+
+  memcpy (&(a2dp_lhdcv5_decoder_cb.dec_input_buf[a2dp_lhdcv5_decoder_cb.dec_input_buf_bytes]),
+      data, data_size);
+  a2dp_lhdcv5_decoder_cb.dec_input_buf_bytes += data_size;
+
+  packet_bytes = 0;
+  api_ret = lhdcv5dec_check_frame_data_enough(a2dp_lhdcv5_decoder_cb.dec_input_buf,
+      a2dp_lhdcv5_decoder_cb.dec_input_buf_bytes,
+      &packet_bytes);
+  if (api_ret != LHDCV5BT_DEC_API_SUCCEED) {
+    log::error( ": fail to check frame data! {}", api_ret);
+    // clear the data in the input buffer
+    a2dp_lhdcv5_decoder_cb.dec_input_buf_bytes = 0;
+    pthread_mutex_unlock(&(a2dp_lhdcv5_decoder_cb.mutex));
+    return false;
+  }
+
+  if (packet_bytes != (a2dp_lhdcv5_decoder_cb.dec_input_buf_bytes - LHDCV5_DEC_PKT_HDR_BYTES)) {
+    // strange!
+    // queued data is NOT exactly equal to one packet!
+    // maybe wrong data in buffer
+    // discard data queued previously, and save input data
+    log::error( ": queued data is NOT exactly equal to one packet! packet ({}),  input ({})",
+         packet_bytes, a2dp_lhdcv5_decoder_cb.dec_input_buf_bytes);
+
+    a2dp_lhdcv5_decoder_cb.dec_input_buf_bytes = 0;
+    memcpy(&(a2dp_lhdcv5_decoder_cb.dec_input_buf[a2dp_lhdcv5_decoder_cb.dec_input_buf_bytes]),
+        data,
+        data_size);
+    a2dp_lhdcv5_decoder_cb.dec_input_buf_bytes += data_size;
+    pthread_mutex_unlock(&(a2dp_lhdcv5_decoder_cb.mutex));
+    return true;
+  }
+
+  out_used = sizeof(a2dp_lhdcv5_decoder_cb.decode_buf[dec_buf_idx]);
+
+  api_ret = lhdcv5dec_decode(a2dp_lhdcv5_decoder_cb.dec_input_buf,
+      a2dp_lhdcv5_decoder_cb.dec_input_buf_bytes,
+      a2dp_lhdcv5_decoder_cb.decode_buf[dec_buf_idx],
+      &out_used,
+      a2dp_lhdcv5_decoder_cb.bits_per_sample);
+
+  // finish decoding
+  // clear the data in the input buffer
+  a2dp_lhdcv5_decoder_cb.dec_input_buf_bytes = 0;
+
+  if (api_ret != LHDCV5BT_DEC_API_SUCCEED) {
+    log::error( ": fail to decode lhdc stream! {}", api_ret);
+    pthread_mutex_unlock(&(a2dp_lhdcv5_decoder_cb.mutex));
+    return false;
+  }
+
+  if (a2dp_lhdcv5_decoder_cb.bits_per_sample == 24) { //PCM_24_BIT_PACKCED
+    ptr_src = a2dp_lhdcv5_decoder_cb.decode_buf[dec_buf_idx];
+    ptr_dst = a2dp_lhdcv5_decoder_cb.decode_buf[dec_buf_idx];
+
+    for (i = 0; i < (out_used >> 2) ; i++) {
+      *ptr_dst++ = *ptr_src++;
+      *ptr_dst++ = *ptr_src++;
+      *ptr_dst++ = *ptr_src++;
+      ptr_src++;
+    }
+    out_used = (out_used >> 2) * 3;
+  } else if (a2dp_lhdcv5_decoder_cb.bits_per_sample == 32) {
+    ptr_dst = a2dp_lhdcv5_decoder_cb.decode_buf[dec_buf_idx];
+
+    for (i = 0; i < (out_used >> 2) ; i++) {
+      ptr_dst[3] = ptr_dst[2];
+      ptr_dst[2] = ptr_dst[1];
+      ptr_dst[1] = ptr_dst[0];
+      ptr_dst[0] = 0;
+      ptr_dst+=4;
+    }
+  }
+
+#if defined(_V5DEC_REC_FILE_)
+  if (pcmFile != NULL && out_used > 0 &&
+      out_used <= sizeof(a2dp_lhdcv5_decoder_cb.decode_buf[dec_buf_idx])) {
+    fwrite(a2dp_lhdcv5_decoder_cb.decode_buf[dec_buf_idx],
+        sizeof(uint8_t), out_used, pcmFile);
+  }
+#endif
+
+  a2dp_lhdcv5_decoder_cb.decode_callback(
+      reinterpret_cast<uint8_t*>(a2dp_lhdcv5_decoder_cb.decode_buf[dec_buf_idx]), out_used);
+
+  pthread_mutex_unlock(&(a2dp_lhdcv5_decoder_cb.mutex));
+  return true;
+}
+
+void a2dp_vendor_lhdcv5_decoder_start(void) {
+  //pthread_mutex_lock(&(a2dp_lhdcv5_decoder_cb.mutex));
+  log::info("");
+  // do nothing
+
+  //pthread_mutex_unlock(&(a2dp_lhdcv5_decoder_cb.mutex));
+}
+
+void a2dp_vendor_lhdcv5_decoder_suspend(void) {
+  //pthread_mutex_lock(&(a2dp_lhdcv5_decoder_cb.mutex));
+  log::info("");
+  // do nothing
+}
+
+void a2dp_vendor_lhdcv5_decoder_configure(const uint8_t* p_codec_info) {
+  if (p_codec_info == NULL) {
+    log::info(": p_codec_info is NULL");
+    return;
+  }
+  //pthread_mutex_lock(&(a2dp_lhdcv5_decoder_cb.mutex));
+  log::info("");
+  //pthread_mutex_unlock(&(a2dp_lhdcv5_decoder_cb.mutex));
+}
diff --git a/system/stack/a2dp/a2dp_vendor_lhdcv5_encoder.cc b/system/stack/a2dp/a2dp_vendor_lhdcv5_encoder.cc
new file mode 100755
index 0000000000..386738717e
--- /dev/null
+++ b/system/stack/a2dp/a2dp_vendor_lhdcv5_encoder.cc
@@ -0,0 +1,1309 @@
+/*
+ * Copyright (C) 2016 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+
+#define ATRACE_TAG ATRACE_TAG_AUDIO
+#define LOG_TAG "bluetooth-a2dp"
+#include "a2dp_vendor_lhdcv5_encoder.h"
+
+#ifndef OS_GENERIC
+#include <cutils/trace.h>
+#endif
+#include <dlfcn.h>
+#include <inttypes.h>
+#include <stdio.h>
+#include <string.h>
+
+#include <lhdcv5BT.h>
+
+#include "a2dp_vendor.h"
+#include "a2dp_vendor_lhdcv5.h"
+#include "common/time_util.h"
+#include "osi/include/allocator.h"
+#include "btif/include/btif_av_co.h"
+#include "internal_include/bt_trace.h"
+#include "stack/include/bt_hdr.h"
+#include "osi/include/osi.h"
+#include <bluetooth/log.h>
+#include "os/log.h"
+using namespace bluetooth;
+
+
+//
+// Encoder for LHDC Source Codec
+//
+//#define MCPS_FRAME_ENCODE    // estimate MCPS of encoding frame
+
+#ifdef MCPS_FRAME_ENCODE
+#define STATIS_MILLION_UNIT   (1000000)
+#define STATIS_KILO_UNIT      (1000)
+#define STATIS_CPU_FREQ_MHZ   (1708800 / 1000)  //referenced CPU clock: 1708800KHz
+#define MCPS_FRAME_ENCODE_DUR (60)             //statistics duration (sec)
+uint64_t mcpsStat_time_dur_cnt_lhdcv5 = 0;     //statistics duration counter (sec)
+uint64_t mcpsStat_all_enc_us_lhdcv5 = 0;       //total execution time(us) of current encoded frames
+uint64_t mcpsStat_all_enc_frm_lhdcv5 = 0;      //total number of current encoded frames
+uint64_t mcpsStat_enc_frm_per_sec_lhdcv5 = 0;  //number of frame encoded in one sec
+uint64_t mcpsStat_all_time_dur_ms_lhdcv5 = 0;  //total real time(ms) when enter final statistics calculation
+#endif
+
+//#define LHDCV5_SRC_EXT_API_ENABLE // Savitehc LHDC_EXT_API
+
+//
+// The LHDC encoder shared library, and the functions to use
+//
+static const char* LHDC_ENCODER_LIB_NAME = "liblhdcv5BT_enc.so";
+static void* lhdc_encoder_lib_handle = nullptr;
+
+static const char* LHDC_GET_HANDLE_NAME = "lhdcv5BT_get_handle";
+typedef int32_t (*tLHDC_GET_HANDLE)(uint32_t version, HANDLE_LHDCV5_BT *hLhdcParam);
+
+static const char* LHDC_FREE_HANDLE_NAME = "lhdcv5BT_free_handle";
+typedef int32_t (*tLHDC_FREE_HANDLE)(HANDLE_LHDCV5_BT hLhdcParam);
+
+static const char* LHDC_GET_BITRATE_NAME = "lhdcv5BT_get_bitrate";
+typedef int32_t (*tLHDC_GET_BITRATE)(HANDLE_LHDCV5_BT hLhdcParam, uint32_t *bitrate);
+
+static const char* LHDC_SET_BITRATE_NAME = "lhdcv5BT_set_bitrate";
+typedef int32_t (*tLHDC_SET_BITRATE)(HANDLE_LHDCV5_BT hLhdcParam, uint32_t bitrateInx);
+
+static const char* LHDC_SET_MAX_BITRATE_NAME = "lhdcv5BT_set_max_bitrate";
+typedef int32_t (*tLHDC_SET_MAX_BITRATE)(HANDLE_LHDCV5_BT hLhdcParam, uint32_t maxBitrateInx);
+
+static const char* LHDC_SET_MIN_BITRATE_NAME = "lhdcv5BT_set_min_bitrate";
+typedef int32_t (*tLHDC_SET_MIN_BITRATE)(HANDLE_LHDCV5_BT hLhdcParam, uint32_t minBitrateInx);
+
+static const char* LHDC_AUTO_ADJUST_BITRATE_NAME = "lhdcv5BT_adjust_bitrate";
+typedef int32_t (*tLHDC_AUTO_ADJUST_BITRATE)(HANDLE_LHDCV5_BT hLhdcParam, uint32_t queueLength);
+
+static const char* LHDC_SET_EXT_FUNC = "lhdcv5BT_set_ext_func_state";
+typedef int32_t (*tLHDC_SET_EXT_FUNC)(HANDLE_LHDCV5_BT hLhdcParam,
+    LHDCV5_EXT_FUNC_T field, bool enabled, void *priv, uint32_t privDataLen);
+
+static const char* LHDC_INIT_ENCODER_NAME = "lhdcv5BT_init_encoder";
+typedef int32_t (*tLHDC_INIT_ENCODER)(HANDLE_LHDCV5_BT hLhdcParam,
+    uint32_t samplingFreq, uint32_t bitsPerSample, uint32_t bitrateInx,
+    uint32_t mtu, uint32_t interval, uint32_t is_lossless_enable);
+
+static const char* LHDC_GET_BLOCK_SIZE = "lhdcv5BT_get_block_Size";
+typedef int32_t (*tLHDC_GET_BLOCK_SIZE)(HANDLE_LHDCV5_BT hLhdcParam, uint32_t *samplesPerFrame);
+
+static const char* LHDC_ENCODE_NAME = "lhdcv5BT_encode";
+typedef int32_t (*tLHDC_ENCODE)(HANDLE_LHDCV5_BT hLhdcParam,
+    void *pInPcm, uint32_t pcmBytes, uint8_t *pOutBuf, uint32_t outBufBytes,
+    uint32_t *pOutByte, uint32_t *pOut_frames);
+
+#ifdef LHDC_LOSSLESS_RAW_SUPPORT
+static const char* LHDC_SET_LOSSLESS_RAW_ENABLE = "lhdcv5BT_set_lossless_raw_enable";
+typedef int32_t (*tLHDC_SET_LOSSLESS_RAW_ENABLE)(HANDLE_LHDCV5_BT hLhdcParam, uint32_t enabled);
+#endif
+
+static tLHDC_GET_HANDLE lhdc_get_handle;
+static tLHDC_FREE_HANDLE lhdc_free_handle;
+static tLHDC_GET_BITRATE lhdc_get_bitrate;
+static tLHDC_SET_BITRATE lhdc_set_bitrate;
+static tLHDC_SET_MAX_BITRATE lhdc_set_max_bitrate;
+static tLHDC_SET_MIN_BITRATE lhdc_set_min_bitrate;
+static tLHDC_AUTO_ADJUST_BITRATE lhdc_auto_adjust_bitrate;
+static tLHDC_SET_EXT_FUNC lhdc_set_ext_func;
+static tLHDC_INIT_ENCODER lhdc_init_encoder;
+static tLHDC_GET_BLOCK_SIZE lhdc_get_block_size;
+static tLHDC_ENCODE lhdc_encode_func;
+#ifdef LHDC_LOSSLESS_RAW_SUPPORT
+static tLHDC_SET_LOSSLESS_RAW_ENABLE lhdc_set_lossless_raw_enable;
+#endif
+
+// A2DP LHDC encoder interval in milliseconds
+#define A2DP_LHDC_ENCODER_SHORT_INTERVAL_MS 10
+#define A2DP_LHDC_ENCODER_INTERVAL_MS 20
+
+// offset
+#if (BTA_AV_CO_CP_SCMS_T == TRUE)
+#define A2DP_LHDC_OFFSET (AVDT_MEDIA_OFFSET + A2DP_LHDC_MPL_HDR_LEN + 1)
+#else
+#define A2DP_LHDC_OFFSET (AVDT_MEDIA_OFFSET + A2DP_LHDC_MPL_HDR_LEN)
+#endif
+
+typedef struct {
+  tA2DP_SAMPLE_RATE sample_rate;
+  uint32_t bits_per_sample;
+  uint32_t quality_mode_index;
+  uint32_t pcm_fmt;
+  uint32_t max_target_bitrate;
+  uint32_t min_target_bitrate;
+  uint8_t isLLEnabled;
+  uint8_t isLLessEnabled;
+#ifdef LHDC_LOSSLESS_RAW_SUPPORT
+  uint8_t isLLessRawEnabled;
+#endif
+} tA2DP_LHDCV5_ENCODER_PARAMS;
+
+typedef struct {
+  uint32_t counter;
+  uint32_t bytes_per_tick; /* pcm bytes read each media task tick */
+  uint64_t last_frame_us;
+} tA2DP_LHDCV5_FEEDING_STATE;
+
+typedef struct {
+  uint64_t session_start_us;
+
+  uint32_t media_read_total_expected_packets;
+  uint32_t media_read_total_expected_reads_count;
+  uint32_t media_read_total_expected_read_bytes;
+
+  uint32_t media_read_total_dropped_packets;
+  uint32_t media_read_total_actual_reads_count;
+  uint32_t media_read_total_actual_read_bytes;
+} a2dp_lhdcv5_encoder_stats_t;
+
+typedef struct {
+  a2dp_source_read_callback_t read_callback;
+  a2dp_source_enqueue_callback_t enqueue_callback;
+  uint32_t TxAaMtuSize;
+  uint32_t TxQueueLength;
+
+  bool use_SCMS_T;
+  bool is_peer_edr;          // True if the peer device supports EDR
+  bool peer_supports_3mbps;  // True if the peer device supports 3Mbps EDR
+  uint16_t peer_mtu;         // MTU of the A2DP peer
+  uint32_t timestamp;        // Timestamp for the A2DP frames
+
+  HANDLE_LHDCV5_BT lhdc_handle;
+  bool has_lhdc_handle;  // True if lhdc_handle is valid
+
+  tA2DP_FEEDING_PARAMS feeding_params;
+  tA2DP_LHDCV5_ENCODER_PARAMS lhdc_encoder_params;
+  tA2DP_LHDCV5_FEEDING_STATE lhdc_feeding_state;
+
+  a2dp_lhdcv5_encoder_stats_t stats;
+  uint32_t buf_seq;
+  uint32_t bytes_read;
+} tA2DP_LHDCV5_ENCODER_CB;
+
+// debug flag for dump PCM to file
+//#define _V5ENC_REC_FILE_
+#if defined(_V5ENC_REC_FILE_)
+#define V5ENC_RAW_NAME "/sdcard/Download/lhdcv5.raw"
+#define V5ENC_PCM_NAME     "/sdcard/Download/sourcev5.pcm"
+static FILE  *recFile = NULL;
+static FILE *pcmFile = NULL;
+#endif
+
+static tA2DP_LHDCV5_ENCODER_CB a2dp_lhdc_encoder_cb;
+
+static void a2dp_vendor_lhdcv5_encoder_update(uint16_t peer_mtu,
+    A2dpCodecConfig* a2dp_codec_config,
+    bool* p_restart_input,
+    bool* p_restart_output,
+    bool* p_config_updated);
+
+static void a2dp_lhdcv5_get_num_frame_iteration(uint8_t* num_of_iterations,
+    uint8_t* num_of_frames,
+    uint64_t timestamp_us);
+
+static void a2dp_lhdcV5_encode_frames(uint8_t nb_frame);
+
+static bool a2dp_lhdcv5_read_feeding(uint8_t* read_buffer, uint32_t *bytes_read);
+
+static std::string quality_mode_index_to_name(uint32_t quality_mode_index);
+
+
+static void* load_func(const char* func_name) {
+  if(!func_name) return NULL;
+
+  void* func_ptr = dlsym(lhdc_encoder_lib_handle, func_name);
+  if (func_ptr == NULL) {
+    log::error(
+        ": cannot find function '{}' in the encoder library: {}",
+         func_name, dlerror());
+    if (!A2DP_VendorUnloadEncoderLhdcV5()) {
+      log::error( ": unload encoder error");
+    }
+    return nullptr;
+  }
+  return func_ptr;
+}
+
+bool A2DP_VendorLoadEncoderLhdcV5(void) {
+  if (lhdc_encoder_lib_handle != nullptr) return true;  // Already loaded
+
+  // Initialize the control block
+  memset(&a2dp_lhdc_encoder_cb, 0, sizeof(a2dp_lhdc_encoder_cb));
+
+  // Open the encoder library
+  lhdc_encoder_lib_handle = dlopen(LHDC_ENCODER_LIB_NAME, RTLD_NOW);
+  if (lhdc_encoder_lib_handle == nullptr) {
+    log::error( ": cannot open LHDC encoder library : {}",
+        LHDC_ENCODER_LIB_NAME, dlerror());
+    return false;
+  }
+
+  lhdc_get_handle = nullptr;
+  lhdc_free_handle = nullptr;
+  lhdc_get_bitrate = nullptr;
+  lhdc_set_bitrate = nullptr;
+  lhdc_set_max_bitrate = nullptr;
+  lhdc_set_min_bitrate = nullptr;
+  lhdc_auto_adjust_bitrate = nullptr;
+  lhdc_set_ext_func = nullptr;
+  lhdc_init_encoder = nullptr;
+  lhdc_get_block_size =nullptr;
+  lhdc_encode_func = nullptr;
+#ifdef LHDC_LOSSLESS_RAW_SUPPORT
+  lhdc_set_lossless_raw_enable = nullptr;
+#endif
+
+  // Load all APIs
+  lhdc_get_handle = (tLHDC_GET_HANDLE)load_func(LHDC_GET_HANDLE_NAME);
+  if (lhdc_get_handle == nullptr) return false;
+  lhdc_free_handle = (tLHDC_FREE_HANDLE)load_func(LHDC_FREE_HANDLE_NAME);
+  if (lhdc_free_handle == nullptr) return false;
+  lhdc_get_bitrate = (tLHDC_GET_BITRATE)load_func(LHDC_GET_BITRATE_NAME);
+  if (lhdc_get_bitrate == nullptr) return false;
+  lhdc_set_bitrate = (tLHDC_SET_BITRATE)load_func(LHDC_SET_BITRATE_NAME);
+  if (lhdc_set_bitrate == nullptr) return false;
+  lhdc_set_max_bitrate = (tLHDC_SET_MAX_BITRATE)load_func(LHDC_SET_MAX_BITRATE_NAME);
+  if (lhdc_set_max_bitrate == nullptr) return false;
+  lhdc_set_min_bitrate = (tLHDC_SET_MIN_BITRATE)load_func(LHDC_SET_MIN_BITRATE_NAME);
+  if (lhdc_set_min_bitrate == nullptr) return false;
+  lhdc_auto_adjust_bitrate = (tLHDC_AUTO_ADJUST_BITRATE)load_func(LHDC_AUTO_ADJUST_BITRATE_NAME);
+  if (lhdc_auto_adjust_bitrate == nullptr) return false;
+  lhdc_set_ext_func = (tLHDC_SET_EXT_FUNC)load_func(LHDC_SET_EXT_FUNC);
+  if (lhdc_set_ext_func == nullptr) return false;
+  lhdc_init_encoder = (tLHDC_INIT_ENCODER)load_func(LHDC_INIT_ENCODER_NAME);
+  if (lhdc_init_encoder == nullptr) return false;
+  lhdc_get_block_size = (tLHDC_GET_BLOCK_SIZE)load_func(LHDC_GET_BLOCK_SIZE);
+  if (lhdc_get_block_size == nullptr) return false;
+  lhdc_encode_func = (tLHDC_ENCODE)load_func(LHDC_ENCODE_NAME);
+  if (lhdc_encode_func == nullptr) return false;
+#ifdef LHDC_LOSSLESS_RAW_SUPPORT
+  lhdc_set_lossless_raw_enable = (tLHDC_SET_LOSSLESS_RAW_ENABLE)load_func(LHDC_SET_LOSSLESS_RAW_ENABLE);
+  if (lhdc_set_lossless_raw_enable == nullptr) return false;
+#endif
+
+  return true;
+}
+
+bool A2DP_VendorUnloadEncoderLhdcV5(void) {
+  if (lhdc_encoder_lib_handle == nullptr) return true;  // Already unload
+
+  // Cleanup any LHDC-related state
+  log::info( ": has_lhdc_handle {}",
+       a2dp_lhdc_encoder_cb.has_lhdc_handle);
+
+  if (a2dp_lhdc_encoder_cb.has_lhdc_handle && lhdc_free_handle != nullptr) {
+    int32_t ret = lhdc_free_handle(a2dp_lhdc_encoder_cb.lhdc_handle);
+    if (ret < 0) {
+      log::error( ": free handle error {}",  ret);
+      return false;
+    }
+  } else {
+    log::error( ": unload encoder error");
+    return false;
+  }
+
+  memset(&a2dp_lhdc_encoder_cb, 0, sizeof(a2dp_lhdc_encoder_cb));
+
+  lhdc_get_handle = nullptr;
+  lhdc_free_handle = nullptr;
+  lhdc_get_bitrate = nullptr;
+  lhdc_set_bitrate = nullptr;
+  lhdc_set_max_bitrate = nullptr;
+  lhdc_set_min_bitrate = nullptr;
+  lhdc_auto_adjust_bitrate = nullptr;
+  lhdc_set_ext_func = nullptr;
+  lhdc_init_encoder = nullptr;
+  lhdc_get_block_size =nullptr;
+  lhdc_encode_func = nullptr;
+#ifdef LHDC_LOSSLESS_RAW_SUPPORT
+  lhdc_set_lossless_raw_enable = nullptr;
+#endif
+
+  dlclose(lhdc_encoder_lib_handle);
+  lhdc_encoder_lib_handle = nullptr;
+
+  return true;
+}
+
+//tA2DP_ENCODER_INTERFACE::(encoder_init)
+void a2dp_vendor_lhdcv5_encoder_init(
+    const tA2DP_ENCODER_INIT_PEER_PARAMS* p_peer_params,
+    A2dpCodecConfig* a2dp_codec_config,
+    a2dp_source_read_callback_t read_callback,
+    a2dp_source_enqueue_callback_t enqueue_callback) {
+
+  if (p_peer_params == nullptr || a2dp_codec_config == nullptr ||
+      read_callback == nullptr || enqueue_callback == nullptr) {
+    log::error( ": null input");
+    return;
+  }
+
+  if (a2dp_lhdc_encoder_cb.has_lhdc_handle) {
+    int32_t ret = lhdc_free_handle(a2dp_lhdc_encoder_cb.lhdc_handle);
+    if (ret < 0) {
+      log::error( ": free handle error {}",  ret);
+      return;
+    }
+  }
+
+  memset(&a2dp_lhdc_encoder_cb, 0, sizeof(a2dp_lhdc_encoder_cb));
+
+  a2dp_lhdc_encoder_cb.stats.session_start_us = bluetooth::common::time_get_os_boottime_us();
+
+  a2dp_lhdc_encoder_cb.read_callback = read_callback;
+  a2dp_lhdc_encoder_cb.enqueue_callback = enqueue_callback;
+  a2dp_lhdc_encoder_cb.is_peer_edr = p_peer_params->is_peer_edr;
+  a2dp_lhdc_encoder_cb.peer_supports_3mbps = p_peer_params->peer_supports_3mbps;
+  a2dp_lhdc_encoder_cb.peer_mtu = p_peer_params->peer_mtu;
+  a2dp_lhdc_encoder_cb.timestamp = 0;
+
+
+  a2dp_lhdc_encoder_cb.use_SCMS_T = false;  // TODO: should be a parameter
+#if (BTA_AV_CO_CP_SCMS_T == TRUE)
+  a2dp_lhdc_encoder_cb.use_SCMS_T = true;
+#endif
+
+  // NOTE: Ignore the restart_input / restart_output flags - this initization
+  // happens when the connection is (re)started.
+  bool restart_input = false;
+  bool restart_output = false;
+  bool config_updated = false;
+  a2dp_vendor_lhdcv5_encoder_update(a2dp_lhdc_encoder_cb.peer_mtu,
+      a2dp_codec_config, &restart_input,
+      &restart_output, &config_updated);
+}
+
+
+#if 0
+bool A2dpCodecConfigLhdcV5Source::updateEncoderUserConfig(
+    const tA2DP_ENCODER_INIT_PEER_PARAMS* p_peer_params, bool* p_restart_input,
+    bool* p_restart_output, bool* p_config_updated) {
+
+  if (p_peer_params == nullptr || p_restart_input == nullptr ||
+      p_restart_output == nullptr || p_config_updated == nullptr) {
+    log::error( ": null input");
+    return false;
+  }
+
+  if (a2dp_lhdc_encoder_cb.has_lhdc_handle) {
+    lhdc_free_handle(a2dp_lhdc_encoder_cb.lhdc_handle);
+    a2dp_lhdc_encoder_cb.has_lhdc_handle = false;
+    log::info(": clean lhdc handle");
+  }
+
+  a2dp_lhdc_encoder_cb.is_peer_edr = p_peer_params->is_peer_edr;
+  a2dp_lhdc_encoder_cb.peer_supports_3mbps = p_peer_params->peer_supports_3mbps;
+  a2dp_lhdc_encoder_cb.peer_mtu = p_peer_params->peer_mtu;
+  a2dp_lhdc_encoder_cb.timestamp = 0;
+
+  if (a2dp_lhdc_encoder_cb.peer_mtu == 0) {
+    log::error(
+        ": Cannot update the codec encoder for : "
+        "invalid peer MTU",
+         name().c_str());
+    return false;
+  }
+
+  a2dp_vendor_lhdcv5_encoder_update(a2dp_lhdc_encoder_cb.peer_mtu, this,
+      p_restart_input, p_restart_output,
+      p_config_updated);
+  return true;
+}
+#endif
+
+// wrap index mapping from bt stack to codec library
+static bool a2dp_vendor_lhdcv5_qualitymode_wrapper(uint32_t *out, uint32_t in) {
+  if (!out) return false;
+
+  switch(in) {
+  case A2DP_LHDC_QUALITY_ABR:
+    *out = LHDCV5_QUALITY_AUTO;
+    return true;
+  case A2DP_LHDC_QUALITY_HIGH1:
+    *out = LHDCV5_QUALITY_HIGH1;
+    return true;
+  case A2DP_LHDC_QUALITY_HIGH:
+    *out = LHDCV5_QUALITY_HIGH;
+    return true;
+  case A2DP_LHDC_QUALITY_MID:
+    *out = LHDCV5_QUALITY_MID;
+    return true;
+  case A2DP_LHDC_QUALITY_LOW:
+    *out = LHDCV5_QUALITY_LOW;
+    return true;
+  case A2DP_LHDC_QUALITY_LOW4:
+    *out = LHDCV5_QUALITY_LOW4;
+    return true;
+  case A2DP_LHDC_QUALITY_LOW3:
+    *out = LHDCV5_QUALITY_LOW3;
+    return true;
+  case A2DP_LHDC_QUALITY_LOW2:
+    *out = LHDCV5_QUALITY_LOW2;
+    return true;
+  case A2DP_LHDC_QUALITY_LOW1:
+    *out = LHDCV5_QUALITY_LOW1;
+    return true;
+  case A2DP_LHDC_QUALITY_LOW0:
+    *out = LHDCV5_QUALITY_LOW0;
+    return true;
+  }
+
+  return false;
+}
+
+
+// Update the A2DP LHDC encoder.
+// |peer_mtu| is the peer MTU.
+// |a2dp_codec_config| is the A2DP codec to use for the update.
+static void a2dp_vendor_lhdcv5_encoder_update(uint16_t peer_mtu,
+    A2dpCodecConfig* a2dp_codec_config,
+    bool* p_restart_input,
+    bool* p_restart_output,
+    bool* p_config_updated) {
+
+  tA2DP_LHDCV5_ENCODER_PARAMS* p_encoder_params =
+      &a2dp_lhdc_encoder_cb.lhdc_encoder_params;
+  uint8_t codec_info[AVDT_CODEC_SIZE];
+  uint32_t verCode = 0;
+  int32_t lib_ret = 0;
+  uint8_t ret_value8 = 0;
+  uint32_t mtu_size = 0;
+  uint32_t max_mtu_len = 0;
+  uint32_t newValue_bt = 0, newValue_lib = 0;
+  tA2DP_FEEDING_PARAMS* p_feeding_params;
+
+  const uint8_t *p_codec_info;
+
+  *p_restart_input = false;
+  *p_restart_output = false;
+  *p_config_updated = false;
+
+  if (!a2dp_codec_config->copyOutOtaCodecConfig(codec_info)) {
+    log::error(
+        ": Cannot update the codec encoder for : {}"
+        "invalid codec config",
+         a2dp_codec_config->name().c_str());
+    return;
+  }
+  p_codec_info = codec_info;
+
+  btav_a2dp_codec_config_t codec_config = a2dp_codec_config->getCodecConfig();
+
+  // get version
+  if (!A2DP_VendorGetVersionLhdcV5(&verCode, p_codec_info)) {
+    log::error( ": get version error!");
+    goto fail;
+  }
+  log::info( ": get version: {}" ,  verCode);
+
+  // get new handle
+  if (!a2dp_lhdc_encoder_cb.has_lhdc_handle) {
+    a2dp_lhdc_encoder_cb.lhdc_handle = nullptr;
+    lib_ret = lhdc_get_handle(verCode, &a2dp_lhdc_encoder_cb.lhdc_handle);
+    if (lib_ret != LHDCV5_FRET_SUCCESS) {
+      log::error( ": (lib_ret) lhdc_get_handle error {}",  lib_ret);
+      goto fail;
+    }
+
+    if (a2dp_lhdc_encoder_cb.lhdc_handle == nullptr) {
+      log::error( ": Cannot get LHDC encoder handle");
+      goto fail;
+    }
+    a2dp_lhdc_encoder_cb.has_lhdc_handle = true;
+  }
+  log::info( ": lhdc handle addr = {}",  a2dp_lhdc_encoder_cb.lhdc_handle);
+
+  //
+  // setup feeding parameters for encoder feeding process
+  //
+  p_feeding_params = &a2dp_lhdc_encoder_cb.feeding_params;
+  // sample rate (uint32_t)
+  p_feeding_params->sample_rate = A2DP_VendorGetTrackSampleRateLhdcV5(p_codec_info);
+  if (p_feeding_params->sample_rate < 0) {
+    log::error( ": get track sample rate error");
+    goto fail;
+  }
+
+  // bit per sample (uint8_t)
+  p_feeding_params->bits_per_sample = A2DP_VendorGetTrackBitsPerSampleLhdcV5(p_codec_info);
+  if (p_feeding_params->bits_per_sample < 0) {
+    log::error( ": get bit per sample error");
+    goto fail;
+  }
+
+  //channel count (uint8_t)
+  p_feeding_params->channel_count = A2DP_VendorGetTrackChannelCountLhdcV5(p_codec_info);
+  if (p_feeding_params->channel_count < 0) {
+    log::error( ": get channel count error");
+    goto fail;
+  }
+  log::info( ": (feeding param) sample_rate={} bits_per_sample={} channel_count={}",
+       p_feeding_params->sample_rate,
+      p_feeding_params->bits_per_sample,
+      p_feeding_params->channel_count);
+
+  //
+  // setup encoder parameters for configuring encoder
+  //
+  // sample rate tA2DP_SAMPLE_RATE(uint32_t)
+  p_encoder_params->sample_rate = a2dp_lhdc_encoder_cb.feeding_params.sample_rate;
+
+  // default mtu size (uint32_t)
+  mtu_size = (BT_DEFAULT_BUFFER_SIZE - A2DP_LHDC_OFFSET - sizeof(BT_HDR));
+  // allowed mtu size (uint32_t)
+  a2dp_lhdc_encoder_cb.TxAaMtuSize = (mtu_size < peer_mtu) ? mtu_size : (uint32_t)peer_mtu;
+  // real mtu size (uint32_t)
+#if (BTA_AV_CO_CP_SCMS_T == TRUE)
+  max_mtu_len = (uint32_t)( a2dp_lhdc_encoder_cb.TxAaMtuSize - A2DP_LHDC_MPL_HDR_LEN - 1);
+#else
+  max_mtu_len = (uint32_t)( a2dp_lhdc_encoder_cb.TxAaMtuSize - A2DP_LHDC_MPL_HDR_LEN);
+#endif
+
+  // max target bit rate
+  if (!A2DP_VendorGetMaxBitRateLhdcV5(&newValue_bt, p_codec_info) ) {
+    log::error( ": get max_target_bitrate error");
+    goto fail;
+  }
+  if (!a2dp_vendor_lhdcv5_qualitymode_wrapper(&newValue_lib, newValue_bt)) {
+    log::error( ": wrap MBR qualiity mode error");
+    goto fail;
+  }
+  p_encoder_params->max_target_bitrate = newValue_lib;
+
+  // min target bit rate
+  if (!A2DP_VendorGetMinBitRateLhdcV5(&newValue_bt, p_codec_info) ) {
+    log::error( ": get min_target_bitrate error");
+    goto fail;
+  }
+  if (!a2dp_vendor_lhdcv5_qualitymode_wrapper(&newValue_lib, newValue_bt)) {
+    log::error( ": wrap mBR qualiity mode error");
+    goto fail;
+  }
+  p_encoder_params->min_target_bitrate = newValue_lib;
+
+  // Low latency mode
+  if (!A2DP_VendorHasLLFlagLhdcV5(&(p_encoder_params->isLLEnabled), p_codec_info)){
+    log::error( ": get Low latency enable error");
+    goto fail;
+  }
+
+  // Lossless mode
+  if (!A2DP_VendorHasLLessFlagLhdcV5(&(p_encoder_params->isLLessEnabled), p_codec_info)){
+    log::error( ": get Lossless enable error");
+    goto fail;
+  }
+
+#ifdef LHDC_LOSSLESS_RAW_SUPPORT
+  // Lossless raw mode
+  if (!A2DP_VendorHasLLessRawFlagLhdcV5(&(p_encoder_params->isLLessRawEnabled), p_codec_info)){
+    log::error( ": get lossless raw enable error");
+    goto fail;
+  }
+#endif
+
+  // bit per sample
+  switch((int)p_feeding_params->bits_per_sample) {
+  case 16:
+    p_encoder_params->pcm_fmt = LHDCV5BT_SMPL_FMT_S16;
+    break;
+  case 24:
+    p_encoder_params->pcm_fmt = LHDCV5BT_SMPL_FMT_S24;
+    break;
+  case 32:
+    p_encoder_params->pcm_fmt = LHDCV5BT_SMPL_FMT_S32;
+    break;
+  }
+
+  // quality mode
+  if ((codec_config.codec_specific_1 & A2DP_LHDC_VENDOR_CMD_MASK) == A2DP_LHDC_QUALITY_MAGIC_NUM) {
+    newValue_bt = (codec_config.codec_specific_1 & A2DP_LHDC_QUALITY_MASK);
+    if (!a2dp_vendor_lhdcv5_qualitymode_wrapper(&newValue_lib, newValue_bt)) {
+      log::error( ": wrap quality mode error");
+      goto fail;
+    }
+
+    if (newValue_lib != p_encoder_params->quality_mode_index) {
+      p_encoder_params->quality_mode_index = newValue_lib;
+    }
+  } else {
+    //give default: ABR
+    newValue_bt = A2DP_LHDC_QUALITY_ABR;
+      if (!a2dp_vendor_lhdcv5_qualitymode_wrapper(&newValue_lib, newValue_bt)) {
+        log::error( ": (default) wrap quality mode error");
+        goto fail;
+      }
+      p_encoder_params->quality_mode_index = newValue_lib;
+      }
+
+  // when in lossless, set max bit rate to current max bitrate stage
+  if (p_encoder_params->isLLessEnabled == 1) {
+    p_encoder_params->max_target_bitrate = LHDCV5_QUALITY_MAX_BITRATE;
+    //log::info( ": set max target bitrate to unlimit when lossless enabled {}", 
+      //  LHDCV5_QUALITY_MAX_BITRATE);
+  }
+
+  log::info( ": (encode param) sample_rate={} pcm_fmt={} peer_mtu={} mtu={} "
+      "maxBitRateIdx={} minBitRateIdx={} isLLEnabled={} isLLessEnabled={} quality_mode={}", 
+      p_encoder_params->sample_rate,                //44100, 48000, ...
+      p_encoder_params->pcm_fmt,                    //16, 24, 32...
+      peer_mtu, max_mtu_len,                        //number of bytes
+      p_encoder_params->max_target_bitrate,         //index
+      p_encoder_params->min_target_bitrate,         //index
+      p_encoder_params->isLLEnabled,
+      p_encoder_params->isLLessEnabled,
+      quality_mode_index_to_name(p_encoder_params->quality_mode_index).c_str(),
+      p_encoder_params->quality_mode_index);
+
+  // Initialize the encoder.
+  // NOTE: MTU in the initialization must include the AVDT media header size.
+  lib_ret = lhdc_init_encoder(
+      a2dp_lhdc_encoder_cb.lhdc_handle,
+      p_encoder_params->sample_rate,
+      p_encoder_params->pcm_fmt,
+      p_encoder_params->quality_mode_index,
+      max_mtu_len,
+      (uint32_t)a2dp_vendor_lhdcv5_get_encoder_interval_ms(),
+      p_encoder_params->isLLessEnabled);
+
+  if (lib_ret != LHDCV5_FRET_SUCCESS) {
+    log::error( ": (lib_ret) lhdc_init_encoder {}",  lib_ret);
+    goto fail;
+  }
+  // setup after encoder initialized
+  lib_ret = lhdc_set_max_bitrate(a2dp_lhdc_encoder_cb.lhdc_handle, p_encoder_params->max_target_bitrate);
+  if (lib_ret != LHDCV5_FRET_SUCCESS) {
+    log::error( ": (lib_ret) set_max_bitrate {}",  lib_ret);
+    goto fail;
+  }
+  lib_ret = lhdc_set_min_bitrate(a2dp_lhdc_encoder_cb.lhdc_handle, p_encoder_params->min_target_bitrate);
+  if (lib_ret != LHDCV5_FRET_SUCCESS) {
+    log::error( ": (lib_ret) set_min_bitrate {}",  lib_ret);
+    goto fail;
+  }
+  lib_ret = lhdc_set_bitrate(a2dp_lhdc_encoder_cb.lhdc_handle, p_encoder_params->quality_mode_index);
+  if (lib_ret != LHDCV5_FRET_SUCCESS) {
+    log::error( ": (lib_ret) set_bitrate {}",  lib_ret);
+    goto fail;
+  }
+
+  // setup special features
+#ifdef LHDC_LOSSLESS_RAW_SUPPORT
+  if (p_encoder_params->isLLessRawEnabled == 1) {
+    // Lossless Raw is enabled (MUST called before lhdc_set_ext_func())
+    lib_ret = lhdc_set_lossless_raw_enable(a2dp_lhdc_encoder_cb.lhdc_handle,
+        p_encoder_params->isLLessRawEnabled);
+    if (lib_ret != LHDCV5_FRET_SUCCESS) {
+      log::error( ": (lib_ret) lhdc_set_lossless_raw_enable error {}",  lib_ret);
+      goto fail;
+    }
+    log::info( ": set lossless raw enable {}",  p_encoder_params->isLLessRawEnabled);
+  }
+#endif
+
+  // features can not be setup when enabling:
+  //  lossless raw mode or lossless 96KHz
+#ifdef LHDC_LOSSLESS_RAW_SUPPORT
+  if ( p_encoder_params->isLLessRawEnabled == 1 ||
+      (p_encoder_params->isLLessEnabled == 1 && p_encoder_params->sample_rate == 96000)) {
+#else
+  if (p_encoder_params->isLLessEnabled == 1 && p_encoder_params->sample_rate == 96000) {
+#endif
+
+  } else {
+    if (A2DP_VendorHasARFlagLhdcV5(&ret_value8, p_codec_info)) {
+      lib_ret = lhdc_set_ext_func(a2dp_lhdc_encoder_cb.lhdc_handle, LHDCV5_EXT_FUNC_AR, (bool)ret_value8, NULL, 0);
+      if (lib_ret != LHDCV5_FRET_SUCCESS) {
+       // log::error( ": (lib_ret) lhdc_set_ext_func AR(0x{}) {}",  LHDCV5_EXT_FUNC_AR, lib_ret);
+        goto fail;
+      }
+    }
+
+    if (A2DP_VendorHasJASFlagLhdcV5(&ret_value8, p_codec_info)) {
+      lib_ret = lhdc_set_ext_func(a2dp_lhdc_encoder_cb.lhdc_handle, LHDCV5_EXT_FUNC_JAS, (bool)ret_value8, NULL, 0);
+      if (lib_ret != LHDCV5_FRET_SUCCESS) {
+        //log::error( ": (lib_ret) lhdc_set_ext_func JAS(0x{}) {}",  LHDCV5_EXT_FUNC_JAS, lib_ret);
+        goto fail;
+      }
+    }
+  }
+
+#ifdef MCPS_FRAME_ENCODE
+  mcpsStat_all_enc_us_lhdcv5 = 0;
+  mcpsStat_all_enc_frm_lhdcv5 = 0;
+  mcpsStat_time_dur_cnt_lhdcv5 = 0;
+  mcpsStat_enc_frm_per_sec_lhdcv5 = 0;
+  mcpsStat_all_time_dur_ms_lhdcv5 = 0;
+#endif
+
+#if defined(_V5ENC_REC_FILE_)
+  if (recFile == NULL) {
+    recFile = fopen(V5ENC_RAW_NAME,"wb");
+    log::info( ": create recode file = {}",  recFile);
+  }
+  if (pcmFile == NULL) {
+    pcmFile = fopen(V5ENC_PCM_NAME,"wb");
+    log::info( ": create recode file = {}",  pcmFile);
+  }
+#endif
+  return;
+
+  fail:
+  if (a2dp_lhdc_encoder_cb.lhdc_handle) {
+    a2dp_vendor_lhdcv5_encoder_cleanup();
+  }
+}
+
+//tA2DP_ENCODER_INTERFACE::(encoder_cleanup)
+void a2dp_vendor_lhdcv5_encoder_cleanup(void) {
+  if (a2dp_lhdc_encoder_cb.has_lhdc_handle && a2dp_lhdc_encoder_cb.lhdc_handle) {
+    int32_t lib_ret = lhdc_free_handle(a2dp_lhdc_encoder_cb.lhdc_handle);
+    if (lib_ret != LHDCV5_FRET_SUCCESS) {
+      log::error( ": free handle error {}",  lib_ret);
+      return;
+    }
+  } else {
+    log::info( ": nothing to clean");
+    return;
+  }
+  memset(&a2dp_lhdc_encoder_cb, 0, sizeof(a2dp_lhdc_encoder_cb));
+
+#if defined(_V5ENC_REC_FILE_)
+  if (recFile != NULL) {
+    fclose(recFile);
+    recFile = NULL;
+    remove(V5ENC_RAW_NAME);
+  }
+  if (pcmFile != NULL) {
+    fclose(pcmFile);
+    pcmFile = NULL;
+    remove(V5ENC_PCM_NAME);
+  }
+#endif
+
+  log::info( ": encoder cleaned up");
+}
+
+//tA2DP_ENCODER_INTERFACE::(feeding_reset)
+void a2dp_vendor_lhdcv5_feeding_reset(void) {
+  /* By default, just clear the entire state */
+  memset(&a2dp_lhdc_encoder_cb.lhdc_feeding_state, 0,
+      sizeof(a2dp_lhdc_encoder_cb.lhdc_feeding_state));
+
+  uint32_t encoder_interval = (uint32_t)a2dp_vendor_lhdcv5_get_encoder_interval_ms();
+  a2dp_lhdc_encoder_cb.lhdc_feeding_state.bytes_per_tick =
+      (a2dp_lhdc_encoder_cb.feeding_params.sample_rate *
+          a2dp_lhdc_encoder_cb.feeding_params.bits_per_sample / 8 *
+          a2dp_lhdc_encoder_cb.feeding_params.channel_count *
+          encoder_interval) / 1000;
+  a2dp_lhdc_encoder_cb.buf_seq = 0;
+  a2dp_lhdc_encoder_cb.bytes_read = 0;
+  a2dp_lhdc_encoder_cb.lhdc_feeding_state.last_frame_us = 0;
+
+  tA2DP_LHDCV5_ENCODER_PARAMS* p_encoder_params = &a2dp_lhdc_encoder_cb.lhdc_encoder_params;
+  if (p_encoder_params->quality_mode_index == LHDCV5_QUALITY_AUTO) {
+    if (lhdc_set_bitrate != NULL && a2dp_lhdc_encoder_cb.has_lhdc_handle) {
+      lhdc_set_bitrate(a2dp_lhdc_encoder_cb.lhdc_handle, LHDCV5_QUALITY_CTRL_RESET_ABR);
+    }
+  }
+
+#ifdef MCPS_FRAME_ENCODE
+  mcpsStat_all_enc_us_lhdcv5 = 0;
+  mcpsStat_all_enc_frm_lhdcv5 = 0;
+  mcpsStat_time_dur_cnt_lhdcv5 = 0;
+  mcpsStat_enc_frm_per_sec_lhdcv5 = 0;
+  mcpsStat_all_time_dur_ms_lhdcv5 = 0;
+#endif
+
+  log::info( ": PCM bytes per tick {}, reset timestamp", 
+      a2dp_lhdc_encoder_cb.lhdc_feeding_state.bytes_per_tick);
+}
+
+//tA2DP_ENCODER_INTERFACE::(feeding_flush)
+void a2dp_vendor_lhdcv5_feeding_flush(void) {
+  a2dp_lhdc_encoder_cb.lhdc_feeding_state.counter = 0;
+  log::info( "");
+}
+
+//tA2DP_ENCODER_INTERFACE::(get_encoder_interval_ms)
+uint64_t a2dp_vendor_lhdcv5_get_encoder_interval_ms(void) {
+  log::info( ": A2DP_LHDC_ENCODER_INTERVAL_MS {}",  
+      a2dp_lhdc_encoder_cb.lhdc_encoder_params.isLLEnabled ? A2DP_LHDC_ENCODER_SHORT_INTERVAL_MS : A2DP_LHDC_ENCODER_INTERVAL_MS);
+
+  if (a2dp_lhdc_encoder_cb.lhdc_encoder_params.isLLEnabled){
+    return A2DP_LHDC_ENCODER_SHORT_INTERVAL_MS;
+  }else{
+    return A2DP_LHDC_ENCODER_INTERVAL_MS;
+  }
+}
+
+int a2dp_vendor_lhdcv5_get_effective_frame_size() {
+  return a2dp_lhdc_encoder_cb.TxAaMtuSize;
+}
+
+//tA2DP_ENCODER_INTERFACE::(send_frames)
+void a2dp_vendor_lhdcv5_send_frames(uint64_t timestamp_us) {
+  uint8_t nb_frame = 0;
+  uint8_t nb_iterations = 0;
+
+  a2dp_lhdcv5_get_num_frame_iteration(&nb_iterations, &nb_frame, timestamp_us);
+  log::info( ": Sending {} frames per iteration, {} iterations",
+       nb_frame, nb_iterations);
+
+  if (nb_frame == 0) return;
+
+  for (uint8_t counter = 0; counter < nb_iterations; counter++) {
+    // Transcode frame and enqueue
+    a2dp_lhdcV5_encode_frames(nb_frame);
+  }
+}
+
+// Obtains the number of frames to send and number of iterations
+// to be used. |num_of_iterations| and |num_of_frames| parameters
+// are used as output param for returning the respective values.
+static void a2dp_lhdcv5_get_num_frame_iteration(uint8_t* num_of_iterations,
+    uint8_t* num_of_frames,
+    uint64_t timestamp_us) {
+
+  uint32_t result = 0;
+  uint8_t nof = 0;
+  uint8_t noi = 1;
+  uint32_t pcm_bytes_per_frame = 0;
+  uint32_t samples_per_frame = 0;
+  int32_t lib_ret = 0;
+
+  lib_ret = lhdc_get_block_size(a2dp_lhdc_encoder_cb.lhdc_handle, &samples_per_frame);
+  if (lib_ret != LHDCV5_FRET_SUCCESS) {
+    log::info( ": get block size error {}",  lib_ret);
+    return;
+  }
+
+  pcm_bytes_per_frame = samples_per_frame *
+      a2dp_lhdc_encoder_cb.feeding_params.channel_count *
+      a2dp_lhdc_encoder_cb.feeding_params.bits_per_sample / 8;
+
+  uint32_t encoder_interval = (uint32_t)a2dp_vendor_lhdcv5_get_encoder_interval_ms();
+  uint32_t us_this_tick = encoder_interval * 1000;
+  uint64_t now_us = timestamp_us;
+
+  // not the first time, calculate time offset
+  if (a2dp_lhdc_encoder_cb.lhdc_feeding_state.last_frame_us != 0) {
+    us_this_tick = (now_us - a2dp_lhdc_encoder_cb.lhdc_feeding_state.last_frame_us);
+  }
+  a2dp_lhdc_encoder_cb.lhdc_feeding_state.last_frame_us = now_us;
+
+  a2dp_lhdc_encoder_cb.lhdc_feeding_state.counter +=
+      a2dp_lhdc_encoder_cb.lhdc_feeding_state.bytes_per_tick * us_this_tick /
+      (encoder_interval * 1000);
+
+  result =
+      a2dp_lhdc_encoder_cb.lhdc_feeding_state.counter / pcm_bytes_per_frame;
+  a2dp_lhdc_encoder_cb.lhdc_feeding_state.counter -=
+      result * pcm_bytes_per_frame;
+  nof = result;
+
+  log::info( ": samples_per_frame={} pcm_bytes_per_frame={} nb_frame={}",
+       samples_per_frame, pcm_bytes_per_frame, nof);
+
+  *num_of_frames = nof;
+  *num_of_iterations = noi;
+}
+
+static BT_HDR *bt_buf_new( void) {
+  BT_HDR *p_buf = ( BT_HDR*)osi_malloc(BT_DEFAULT_BUFFER_SIZE);
+  if ( p_buf == NULL) {
+    // LeoKu(C): should not happen
+    log::error(  ": bt_buf_new failed!");
+    return NULL;
+  }
+
+  p_buf->offset = A2DP_LHDC_OFFSET;
+  p_buf->len = 0;
+  p_buf->layer_specific = 0;
+  return p_buf;
+}
+
+static void a2dp_lhdcV5_encode_frames(uint8_t nb_frame){
+  static float mtu_usage = 0;
+  static int mtu_usage_cnt = 0;
+  static uint64_t time_prev_ms = bluetooth::common::time_get_os_boottime_ms();
+  static uint32_t all_send_bytes = 0;
+  uint8_t read_buffer[LHDCV5_MAX_SAMPLE_FRAME * 2 * 4];
+  uint32_t samples_per_frame = 0;
+  uint32_t out_frames = 0;
+  uint8_t remain_nb_frame = nb_frame;
+  uint32_t written = 0;
+  uint32_t bytes_read = 0;
+  uint8_t *packet = nullptr;
+  BT_HDR *p_buf = nullptr;
+  int32_t lib_ret = 0;
+  uint32_t pcm_bytes_per_frame = 0;
+  uint32_t max_mtu_len = 0;
+
+  uint32_t written_frame = 0;
+  uint32_t temp_bytes_read = 0;
+
+#ifdef MCPS_FRAME_ENCODE
+  uint64_t time_prev_enc_us_2 = 0;
+  uint64_t time_aft_enc_us_2 = 0;
+#endif
+
+  lib_ret = lhdc_get_block_size(a2dp_lhdc_encoder_cb.lhdc_handle, &samples_per_frame);
+  if (lib_ret != LHDCV5_FRET_SUCCESS) {
+    log::error( ": (lib_ret) lhdc_get_block_size error {}",  lib_ret);
+    return;
+  }
+  pcm_bytes_per_frame = samples_per_frame *
+      a2dp_lhdc_encoder_cb.feeding_params.channel_count *
+      a2dp_lhdc_encoder_cb.feeding_params.bits_per_sample / 8;
+
+  if (pcm_bytes_per_frame > sizeof(read_buffer)) {
+    log::error( ": expected read size error");
+    return;
+  }
+
+  // check codec handle existed
+  if (!a2dp_lhdc_encoder_cb.has_lhdc_handle || !a2dp_lhdc_encoder_cb.lhdc_handle) {
+    log::error( ": encoder handle invalid error");
+    return;
+  }
+
+#if (BTA_AV_CO_CP_SCMS_T == TRUE)
+  max_mtu_len = ( uint32_t)( a2dp_lhdc_encoder_cb.TxAaMtuSize - A2DP_LHDC_MPL_HDR_LEN - 1);
+#else
+  max_mtu_len = ( uint32_t)( a2dp_lhdc_encoder_cb.TxAaMtuSize - A2DP_LHDC_MPL_HDR_LEN);
+#endif
+
+  while (nb_frame) {
+    // create a temp output buffer
+    if ((p_buf = bt_buf_new()) == NULL) {
+      log::error( ": create buf error");
+      return;
+    }
+
+    written_frame = 0;
+    do {
+      temp_bytes_read = 0;
+      // read from feeding buffer
+      if (a2dp_lhdcv5_read_feeding(read_buffer, &temp_bytes_read)) {
+        a2dp_lhdc_encoder_cb.bytes_read += temp_bytes_read;
+        packet = (uint8_t*)(p_buf + 1) + p_buf->offset + p_buf->len;
+
+#if defined(_V5ENC_REC_FILE_)
+        if (pcmFile != NULL) {
+          fwrite(read_buffer, sizeof(uint8_t), pcm_bytes_per_frame, pcmFile);
+        }
+#endif
+
+        log::info( ": nb_frame{} to encode...",  nb_frame);
+        // to encode
+
+#ifdef MCPS_FRAME_ENCODE
+        time_prev_enc_us_2 = bluetooth::common::time_get_os_boottime_us();
+#endif
+        lib_ret = lhdc_encode_func(a2dp_lhdc_encoder_cb.lhdc_handle,
+            read_buffer, temp_bytes_read,
+            packet, (BT_DEFAULT_BUFFER_SIZE-(p_buf->offset + p_buf->len + sizeof(BT_HDR))),
+            &written, &out_frames);
+
+        if (lib_ret != LHDCV5_FRET_SUCCESS) {
+          log::error( ": (lib_ret) lhdc_encode_func error {}",  lib_ret);
+          a2dp_lhdc_encoder_cb.stats.media_read_total_dropped_packets++;
+          osi_free(p_buf);
+          return;
+        }
+#ifdef MCPS_FRAME_ENCODE
+#if 0
+        // For old frame per packet mechanism
+        if (mcpsStat_time_dur_cnt_lhdcv5 > 0) { //begin after statistics initialized
+          if (out_frames > 0) {
+            time_aft_enc_us_2 = bluetooth::common::time_get_os_boottime_us();
+            mcpsStat_all_enc_us_lhdcv5 += (time_aft_enc_us_2 - time_prev_enc_us_2);
+            mcpsStat_all_enc_frm_lhdcv5 += out_frames;
+          }
+        }
+#else
+        // For new frame per packet mechanism
+        if (mcpsStat_time_dur_cnt_lhdcv5 > 0) { //begin after statistics initialized
+          time_aft_enc_us_2 = bluetooth::common::time_get_os_boottime_us();
+          mcpsStat_all_enc_us_lhdcv5 += (time_aft_enc_us_2 - time_prev_enc_us_2);
+          mcpsStat_all_enc_frm_lhdcv5 += 1;
+        }
+#endif
+#endif
+
+#if defined(_V5ENC_REC_FILE_)
+        if (recFile != NULL && written > 0) {
+          fwrite(packet, sizeof(uint8_t), written, recFile);
+        }
+#endif
+        log::info( ": nb_frame{} - written:{}, out_frames:{}", 
+            nb_frame, written, out_frames);
+        p_buf->len += written;
+        all_send_bytes += written;
+        nb_frame--;
+        written_frame += out_frames;  // added a frame to the buffer
+      } else {
+        log::info( ": nb_frame{} - underflow",  nb_frame);
+        a2dp_lhdc_encoder_cb.lhdc_feeding_state.counter +=
+            nb_frame * samples_per_frame *
+            a2dp_lhdc_encoder_cb.feeding_params.channel_count *
+            a2dp_lhdc_encoder_cb.feeding_params.bits_per_sample / 8;
+        // no more pcm to read
+        nb_frame = 0;
+      }
+    } while ((written == 0) && nb_frame);
+
+    if (p_buf->len) {
+      /*
+       * Timestamp of the media packet header represent the TS of the
+       * first frame, i.e the timestamp before including this frame.
+       */
+      p_buf->layer_specific = a2dp_lhdc_encoder_cb.buf_seq++;
+      p_buf->layer_specific <<= 8;
+      p_buf->layer_specific |= ((written_frame << A2DP_LHDC_HDR_NUM_SHIFT));
+
+      *( ( uint32_t*)( p_buf + 1)) = a2dp_lhdc_encoder_cb.timestamp;
+      log::info( ": Timestamp {}",  a2dp_lhdc_encoder_cb.timestamp);
+
+      a2dp_lhdc_encoder_cb.timestamp += (written_frame * samples_per_frame);
+
+      remain_nb_frame = nb_frame;
+      log::info( ": nb_frame{} - remain_nb_frame:{}",  (nb_frame+1), remain_nb_frame);
+
+      mtu_usage += ((float)p_buf->len) / max_mtu_len;
+      mtu_usage_cnt++;
+
+      log::info( ": Bytes read for pkt{}",  a2dp_lhdc_encoder_cb.bytes_read);
+      log::info( ": Output frames{} encoded pkt len{}",  written_frame, p_buf->len);
+      bytes_read = a2dp_lhdc_encoder_cb.bytes_read;
+      a2dp_lhdc_encoder_cb.bytes_read = 0;
+
+      if (!a2dp_lhdc_encoder_cb.enqueue_callback(p_buf, 1, bytes_read))
+        return;
+    } else {
+      log::info( ": free buffer len{}",  p_buf->len);
+      a2dp_lhdc_encoder_cb.stats.media_read_total_dropped_packets++;
+      osi_free(p_buf);
+    }
+  }
+
+  // for statistics
+  uint64_t time_now_ms = bluetooth::common::time_get_os_boottime_ms();
+  if (time_now_ms - time_prev_ms >= 1000 ) {
+#ifdef MCPS_FRAME_ENCODE
+    mcpsStat_time_dur_cnt_lhdcv5++;
+
+    if (mcpsStat_time_dur_cnt_lhdcv5 <= MCPS_FRAME_ENCODE_DUR) {  //how long we stop statistics
+      if (mcpsStat_time_dur_cnt_lhdcv5 <= 1) {
+        mcpsStat_all_time_dur_ms_lhdcv5 = 0;  //ignore previous uninitialized records
+      } else {
+        mcpsStat_all_time_dur_ms_lhdcv5 += (time_now_ms - time_prev_ms);
+      }
+
+      /*
+       * MCPS STATISTICS LOG:
+       *  [cnt:{} time_now_ms{}-time_prev_ms{}={} {}s]:
+       *    cnt       : the number of rounds
+       *    time_now_ms    : now system time point (ms)
+       *    time_prev_ms : previous system time point (ms)
+       *  [{} {} {} kbps]: sampleRate, bitDepth, Bitrate
+       *  frmPerTheSec: number of frames encoded in "this second"
+       *  avgFrmPerSec: so far, the average number of encoded frames per second
+       *  avgUsPerfrm:  so far, the average execution time(us) of each encoded frame
+       *  avgMCPS:  so far, the average MCPS
+       */
+      log::info( "[MCPS_STAT]: [cnt:{} time_now_ms{}-time_prev_ms{}={} {}s] [{} {} {} kbps] "
+          "frmPerTheSec{} avgFrmPerSec{} avgUsPerfrm:{}us, avgMCPS:{}",
+          (uint32_t)mcpsStat_time_dur_cnt_lhdcv5,
+          (uint32_t)time_now_ms,
+          (uint32_t)time_prev_ms,
+          (uint32_t)mcpsStat_all_time_dur_ms_lhdcv5,            //total elapsed time (in ms)
+          (float)mcpsStat_all_time_dur_ms_lhdcv5 / 1000,        //total elapsed time (in sec)
+          a2dp_lhdc_encoder_cb.feeding_params.sample_rate,      //current sample rate
+          a2dp_lhdc_encoder_cb.feeding_params.bits_per_sample,  //current bit depth
+          (all_send_bytes * 8) / 1000,                          //current bit rate
+
+          (uint32_t)(mcpsStat_all_enc_frm_lhdcv5 - mcpsStat_enc_frm_per_sec_lhdcv5),              // frmPerTheSec
+          ((float)mcpsStat_all_enc_frm_lhdcv5 / ((float)mcpsStat_all_time_dur_ms_lhdcv5 / 1000)), // avgFrmPerSec
+          ((float)mcpsStat_all_enc_us_lhdcv5 / (float)mcpsStat_all_enc_frm_lhdcv5),               // avgUsPerfrm
+
+          // avgMCPS = (avgUsPerfrm / STATIS_MILLION_UNIT) * CPU_Freq_MHz * avgFrmPerSec
+          (((float)mcpsStat_all_enc_us_lhdcv5 / (float)mcpsStat_all_enc_frm_lhdcv5) * STATIS_CPU_FREQ_MHZ *
+            ((float)mcpsStat_all_enc_frm_lhdcv5 / ((float)mcpsStat_all_time_dur_ms_lhdcv5 / 1000)) /
+            STATIS_MILLION_UNIT)
+          );
+    }
+    mcpsStat_enc_frm_per_sec_lhdcv5 = mcpsStat_all_enc_frm_lhdcv5;
+#endif
+    log::info( ": current data rate about {} kbps, packet usage {}%%", 
+        (all_send_bytes * 8) / 1000, (mtu_usage * 100)/mtu_usage_cnt);
+    all_send_bytes = 0;
+    mtu_usage_cnt = 0;
+    mtu_usage = 0;
+    time_prev_ms = time_now_ms;
+  }
+}
+
+static bool a2dp_lhdcv5_read_feeding(uint8_t* read_buffer, uint32_t *bytes_read) {
+  uint32_t read_size = 0;
+  uint32_t samples_per_frame = 0;
+  uint32_t bytes_per_sample =
+      a2dp_lhdc_encoder_cb.feeding_params.channel_count *
+      a2dp_lhdc_encoder_cb.feeding_params.bits_per_sample / 8;
+  uint32_t nb_byte_read;
+
+  if (read_buffer == nullptr || bytes_read == nullptr) {
+    log::error( ": null input");
+    return false;
+  }
+
+  int32_t lib_ret = lhdc_get_block_size(a2dp_lhdc_encoder_cb.lhdc_handle, &samples_per_frame);
+  if (lib_ret != LHDCV5_FRET_SUCCESS) {
+    log::info( ": (lib_ret) lhdc_get_block_size error {}",  lib_ret);
+    return false;
+  }
+  read_size = samples_per_frame * bytes_per_sample;
+
+  a2dp_lhdc_encoder_cb.stats.media_read_total_expected_reads_count++;
+  a2dp_lhdc_encoder_cb.stats.media_read_total_expected_read_bytes += read_size;
+
+  /* Read Data from UIPC channel */
+  nb_byte_read =
+      a2dp_lhdc_encoder_cb.read_callback(read_buffer, read_size);
+  log::info( ": expected read bytes {}, actual read bytes {}",
+       read_size, nb_byte_read);
+
+  //TODO: what to do if not alignment?
+  if ((nb_byte_read % bytes_per_sample) != 0) {
+    log::info( ": PCM data not alignment. The audio sample is shfit {} bytes!",
+         (nb_byte_read % bytes_per_sample));
+  }
+  a2dp_lhdc_encoder_cb.stats.media_read_total_actual_read_bytes += nb_byte_read;
+
+  // if actual read < want to read
+  if (nb_byte_read < read_size) {
+    if (nb_byte_read == 0) return false;
+
+    /* Fill the unfilled part of the read buffer with silence (0) */
+    memset(((uint8_t*)read_buffer) + nb_byte_read, 0, read_size - nb_byte_read);
+    nb_byte_read = read_size;
+  }
+  a2dp_lhdc_encoder_cb.stats.media_read_total_actual_reads_count++;
+  *bytes_read = nb_byte_read;
+
+  return true;
+}
+
+// library index mapping: quality mode index
+static std::string quality_mode_index_to_name(uint32_t quality_mode_index) {
+  switch (quality_mode_index) {
+  case LHDCV5_QUALITY_AUTO:
+    return "ABR";
+  case LHDCV5_QUALITY_HIGH1:
+    return "HIGH1_1000";
+  case LHDCV5_QUALITY_HIGH:
+    return "HIGH_900";
+  case LHDCV5_QUALITY_MID:
+    return "MID_500";
+  case LHDCV5_QUALITY_LOW:
+    return "LOW_400";
+  case LHDCV5_QUALITY_LOW4:
+    return "LOW_320";
+  case LHDCV5_QUALITY_LOW3:
+    return "LOW_256";
+  case LHDCV5_QUALITY_LOW2:
+    return "LOW_192";
+  case LHDCV5_QUALITY_LOW1:
+    return "LOW_160";
+  case LHDCV5_QUALITY_LOW0:
+    return "LOW_64";
+  default:
+    return "Unknown";
+  }
+}
+
+//tA2DP_ENCODER_INTERFACE::(set_transmit_queue_length)
+void a2dp_vendor_lhdcv5_set_transmit_queue_length(size_t transmit_queue_length) {
+  int32_t lib_ret = 0;
+
+  a2dp_lhdc_encoder_cb.TxQueueLength = transmit_queue_length;
+  tA2DP_LHDCV5_ENCODER_PARAMS* p_encoder_params = &a2dp_lhdc_encoder_cb.lhdc_encoder_params;
+
+  if (p_encoder_params->quality_mode_index == LHDCV5_QUALITY_AUTO) {
+    if (lhdc_auto_adjust_bitrate != NULL) {
+      lib_ret = lhdc_auto_adjust_bitrate(a2dp_lhdc_encoder_cb.lhdc_handle, (uint32_t)transmit_queue_length);
+      if (lib_ret != LHDCV5_FRET_SUCCESS){
+        log::error( ": (lib_ret) lhdc_auto_adjust_bitrate error {}",  lib_ret);
+      }
+    }
+  }
+}
+
+#if 0
+uint64_t A2dpCodecConfigLhdcV5Source::encoderIntervalMs() const {
+  return a2dp_vendor_lhdcv5_get_encoder_interval_ms();
+}
+#endif
+
+#if 0
+int A2dpCodecConfigLhdcV5Source::getEffectiveMtu() const {
+  return a2dp_lhdc_encoder_cb.TxAaMtuSize;
+}
+#endif
+
+void A2dpCodecConfigLhdcV5Source::debug_codec_dump(int fd) {
+  a2dp_lhdcv5_encoder_stats_t* stats = &a2dp_lhdc_encoder_cb.stats;
+  tA2DP_LHDCV5_ENCODER_PARAMS* p_encoder_params =
+      &a2dp_lhdc_encoder_cb.lhdc_encoder_params;
+
+  uint32_t lib_value = 0;
+  int32_t lib_ret = 0;
+
+  A2dpCodecConfig::debug_codec_dump(fd);
+
+  dprintf(fd,
+      "  Packet counts (expected/dropped)                        : %zu / "
+      "%zu\n",
+      (size_t)stats->media_read_total_expected_packets,
+      (size_t)stats->media_read_total_dropped_packets);
+
+  dprintf(fd,
+      "  PCM read counts (expected/actual)                       : %zu / "
+      "%zu\n",
+      (size_t)stats->media_read_total_expected_reads_count,
+      (size_t)stats->media_read_total_actual_reads_count);
+
+  dprintf(fd,
+      "  PCM read bytes (expected/actual)                        : %zu / "
+      "%zu\n",
+      (size_t)stats->media_read_total_expected_read_bytes,
+      (size_t)stats->media_read_total_actual_read_bytes);
+
+  dprintf(fd,
+      "  LHDC quality mode                                       : %s\n",
+      quality_mode_index_to_name(p_encoder_params->quality_mode_index).c_str());
+
+  lib_ret = lhdc_get_bitrate(a2dp_lhdc_encoder_cb.lhdc_handle, &lib_value);
+  if (lib_ret == LHDCV5_FRET_SUCCESS) {
+    dprintf(fd,
+        "  LHDC transmission bitrate (Kbps)                        :%d\n",
+        lib_value);
+  }
+
+  dprintf(fd,
+      "  LHDC saved transmit queue length                        : %zu\n",
+      (size_t)a2dp_lhdc_encoder_cb.TxQueueLength);
+}
+
diff --git a/system/stack/include/a2dp_constants.h b/system/stack/include/a2dp_constants.h
index 3bb957a5e7..b789aa1806 100644
--- a/system/stack/include/a2dp_constants.h
+++ b/system/stack/include/a2dp_constants.h
@@ -59,6 +59,8 @@ enum tA2DP_CODEC_ID : uint64_t {
   A2DP_CODEC_ID_APTX = 0x0001004fff,
   A2DP_CODEC_ID_APTX_HD = 0x002400d7ff,
   A2DP_CODEC_ID_LDAC = 0x00aa012dff,
+  A2DP_CODEC_ID_LHDCV3 = 0x334c3a05ff,
+  A2DP_CODEC_ID_LHDCV5 = 0x354c3a05ff,
   A2DP_CODEC_ID_OPUS = 0x000100e0ff,
 };
 
diff --git a/system/stack/include/a2dp_vendor_lhdc_constants.h b/system/stack/include/a2dp_vendor_lhdc_constants.h
new file mode 100755
index 0000000000..486ee999e6
--- /dev/null
+++ b/system/stack/include/a2dp_vendor_lhdc_constants.h
@@ -0,0 +1,308 @@
+/*
+ * Copyright (C) 2016 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+//
+// A2DP constants for LHDC codec
+//
+
+#ifndef A2DP_VENDOR_LHDC_CONSTANTS_H
+#define A2DP_VENDOR_LHDC_CONSTANTS_H
+#define A2DP_LHDC_SILENCE_LEVEL  1.0f
+#define A2DP_LHDC_VERSION_NUMBER    0x01
+#define A2DP_LHDC_VENDOR_CMD_MASK    0xC000
+#define A2DP_LHDC_VENDOR_FEATURE_MASK    (0xFF000000)
+
+// LHDC Quality Mode Index
+//LHDC not supported auto bit rate now.
+#define A2DP_LHDC_QUALITY_MAGIC_NUM 0x8000
+
+/* LHDC quality supporting bit rate */
+#define A2DP_LHDC_QUALITY_MASK   0xFF
+#define A2DP_LHDC_QUALITY_ABR    9     // ABR mode
+#define A2DP_LHDC_QUALITY_HIGH1  8     // 1000 (supported in LHDCV5+)
+#define A2DP_LHDC_QUALITY_HIGH   7     // 900
+#define A2DP_LHDC_QUALITY_MID    6     // 500
+#define A2DP_LHDC_QUALITY_LOW    5     // 400
+#define A2DP_LHDC_QUALITY_LOW4   4     // 320
+#define A2DP_LHDC_QUALITY_LOW3   3     // 256
+#define A2DP_LHDC_QUALITY_LOW2   2     // 192
+#define A2DP_LHDC_QUALITY_LOW1   1     // 128(LHDCV3) / 160(LHDCV5)
+#define A2DP_LHDC_QUALITY_LOW0   0     // 64
+
+// LHDC Peer Max/Min Target Bitrate
+#define A2DP_LHDC_PEER_MAX_BITRATE_MASK   (0xF00)
+#define A2DP_LHDC_PEER_MIN_BITRATE_MASK   (0xF0000)
+
+// LHDCV3/V4 peer min bitrate mode
+#define A2DP_LHDC_PEER_MIN_BITRATE_ON     (0x10000)
+
+// LHDCV3/V4 sub-type capabilities
+#define A2DP_LHDC_CAP_V4_LLAC_MASK        (0xF00000)
+#define A2DP_LHDC_CAP_V4_LLAC             (0x300000)
+#define A2DP_LHDC_CAP_V4_ONLY             (0x200000)
+#define A2DP_LHDC_CAP_LLAC_ONLY           (0x100000)
+#define A2DP_LHDC_CAP_V3_ONLY             (0x0)
+
+
+
+#define A2DP_LHDC_LATENCY_MAGIC_NUM 0xC000
+#define A2DP_LHDC_LL_ENABLE	  1	// LL enabled
+#define A2DP_LHDC_LL_DISABLE	0	// LL disabled
+
+#define A2DP_LHDC_LATENCY_LOW	0	// 50-100 ms
+#define A2DP_LHDC_LATENCY_MID	1	// default value, 150-200 ms
+#define A2DP_LHDC_LATENCY_HIGH	2	// 300-500 ms
+
+
+// Length of the LHDC Media Payload header
+#define A2DP_LHDC_MPL_HDR_LEN 2
+
+// LHDC Media Payload Header
+#define A2DP_LHDC_HDR_F_MSK 0x80
+#define A2DP_LHDC_HDR_S_MSK 0x40
+#define A2DP_LHDC_HDR_L_MSK 0x20
+
+#define A2DP_LHDCV3_HDR_NUM_MSK 0x0F
+#define A2DP_LHDCV2_HDR_NUM_MSK 0x7
+#define A2DP_LHDCV1_HDR_NUM_MSK 0x7
+#define A2DP_LHDC_HDR_NUM_SHIFT 2
+#define A2DP_LHDCV3_HDR_NUM_MAX 8
+#define A2DP_LHDCV2_HDR_NUM_MAX 7
+#define A2DP_LHDCV1_HDR_NUM_MAX 7
+
+#define A2DP_LHDC_HDR_LATENCY_LOW   0x00
+#define A2DP_LHDC_HDR_LATENCY_MID   0x01
+#define A2DP_LHDC_HDR_LATENCY_HIGH  0x02
+#define A2DP_LHDC_HDR_LATENCY_MSK   0x03
+
+// LHDC codec specific settings
+//#define A2DP_LHDCV3_CODEC_LEN 12
+#define A2DP_LHDCV3_CODEC_LEN 11
+#define A2DP_LHDCV2_CODEC_LEN 11
+#define A2DP_LHDCV1_CODEC_LEN 9
+#define A2DP_LHDC_LL_CODEC_LEN 9
+#define A2DP_LHDCV5_CODEC_LEN 13
+
+// [Octet 0-3] Vendor ID
+#define A2DP_LHDC_VENDOR_ID 0x0000053a
+// [Octet 4-5] Vendor Specific Codec ID
+#define A2DP_LHDCV2_CODEC_ID 0x4C32
+#define A2DP_LHDCV3_CODEC_ID 0x4C33
+#define A2DP_LHDCV1_CODEC_ID 0x484C
+#define A2DP_LHDCV1_LL_CODEC_ID 0x4C4C
+#define A2DP_LHDCV5_CODEC_ID 0x4C35
+
+// [Octet 6], [Bits 0-3] Sampling Frequency
+#define A2DP_LHDC_SAMPLING_FREQ_MASK 0x0F
+#define A2DP_LHDC_SAMPLING_FREQ_44100 0x08
+#define A2DP_LHDC_SAMPLING_FREQ_48000 0x04
+#define A2DP_LHDC_SAMPLING_FREQ_88200 0x02
+#define A2DP_LHDC_SAMPLING_FREQ_96000 0x01
+// [Octet 6], [Bits 3-4] Bit dipth
+#define A2DP_BAD_BITS_PER_SAMPLE    0xff
+#define A2DP_LHDC_BIT_FMT_MASK 	 0x30
+#define A2DP_LHDC_BIT_FMT_24	 0x10
+#define A2DP_LHDC_BIT_FMT_16	 0x20
+
+// [Octet 6], [Bits 6-7] Bit dipth
+#define A2DP_LHDC_FEATURE_AR		0x80
+#define A2DP_LHDC_FEATURE_JAS		0x40
+
+//[Octet 7:bit0..bit3]
+#define A2DP_LHDC_VERSION_MASK 0x0F
+//#define A2DP_LHDC_VERSION_2    0x01
+//#define A2DP_LHDC_VERSION_3    0x02
+//Supported version
+typedef enum {
+    A2DP_LHDC_VER2_BES  = 0,
+    A2DP_LHDC_VER2 = 1,
+    A2DP_LHDC_VER3 = 0x01,
+    A2DP_LHDC_VER4 = 0x02,
+    A2DP_LHDC_VER5 = 0x04,
+    A2DP_LHDC_VER6 = 0x08,
+    A2DP_LHDC_ERROR_VER,
+
+    A2DP_LHDC_LAST_SUPPORTED_VERSION = A2DP_LHDC_VER4,
+} A2DP_LHDC_VERSION;
+
+//[Octet 7:bit4..bit5]
+#define A2DP_LHDC_MAX_BIT_RATE_MASK       0x30
+#define A2DP_LHDC_MAX_BIT_RATE_900K       0x00
+#define A2DP_LHDC_MAX_BIT_RATE_500K       0x10		//500~600K
+#define A2DP_LHDC_MAX_BIT_RATE_400K       0x20
+//[Octet 7:bit6]
+#define A2DP_LHDC_LL_MASK             0x40
+#define A2DP_LHDC_LL_NONE             0x00
+#define A2DP_LHDC_LL_SUPPORTED        0x40
+
+//[Octet 7:bit7]
+#define A2DP_LHDC_FEATURE_LLAC		0x80
+
+//[Octet 8:bit0..bit3]
+#define A2DP_LHDC_CH_SPLIT_MSK        0x0f
+#define A2DP_LHDC_CH_SPLIT_NONE       0x01
+#define A2DP_LHDC_CH_SPLIT_TWS        0x02
+#define A2DP_LHDC_CH_SPLIT_TWS_PLUS   0x04
+
+//[Octet 8:bit4..bit7]
+#define A2DP_LHDC_FEATURE_META		0x10
+#define A2DP_LHDC_FEATURE_MIN_BR	0x20
+#define A2DP_LHDC_FEATURE_LARC		0x40
+#define A2DP_LHDC_FEATURE_LHDCV4	0x80
+
+//For LL used
+#define A2DP_LHDC_CHANNEL_SEPARATION  0x40
+
+
+//Only supported stereo
+#define A2DP_LHDC_CHANNEL_MODE_STEREO 0x03
+
+#define A2DP_LHDC_BITRATE_900K		0x01
+#define A2DP_LHDC_BITRATE_600K		0x02
+#define A2DP_LHDC_BITRATE_400K		0x04
+#define A2DP_LHDC_BITRATE_320K		0x08
+#define A2DP_LHDC_BITRATE_256K		0x10
+#define A2DP_LHDC_BITRATE_192K		0x20
+#define A2DP_LHDC_BITRATE_128K		0x40
+#define A2DP_LHDC_BITRATE_64K		0x80
+#define A2DP_LHDC_BITRATE_ALL		0xff
+
+
+#define A2DP_LHDC_FEATURE_MAGIC_NUM (0x4C000000)
+//LHDC Features: codec config specific field bitmap definition
+//specific2
+#define A2DP_LHDC_LL_ENABLED		0x1ULL
+//specific3
+#define A2DP_LHDC_JAS_ENABLED		0x1ULL
+#define A2DP_LHDC_AR_ENABLED		0x2ULL
+#define A2DP_LHDC_META_ENABLED		0x4ULL
+#define A2DP_LHDC_LLAC_ENABLED		0x8ULL
+#define A2DP_LHDC_MBR_ENABLED		0x10ULL
+#define A2DP_LHDC_LARC_ENABLED		0x20ULL
+#define A2DP_LHDC_V4_ENABLED		0x40ULL
+/* Define the ?th bit(from least significant bit) in the specific, sync with the bitmap definition
+ *  ex: A2DP_LHDC_AR_ENABLED = (2^A2DP_LHDC_AR_SPEC_BIT_POS)
+ * */
+//default in specific2
+#define A2DP_LHDC_LL_SPEC_BIT_POS        (0x0)
+//default in specific3
+#define A2DP_LHDC_JAS_SPEC_BIT_POS       (0x0)
+#define A2DP_LHDC_AR_SPEC_BIT_POS        (0x01)
+#define A2DP_LHDC_META_SPEC_BIT_POS      (0x02)
+#define A2DP_LHDC_LLAC_SPEC_BIT_POS      (0x03)
+#define A2DP_LHDC_MBR_SPEC_BIT_POS       (0x04)
+#define A2DP_LHDC_LARC_SPEC_BIT_POS      (0x05)
+#define A2DP_LHDC_V4_SPEC_BIT_POS        (0x06)
+
+/* bitmap for A2DP codec config selecting */
+#define A2DP_LHDC_TO_A2DP_CODEC_CONFIG_         0x1ULL      //codec_config_
+#define A2DP_LHDC_TO_A2DP_CODEC_CAP_            0x2ULL      //codec_capability_
+#define A2DP_LHDC_TO_A2DP_CODEC_LOCAL_CAP_      0x4ULL      //codec_local_capability_
+#define A2DP_LHDC_TO_A2DP_CODEC_SELECT_CAP_     0x8ULL      //codec_selectable_capability_
+#define A2DP_LHDC_TO_A2DP_CODEC_USER_           0x10ULL     //codec_user_config_
+#define A2DP_LHDC_TO_A2DP_CODEC_AUDIO_          0x20ULL     //codec_audio_config_
+
+#define SETUP_A2DP_SPEC(cfg, spec, has, value)  do{   \
+  if( spec == LHDC_EXTEND_FUNC_A2DP_SPECIFIC1_INDEX ) \
+    (has) ? (cfg->codec_specific_1 |= value) : (cfg->codec_specific_1 &= ~value);   \
+  if( spec == LHDC_EXTEND_FUNC_A2DP_SPECIFIC2_INDEX ) \
+    (has) ? (cfg->codec_specific_2 |= value) : (cfg->codec_specific_2 &= ~value);   \
+  if( spec == LHDC_EXTEND_FUNC_A2DP_SPECIFIC3_INDEX ) \
+    (has) ? (cfg->codec_specific_3 |= value) : (cfg->codec_specific_3 &= ~value);   \
+  if( spec == LHDC_EXTEND_FUNC_A2DP_SPECIFIC4_INDEX ) \
+    (has) ? (cfg->codec_specific_4 |= value) : (cfg->codec_specific_4 &= ~value);   \
+} while(0)
+
+#define CHECK_IN_A2DP_SPEC(cfg, spec, value)  do{   \
+  if( spec == LHDC_EXTEND_FUNC_A2DP_SPECIFIC1_INDEX ) \
+    return (cfg->codec_specific_1 & value);   \
+  if( spec == LHDC_EXTEND_FUNC_A2DP_SPECIFIC2_INDEX ) \
+    return (cfg->codec_specific_2 & value);   \
+  if( spec == LHDC_EXTEND_FUNC_A2DP_SPECIFIC3_INDEX ) \
+    return (cfg->codec_specific_3 & value);   \
+  if( spec == LHDC_EXTEND_FUNC_A2DP_SPECIFIC4_INDEX ) \
+    return (cfg->codec_specific_4 & value);   \
+  return false;   \
+} while(0)
+
+// TODO: return version macro to replace LHDC_CHECK_IN_A2DP_SPEC
+#define LHDCV3_CHECK_IN_A2DP_SPEC(cfg, spec, value)  ({ \
+  bool marco_ret = false; \
+  do{   \
+    if( spec == LHDC_EXTEND_FUNC_A2DP_SPECIFIC1_INDEX ) \
+      marco_ret = (cfg->codec_specific_1 & value);   \
+    if( spec == LHDC_EXTEND_FUNC_A2DP_SPECIFIC2_INDEX ) \
+      marco_ret = (cfg->codec_specific_2 & value);   \
+    if( spec == LHDC_EXTEND_FUNC_A2DP_SPECIFIC3_INDEX ) \
+      marco_ret = (cfg->codec_specific_3 & value);   \
+    if( spec == LHDC_EXTEND_FUNC_A2DP_SPECIFIC4_INDEX ) \
+      marco_ret = (cfg->codec_specific_4 & value);   \
+    } while(0);  \
+  marco_ret;   \
+})
+
+//
+// Savitech - LHDC aDSP configuration
+//
+// Lhdcv5Version: 1 << (below value-1)
+#define A2DP_OFFLOAD_LHDCV2_VER_1                   0x01
+#define A2DP_OFFLOAD_LHDCV3_V3_ONLY                 0x02
+#define A2DP_OFFLOAD_LHDCV3_V4_ONLY                 0x03
+#define A2DP_OFFLOAD_LHDCV3_LLAC                    0x04
+#define A2DP_OFFLOAD_LHDCV5_VER_1                   0x01
+
+// Lhdcv5QualityIndex
+#define A2DP_OFFLOAD_LHDC_QUALITY_LOW0            0x01
+#define A2DP_OFFLOAD_LHDC_QUALITY_LOW1            0x02
+#define A2DP_OFFLOAD_LHDC_QUALITY_LOW2            0x04
+#define A2DP_OFFLOAD_LHDC_QUALITY_LOW3            0x08
+#define A2DP_OFFLOAD_LHDC_QUALITY_LOW4            0x10
+#define A2DP_OFFLOAD_LHDC_QUALITY_LOW             0x20
+#define A2DP_OFFLOAD_LHDC_QUALITY_MID             0x40
+#define A2DP_OFFLOAD_LHDC_QUALITY_HIGH            0x80
+#define A2DP_OFFLOAD_LHDC_QUALITY_HIGH1           0x100
+#define A2DP_OFFLOAD_LHDC_QUALITY_ABR             0x8000
+
+// Lhdcv5FrameDuration
+#define A2DP_OFFLOAD_LHDC_FRAME_DURATION_5000US   0x01
+
+// Lhdcv5DataInterval
+#define A2DP_OFFLOAD_LHDC_DATA_INTERVAL_20MS      0x01
+#define A2DP_OFFLOAD_LHDC_DATA_INTERVAL_10MS      0x02
+
+// Lhdcv5Specific
+#define A2DP_OFFLOAD_LHDC_SPECIFIC_FEATURE_AR     0x01
+#define A2DP_OFFLOAD_LHDC_SPECIFIC_FEATURE_JAS    0x02
+#define A2DP_OFFLOAD_LHDC_SPECIFIC_FEATURE_META   0x04
+
+#define A2DP_OFFLOAD_LHDC_SPECIFIC_ACTION_AR_ON   0x01
+#define A2DP_OFFLOAD_LHDC_SPECIFIC_FEATURE_SPLIT  0x80
+
+// Lhdcv5Parameters
+#define A2DP_OFFLOAD_LHDC_CFG_VER                   6
+#define A2DP_OFFLOAD_LHDC_CFG_BITRATE_L             7
+#define A2DP_OFFLOAD_LHDC_CFG_BITRATE_H             8
+#define A2DP_OFFLOAD_LHDC_CFG_MAXBITRATE_L          9
+#define A2DP_OFFLOAD_LHDC_CFG_MAXBITRATE_H          10
+#define A2DP_OFFLOAD_LHDC_CFG_MINBITRATE_L          11
+#define A2DP_OFFLOAD_LHDC_CFG_MINBITRATE_H          12
+#define A2DP_OFFLOAD_LHDC_CFG_FRAMEDUR              13
+#define A2DP_OFFLOAD_LHDC_CFG_INTERVAL              14
+#define A2DP_OFFLOAD_LHDC_CFG_SPEC1                 15
+#define A2DP_OFFLOAD_LHDC_CFG_SPEC2                 16
+#define A2DP_OFFLOAD_LHDC_CFG_META                  17
+
+#endif  // A2DP_VENDOR_LHDC_CONSTANTS_H
diff --git a/system/stack/include/a2dp_vendor_lhdcv3.h b/system/stack/include/a2dp_vendor_lhdcv3.h
new file mode 100755
index 0000000000..6cd90d01a2
--- /dev/null
+++ b/system/stack/include/a2dp_vendor_lhdcv3.h
@@ -0,0 +1,324 @@
+/*
+ * Copyright (C) 2016 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+//
+// A2DP Codec API for LHDC
+//
+
+#ifndef A2DP_VENDOR_LHDCV3_H
+#define A2DP_VENDOR_LHDCV3_H
+
+#include "a2dp_codec_api.h"
+#include "a2dp_vendor_lhdc_constants.h"
+#include "avdt_api.h"
+
+#ifdef LOG_NDEBUG
+#undef LOG_NDEBUG
+#define LOG_NDEBUG 1	//set 0 to turn on VERBOSE LOG
+#endif
+
+/** Start of LHDC A2DP-Related API definition ***************************************/
+#define EXTEND_FUNC_CODE_GET_SPECIFIC                   ((unsigned int) 0x0A010001)
+#define EXTEND_FUNC_VER_GET_SPECIFIC_V1                 ((unsigned int) 0x01000000)
+#define EXTEND_FUNC_VER_GET_SPECIFIC_V2                 ((unsigned int) 0x02000000)
+#define LHDC_EXTEND_FUNC_CODE_A2DP_TYPE_MASK            (0x0A)
+#define LHDC_EXTEND_FUNC_CODE_LIB_TYPE_MASK             (0x0C)
+
+/* ************************************************************************
+ * Version info: EXTEND_FUNC_CODE_GET_SPECIFIC
+ * EXTEND_FUNC_VER_GET_SPECIFIC_V1:  Total Size: 41 bytes
+   * API Version:                   (4 bytes)
+   * API Code:                      (4 bytes)
+   * A2DP Codec Config Code:        (1 bytes)
+   * A2dp Specific1:                (8 bytes)
+   * A2dp Specific2:                (8 bytes)
+   * A2dp Specific3:                (8 bytes)
+   * A2dp Specific4:                (8 bytes)
+ * EXTEND_FUNC_VER_GET_SPECIFIC_V2:  Total Size: 64 bytes
+   * API Version:                   (4 bytes)
+   * API Code:                      (4 bytes)
+   * A2DP Codec Config Code:        (1 bytes)
+   * Reserved:                      (7 bytes)
+   * A2dp Specific1:                (8 bytes)
+   * A2dp Specific2:                (8 bytes)
+   * A2dp Specific3:                (8 bytes)
+   * A2dp Specific4:                (8 bytes)
+   * Capabilities Metadata sub fields:  (7*2 bytes)
+     * sub[0~1]:    JAS
+     * sub[2~3]:    AR
+     * sub[4~5]:    META
+     * sub[6~7]:    LLAC
+     * sub[8~9]:    MBR
+     * sub[10~11]:  LARC
+     * sub[12~13]:  LHDCV4
+   * Padded:                        (2 bytes)
+ * ************************************************************************/
+#define LHDC_EXTEND_FUNC_CONFIG_API_VERSION_SIZE        4       /* API version */
+#define LHDC_EXTEND_FUNC_CONFIG_API_CODE_SIZE           4       /* API index code */
+#define LHDC_EXTEND_FUNC_CONFIG_A2DPCFG_CODE_SIZE       1       /* A2DP codec config code */
+#define LHDC_EXTEND_FUNC_CONFIG_RESERVED_V2             7       /* V2 Reserved bytes */
+#define LHDC_EXTEND_FUNC_CONFIG_SPECIFIC1_SIZE          8       /* Specific 1 */
+#define LHDC_EXTEND_FUNC_CONFIG_SPECIFIC2_SIZE          8       /* Specific 2 */
+#define LHDC_EXTEND_FUNC_CONFIG_SPECIFIC3_SIZE          8       /* Specific 3 */
+#define LHDC_EXTEND_FUNC_CONFIG_SPECIFIC4_SIZE          8       /* Specific 4 */
+/* Capabilities metadata fields(2 bytes for each tuple) */
+#define LHDC_EXTEND_FUNC_CONFIG_CAPMETA_SIZE_V2         (7<<1)  /* V2 Capabilities */
+#define LHDC_EXTEND_FUNC_CONFIG_PADDED_SIZE_V2          2       /* V2 Padded Fields */
+
+/* Total size of buffer */
+#define LHDC_EXTEND_FUNC_CONFIG_TOTAL_FIXED_SIZE_V1    (LHDC_EXTEND_FUNC_CONFIG_API_VERSION_SIZE + \
+                                                          LHDC_EXTEND_FUNC_CONFIG_API_CODE_SIZE + \
+                                                          LHDC_EXTEND_FUNC_CONFIG_A2DPCFG_CODE_SIZE + \
+                                                          LHDC_EXTEND_FUNC_CONFIG_SPECIFIC1_SIZE + \
+                                                          LHDC_EXTEND_FUNC_CONFIG_SPECIFIC2_SIZE + \
+                                                          LHDC_EXTEND_FUNC_CONFIG_SPECIFIC3_SIZE + \
+                                                          LHDC_EXTEND_FUNC_CONFIG_SPECIFIC4_SIZE)
+#define LHDC_EXTEND_FUNC_CONFIG_TOTAL_FIXED_SIZE_V2    (LHDC_EXTEND_FUNC_CONFIG_API_VERSION_SIZE + \
+                                                          LHDC_EXTEND_FUNC_CONFIG_API_CODE_SIZE + \
+                                                          LHDC_EXTEND_FUNC_CONFIG_A2DPCFG_CODE_SIZE + \
+                                                          LHDC_EXTEND_FUNC_CONFIG_RESERVED_V2 + \
+                                                          LHDC_EXTEND_FUNC_CONFIG_SPECIFIC1_SIZE + \
+                                                          LHDC_EXTEND_FUNC_CONFIG_SPECIFIC2_SIZE + \
+                                                          LHDC_EXTEND_FUNC_CONFIG_SPECIFIC3_SIZE + \
+                                                          LHDC_EXTEND_FUNC_CONFIG_SPECIFIC4_SIZE + \
+                                                          LHDC_EXTEND_FUNC_CONFIG_CAPMETA_SIZE_V2 + \
+                                                          LHDC_EXTEND_FUNC_CONFIG_PADDED_SIZE_V2)
+/* Head of each field */
+#define LHDC_EXTEND_FUNC_CONFIG_API_VERSION_HEAD        (0)
+#define LHDC_EXTEND_FUNC_CONFIG_API_CODE_HEAD           (LHDC_EXTEND_FUNC_CONFIG_API_VERSION_HEAD + 4)  //4
+#define LHDC_EXTEND_FUNC_CONFIG_A2DPCFG_CODE_HEAD       (LHDC_EXTEND_FUNC_CONFIG_API_CODE_HEAD + 4)     //8
+/* Following part in V1 */
+#define LHDC_EXTEND_FUNC_A2DP_SPECIFICS1_HEAD_V1        (LHDC_EXTEND_FUNC_CONFIG_A2DPCFG_CODE_HEAD + 1) //9~16
+#define LHDC_EXTEND_FUNC_A2DP_SPECIFICS2_HEAD_V1        (LHDC_EXTEND_FUNC_A2DP_SPECIFICS1_HEAD_V1 + 8)  //17~24
+#define LHDC_EXTEND_FUNC_A2DP_SPECIFICS3_HEAD_V1        (LHDC_EXTEND_FUNC_A2DP_SPECIFICS2_HEAD_V1 + 8)  //25~32
+#define LHDC_EXTEND_FUNC_A2DP_SPECIFICS4_HEAD_V1        (LHDC_EXTEND_FUNC_A2DP_SPECIFICS3_HEAD_V1 + 8)  //33~40
+/* Following part in V2 */
+#define LHDC_EXTEND_FUNC_A2DP_RESERVED_HEAD_V2          (LHDC_EXTEND_FUNC_CONFIG_A2DPCFG_CODE_HEAD + 1) //9~15
+#define LHDC_EXTEND_FUNC_A2DP_SPECIFICS1_HEAD_V2        (LHDC_EXTEND_FUNC_CONFIG_A2DPCFG_CODE_HEAD + 8) //16~23
+#define LHDC_EXTEND_FUNC_A2DP_SPECIFICS2_HEAD_V2        (LHDC_EXTEND_FUNC_A2DP_SPECIFICS1_HEAD_V2 + 8)  //24~31
+#define LHDC_EXTEND_FUNC_A2DP_SPECIFICS3_HEAD_V2        (LHDC_EXTEND_FUNC_A2DP_SPECIFICS2_HEAD_V2 + 8)  //32~39
+#define LHDC_EXTEND_FUNC_A2DP_SPECIFICS4_HEAD_V2        (LHDC_EXTEND_FUNC_A2DP_SPECIFICS3_HEAD_V2 + 8)  //40~47
+#define LHDC_EXTEND_FUNC_A2DP_CAPMETA_HEAD_V2           (LHDC_EXTEND_FUNC_A2DP_SPECIFICS4_HEAD_V2 + 8)  //48~61
+#define LHDC_EXTEND_FUNC_A2DP_PADDED_HEAD_V2            (LHDC_EXTEND_FUNC_A2DP_CAPMETA_HEAD_V2 + LHDC_EXTEND_FUNC_CONFIG_CAPMETA_SIZE_V2)   //62~63
+
+
+/* code definition mapping to A2DP codec specific in a2dp_codec_api.h
+ * 0x01: codec_config_
+ * 0x02: codec_capability_
+ * 0x03: codec_local_capability_
+ * 0x04: codec_selectable_capability_
+ * 0x05: codec_user_config_
+ * 0x06: codec_audio_config_
+ */
+#define LHDC_EXTEND_FUNC_A2DP_TYPE_SPECIFICS_FINAL_CFG          (0x01)
+#define LHDC_EXTEND_FUNC_A2DP_TYPE_SPECIFICS_FINAL_CAP          (0x02)
+#define LHDC_EXTEND_FUNC_A2DP_TYPE_SPECIFICS_LOCAL_CAP          (0x03)
+#define LHDC_EXTEND_FUNC_A2DP_TYPE_SPECIFICS_SELECTABLE_CAP     (0x04)
+#define LHDC_EXTEND_FUNC_A2DP_TYPE_SPECIFICS_USER_CFG           (0x05)
+#define LHDC_EXTEND_FUNC_A2DP_TYPE_SPECIFICS_AUDIO_CFG          (0x06)
+
+
+/************************
+ * Capability Meta Format: (denotes where source capabilities bits are stored in specifics)
+   * Capability Code:                   (1 byte)
+   * Saving Position Info:              (1 byte)
+ ************************/
+/* Capabilities's code: */
+#define LHDC_EXTEND_FUNC_A2DP_LHDC_JAS_CODE      (0x01)
+#define LHDC_EXTEND_FUNC_A2DP_LHDC_AR_CODE       (0x02)
+#define LHDC_EXTEND_FUNC_A2DP_LHDC_META_CODE     (0x03)
+#define LHDC_EXTEND_FUNC_A2DP_LHDC_LLAC_CODE     (0x04)
+#define LHDC_EXTEND_FUNC_A2DP_LHDC_MBR_CODE      (0x05)
+#define LHDC_EXTEND_FUNC_A2DP_LHDC_LARC_CODE     (0x06)
+#define LHDC_EXTEND_FUNC_A2DP_LHDC_V4_CODE       (0x07)
+
+/* Capabilities's saving position Info:
+ *  1. in which specific                        (represented in leftmost 2-bits)
+ *  2. at which bit position of the specific    (represented in rightmost 6-bits)
+ * */
+#define LHDC_EXTEND_FUNC_A2DP_SPECIFIC1_INDEX    (0x00)     //2-bit:00
+#define LHDC_EXTEND_FUNC_A2DP_SPECIFIC2_INDEX    (0x40)     //2-bit:01
+#define LHDC_EXTEND_FUNC_A2DP_SPECIFIC3_INDEX    (0x80)     //2-bit:10
+#define LHDC_EXTEND_FUNC_A2DP_SPECIFIC4_INDEX    (0xC0)     //2-bit:11
+/** End of LHDC A2DP-Related API definition ***************************************/
+
+
+class A2dpCodecConfigLhdcV3 : public A2dpCodecConfig {
+ public:
+  bool copySinkCapability(uint8_t * codec_info);
+  A2dpCodecConfigLhdcV3(btav_a2dp_codec_priority_t codec_priority);
+  virtual ~A2dpCodecConfigLhdcV3();
+
+  bool init() override;
+  //uint64_t encoderIntervalMs() const override;
+  //int getEffectiveMtu() const override;
+  tA2DP_STATUS setCodecConfig(const uint8_t* p_peer_codec_info, bool is_capability,
+                      uint8_t* p_result_codec_config) override;
+  bool setPeerCodecCapabilities(
+      const uint8_t* p_peer_codec_capabilities) override;
+ private:
+  bool useRtpHeaderMarkerBit() const override;
+  /*
+  bool updateEncoderUserConfig(
+      const tA2DP_ENCODER_INIT_PEER_PARAMS* p_peer_params,
+      bool* p_restart_input, bool* p_restart_output,
+      bool* p_config_updated) override;
+      */
+  void debug_codec_dump(int fd) override;
+};
+
+bool A2DP_VendorGetLowLatencyEnabledLhdcV3();
+// Checks whether the codec capabilities contain a valid A2DP LHDC Source
+// codec.
+// NOTE: only codecs that are implemented are considered valid.
+// Returns true if |p_codec_info| contains information about a valid LHDC
+// codec, otherwise false.
+bool A2DP_IsVendorSourceCodecValidLhdcV3(const uint8_t* p_codec_info);
+
+// Checks whether the codec capabilities contain a valid peer A2DP LHDC Sink
+// codec.
+// NOTE: only codecs that are implemented are considered valid.
+// Returns true if |p_codec_info| contains information about a valid LHDC
+// codec, otherwise false.
+bool A2DP_IsVendorPeerSinkCodecValidLhdcV3(const uint8_t* p_codec_info);
+
+// Checks whether the A2DP data packets should contain RTP header.
+// |content_protection_enabled| is true if Content Protection is
+// enabled. |p_codec_info| contains information about the codec capabilities.
+// Returns true if the A2DP data packets should contain RTP header, otherwise
+// false.
+bool A2DP_VendorUsesRtpHeaderLhdcV3(bool content_protection_enabled,
+                                  const uint8_t* p_codec_info);
+
+// Gets the A2DP LHDC codec name for a given |p_codec_info|.
+const char* A2DP_VendorCodecNameLhdcV3(const uint8_t* p_codec_info);
+
+// Checks whether two A2DP LHDC codecs |p_codec_info_a| and |p_codec_info_b|
+// have the same type.
+// Returns true if the two codecs have the same type, otherwise false.
+bool A2DP_VendorCodecTypeEqualsLhdcV3(const uint8_t* p_codec_info_a,
+                                    const uint8_t* p_codec_info_b);
+
+// Checks whether two A2DP LHDC codecs |p_codec_info_a| and |p_codec_info_b|
+// are exactly the same.
+// Returns true if the two codecs are exactly the same, otherwise false.
+// If the codec type is not LHDC, the return value is false.
+bool A2DP_VendorCodecEqualsLhdcV3(const uint8_t* p_codec_info_a,
+                                const uint8_t* p_codec_info_b);
+
+// Gets the track sample rate value for the A2DP LHDC codec.
+// |p_codec_info| is a pointer to the LHDC codec_info to decode.
+// Returns the track sample rate on success, or -1 if |p_codec_info|
+// contains invalid codec information.
+int A2DP_VendorGetTrackSampleRateLhdcV3(const uint8_t* p_codec_info);
+
+// Gets the bits per audio sample for the A2DP LHDC codec.
+// |p_codec_info| is a pointer to the LHDC codec_info to decode.
+// Returns the bits per audio sample on success, or -1 if |p_codec_info|
+// contains invalid codec information.
+int A2DP_VendorGetTrackBitsPerSampleLhdcV3(const uint8_t* p_codec_info);
+
+// Gets the channel count for the A2DP LHDC codec.
+// |p_codec_info| is a pointer to the LHDC codec_info to decode.
+// Returns the channel count on success, or -1 if |p_codec_info|
+// contains invalid codec information.
+int A2DP_VendorGetTrackChannelCountLhdcV3(const uint8_t* p_codec_info);
+
+// Gets the channel mode code for the A2DP LHDC codec.
+// The actual value is codec-specific - see |A2DP_LHDC_CHANNEL_MODE_*|.
+// |p_codec_info| is a pointer to the LHDC codec_info to decode.
+// Returns the channel mode code on success, or -1 if |p_codec_info|
+// contains invalid codec information.
+int A2DP_VendorGetChannelModeCodeLhdcV3(const uint8_t* p_codec_info);
+
+// Gets the A2DP LHDC audio data timestamp from an audio packet.
+// |p_codec_info| contains the codec information.
+// |p_data| contains the audio data.
+// The timestamp is stored in |p_timestamp|.
+// Returns true on success, otherwise false.
+bool A2DP_VendorGetPacketTimestampLhdcV3(const uint8_t* p_codec_info,
+                                       const uint8_t* p_data,
+                                       uint32_t* p_timestamp);
+
+// Builds A2DP LHDC codec header for audio data.
+// |p_codec_info| contains the codec information.
+// |p_buf| contains the audio data.
+// |frames_per_packet| is the number of frames in this packet.
+// Returns true on success, otherwise false.
+bool A2DP_VendorBuildCodecHeaderLhdcV3(const uint8_t* p_codec_info, BT_HDR* p_buf,
+                                     uint16_t frames_per_packet);
+
+// Decodes A2DP LHDC codec info into a human readable string.
+// |p_codec_info| is a pointer to the LHDC codec_info to decode.
+// Returns a string describing the codec information.
+std::string A2DP_VendorCodecInfoStringLhdcV3(const uint8_t* p_codec_info);
+
+// New feature to check codec info is supported Channel Separation.
+int8_t A2DP_VendorGetChannelSplitModeLhdcV3(const uint8_t* p_codec_info);
+
+bool A2DP_VendorGetLowLatencyStateLhdcV3(const uint8_t* p_codec_info);
+int16_t A2DP_VendorGetMaxDatarateLhdcV3(const uint8_t* p_codec_info);
+uint8_t A2DP_VendorGetVersionLhdcV3(const uint8_t* p_codec_info);
+
+bool A2DP_VendorHasV4FlagLhdcV3(const uint8_t* p_codec_info);
+bool A2DP_VendorHasLLACFlagLhdcV3(const uint8_t* p_codec_info);
+
+bool A2DP_VendorHasJASFlagLhdcV3(const uint8_t* p_codec_info);
+bool A2DP_VendorHasARFlagLhdcV3(const uint8_t* p_codec_info);
+bool A2DP_VendorHasMETAFlagLhdcV3(const uint8_t* p_codec_info);
+bool A2DP_VendorHasMinBRFlagLhdcV3(const uint8_t* p_codec_info);
+bool A2DP_VendorHasLARCFlagLhdcV3(const uint8_t* p_codec_info);
+
+// Decodes and displays LHDC codec info (for debugging).
+// |p_codec_info| is a pointer to the LHDC codec_info to decode and display.
+void A2DP_VendorDumpCodecInfoLhdcV3(const uint8_t* p_codec_info);
+
+// Gets the A2DP LHDC encoder interface that can be used to encode and prepare
+// A2DP packets for transmission - see |tA2DP_ENCODER_INTERFACE|.
+// |p_codec_info| contains the codec information.
+// Returns the A2DP LHDC encoder interface if the |p_codec_info| is valid and
+// supported, otherwise NULL.
+const tA2DP_ENCODER_INTERFACE* A2DP_VendorGetEncoderInterfaceLhdcV3(
+    const uint8_t* p_codec_info);
+
+// Adjusts the A2DP LHDC codec, based on local support and Bluetooth
+// specification.
+// |p_codec_info| contains the codec information to adjust.
+// Returns true if |p_codec_info| is valid and supported, otherwise false.
+bool A2DP_VendorAdjustCodecLhdcV3(uint8_t* p_codec_info);
+
+// Gets the A2DP LHDC Source codec index for a given |p_codec_info|.
+// Returns the corresponding |btav_a2dp_codec_index_t| on success,
+// otherwise |BTAV_A2DP_CODEC_INDEX_MAX|.
+btav_a2dp_codec_index_t A2DP_VendorSourceCodecIndexLhdcV3(
+    const uint8_t* p_codec_info);
+
+// Gets the A2DP LHDC Source codec name.
+const char* A2DP_VendorCodecIndexStrLhdcV3(void);
+
+// Initializes A2DP LHDC Source codec information into |tAVDT_CFG|
+// configuration entry pointed by |p_cfg|.
+bool A2DP_VendorInitCodecConfigLhdcV3(AvdtpSepConfig* p_cfg);
+
+bool A2DP_VendorGetSrcCapVectorLhdcv3(uint8_t* capVector);
+
+// Gets the track bitrate value for the A2DP LHDCV3 codec.
+// |p_codec_info| is a pointer to the LHDC codec_info to decode.
+// Returns the track bit rate on success, or -1 if |p_codec_info|
+// contains invalid codec information.
+int A2DP_VendorGetBitRateLhdcV3(const uint8_t* p_codec_info);
+
+#endif  // A2DP_VENDOR_LHDCV3_H
diff --git a/system/stack/include/a2dp_vendor_lhdcv3_dec.h b/system/stack/include/a2dp_vendor_lhdcv3_dec.h
new file mode 100755
index 0000000000..adec89261d
--- /dev/null
+++ b/system/stack/include/a2dp_vendor_lhdcv3_dec.h
@@ -0,0 +1,192 @@
+/*
+ * Copyright 2016 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+//
+// A2DP Codec API for low complexity subband codec (SBC)
+//
+
+#ifndef A2DP_VENDOR_LHDCV3_DEC_H
+#define A2DP_VENDOR_LHDCV3_DEC_H
+
+#include "a2dp_codec_api.h"
+#include "a2dp_vendor_lhdc_constants.h"
+#include "avdt_api.h"
+
+#define IS_SRC  (true)
+#define IS_SNK  (false)
+
+class A2dpCodecConfigLhdcV3Base : public A2dpCodecConfig {
+ protected:
+  A2dpCodecConfigLhdcV3Base(btav_a2dp_codec_index_t codec_index,
+                         const std::string& name,
+                         btav_a2dp_codec_priority_t codec_priority,
+                         bool is_source)
+      : A2dpCodecConfig(codec_index, A2DP_CODEC_ID_LHDCV3, name, codec_priority),
+        is_source_(is_source) {}
+  tA2DP_STATUS setCodecConfig(const uint8_t* p_peer_codec_info, bool is_capability,
+                      uint8_t* p_result_codec_config) override;
+  bool setPeerCodecCapabilities(
+      const uint8_t* p_peer_codec_capabilities) override;
+
+ private:
+  bool is_source_;  // True if local is Source
+};
+
+
+class A2dpCodecConfigLhdcV3Sink : public A2dpCodecConfigLhdcV3Base {
+ public:
+  A2dpCodecConfigLhdcV3Sink(btav_a2dp_codec_priority_t codec_priority);
+  virtual ~A2dpCodecConfigLhdcV3Sink();
+
+  bool init() override;
+  //uint64_t encoderIntervalMs() const override;
+  //int getEffectiveMtu() const override;
+//  bool setCodecConfig(const uint8_t* p_peer_codec_info, bool is_capability,
+//                      uint8_t* p_result_codec_config) override;
+//  bool setPeerCodecCapabilities(
+//      const uint8_t* p_peer_codec_capabilities) override;
+
+ private:
+  bool useRtpHeaderMarkerBit() const override;
+  /*
+  bool updateEncoderUserConfig(
+      const tA2DP_ENCODER_INIT_PEER_PARAMS* p_peer_params,
+      bool* p_restart_input, bool* p_restart_output,
+      bool* p_config_updated) override;
+      */
+};
+
+
+// Checks whether the codec capabilities contain a valid A2DP LHDC V3 Sink codec.
+// NOTE: only codecs that are implemented are considered valid.
+// Returns true if |p_codec_info| contains information about a valid SBC codec,
+// otherwise false.
+bool A2DP_IsVendorSinkCodecValidLhdcV3(const uint8_t* p_codec_info);
+
+// Checks whether the codec capabilities contain a valid peer A2DP SBC Source
+// codec.
+// NOTE: only codecs that are implemented are considered valid.
+// Returns true if |p_codec_info| contains information about a valid SBC codec,
+// otherwise false.
+bool A2DP_IsVendorPeerSourceCodecValidLhdcV3(const uint8_t* p_codec_info);
+
+// Checks whether A2DP SBC Sink codec is supported.
+// |p_codec_info| contains information about the codec capabilities.
+// Returns true if the A2DP SBC Sink codec is supported, otherwise false.
+tA2DP_STATUS A2DP_IsVendorSinkCodecSupportedLhdcV3(const uint8_t* p_codec_info);
+
+// Checks whether an A2DP SBC Source codec for a peer Source device is
+// supported.
+// |p_codec_info| contains information about the codec capabilities of the
+// peer device.
+// Returns true if the A2DP SBC Source codec for a peer Source device is
+// supported, otherwise false.
+bool A2DP_IsPeerSourceCodecSupportedLhdcV3(const uint8_t* p_codec_info);
+
+// Initialize state with the default A2DP SBC codec.
+// The initialized state with the codec capabilities is stored in
+// |p_codec_info|.
+void A2DP_InitDefaultCodecLhdcV3Sink(uint8_t* p_codec_info);
+
+// Gets the A2DP SBC codec name for a given |p_codec_info|.
+const char* A2DP_VendorCodecNameLhdcV3Sink(const uint8_t* p_codec_info);
+
+// Checks whether two A2DP SBC codecs |p_codec_info_a| and |p_codec_info_b|
+// have the same type.
+// Returns true if the two codecs have the same type, otherwise false.
+bool A2DP_VendorCodecTypeEqualsLhdcV3Sink(const uint8_t* p_codec_info_a,
+                             const uint8_t* p_codec_info_b);
+
+// Checks whether two A2DP SBC codecs |p_codec_info_a| and |p_codec_info_b|
+// are exactly the same.
+// Returns true if the two codecs are exactly the same, otherwise false.
+// If the codec type is not SBC, the return value is false.
+bool A2DP_VendorCodecEqualsLhdcV3Sink(const uint8_t* p_codec_info_a,
+                         const uint8_t* p_codec_info_b);
+
+// Gets the track sample rate value for the A2DP SBC codec.
+// |p_codec_info| is a pointer to the SBC codec_info to decode.
+// Returns the track sample rate on success, or -1 if |p_codec_info|
+// contains invalid codec information.
+int A2DP_VendorGetTrackSampleRateLhdcV3Sink(const uint8_t* p_codec_info);
+
+// Gets the channel mode code for the A2DP SBC codec.
+// The actual value is codec-specific - see |A2DP_SBC_IE_CH_MD_*|.
+// |p_codec_info| is a pointer to the SBC codec_info to decode.
+// Returns the channel mode code on success, or -1 if |p_codec_info|
+// contains invalid codec information.
+int A2DP_VendorGetChannelModeCodeLhdcV3Sink(const uint8_t* p_codec_info);
+
+// Gets the channel type for the A2DP SBC Sink codec:
+// 1 for mono, or 3 for dual/stereo/joint.
+// |p_codec_info| is a pointer to the SBC codec_info to decode.
+// Returns the channel type on success, or -1 if |p_codec_info|
+// contains invalid codec information.
+int A2DP_VendorGetSinkTrackChannelTypeLhdcV3(const uint8_t* p_codec_info);
+
+// Gets the A2DP SBC audio data timestamp from an audio packet.
+// |p_codec_info| contains the codec information.
+// |p_data| contains the audio data.
+// The timestamp is stored in |p_timestamp|.
+// Returns true on success, otherwise false.
+bool A2DP_VendorGetPacketTimestampLhdcV3Sink(const uint8_t* p_codec_info,
+                                const uint8_t* p_data, uint32_t* p_timestamp);
+
+// Builds A2DP SBC codec header for audio data.
+// |p_codec_info| contains the codec information.
+// |p_buf| contains the audio data.
+// |frames_per_packet| is the number of frames in this packet.
+// Returns true on success, otherwise false.
+/*bool A2DP_VendorBuildCodecHeaderLhdcV3Sink(const uint8_t* p_codec_info, BT_HDR* p_buf,
+                              uint16_t frames_per_packet);
+*/
+// Decodes A2DP SBC codec info into a human readable string.
+// |p_codec_info| is a pointer to the SBC codec_info to decode.
+// Returns a string describing the codec information.
+std::string A2DP_VendorCodecInfoStringLhdcV3Sink(const uint8_t* p_codec_info);
+
+// Gets the A2DP SBC decoder interface that can be used to decode received A2DP
+// packets - see |tA2DP_DECODER_INTERFACE|.
+// |p_codec_info| contains the codec information.
+// Returns the A2DP SBC decoder interface if the |p_codec_info| is valid and
+// supported, otherwise NULL.
+const tA2DP_DECODER_INTERFACE* A2DP_VendorGetDecoderInterfaceLhdcV3(
+    const uint8_t* p_codec_info);
+
+// Adjusts the A2DP SBC codec, based on local support and Bluetooth
+// specification.
+// |p_codec_info| contains the codec information to adjust.
+// Returns true if |p_codec_info| is valid and supported, otherwise false.
+bool A2DP_VendorAdjustCodecLhdcV3Sink(uint8_t* p_codec_info);
+
+// Gets the A2DP SBC Source codec index for a given |p_codec_info|.
+// Returns the corresponding |btav_a2dp_codec_index_t| on success,
+// otherwise |BTAV_A2DP_CODEC_INDEX_MAX|.
+btav_a2dp_codec_index_t A2DP_SourceCodecIndexSbc(const uint8_t* p_codec_info);
+
+// Gets the A2DP SBC Sink codec index for a given |p_codec_info|.
+// Returns the corresponding |btav_a2dp_codec_index_t| on success,
+// otherwise |BTAV_A2DP_CODEC_INDEX_MAX|.
+btav_a2dp_codec_index_t A2DP_VendorSinkCodecIndexLhdcV3(const uint8_t* p_codec_info);
+
+// Gets the A2DP LHDC V3 Sink codec name.
+const char* A2DP_VendorCodecIndexStrLhdcV3Sink(void);
+
+// Initializes A2DP SBC Sink codec information into |AvdtpSepConfig|
+// configuration entry pointed by |p_cfg|.
+bool A2DP_VendorInitCodecConfigLhdcV3Sink(AvdtpSepConfig* p_cfg);
+
+#endif  // A2DP_VENDOR_LHDCV3_DEC_H
diff --git a/system/stack/include/a2dp_vendor_lhdcv3_decoder.h b/system/stack/include/a2dp_vendor_lhdcv3_decoder.h
new file mode 100755
index 0000000000..58b8f14370
--- /dev/null
+++ b/system/stack/include/a2dp_vendor_lhdcv3_decoder.h
@@ -0,0 +1,59 @@
+/*
+ * Copyright (C) 2016 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+//
+// Interface to the A2DP LHDC V3 Decoder
+//
+
+#ifndef A2DP_VENDOR_LHDCV3_DECODER_H
+#define A2DP_VENDOR_LHDCV3_DECODER_H
+
+#include "a2dp_codec_api.h"
+#include "a2dp_vendor_lhdc_constants.h"
+
+
+
+// Save CODEC information
+// Return true on success, otherwise false.
+bool save_codec_info (const uint8_t* p_codec_info);
+
+// Loads the A2DP LHDC V3 decoder.
+// Return true on success, otherwise false.
+bool A2DP_VendorLoadDecoderLhdcV3(void);
+
+// Unloads the A2DP LHDC V3 decoder.
+void A2DP_VendorUnloadDecoderLhdcV3(void);
+
+// Initialize the A2DP LHDC V3 decoder.
+bool a2dp_vendor_lhdcv3_decoder_init(decoded_data_callback_t decode_callback);
+
+// Cleanup the A2DP LHDC V3 decoder.
+void a2dp_vendor_lhdcv3_decoder_cleanup(void);
+
+// Decodes |p_buf|. Calls |decode_callback| passed into |a2dp_lhdcv3_decoder_init|
+// if decoded frames are available.
+bool a2dp_vendor_lhdcv3_decoder_decode_packet(BT_HDR* p_buf);
+
+// Start the A2DP LHDCV3 decoder.
+void a2dp_vendor_lhdcv3_decoder_start(void);
+
+// Suspend the A2DP LHDCV3 decoder.
+void a2dp_vendor_lhdcv3_decoder_suspend(void);
+
+// A2DP LHDCV3 decoder configuration.
+void a2dp_vendor_lhdcv3_decoder_configure(const uint8_t* p_codec_info);
+
+#endif  // A2DP_VENDOR_LHDCV3_DECODER_H
diff --git a/system/stack/include/a2dp_vendor_lhdcv3_encoder.h b/system/stack/include/a2dp_vendor_lhdcv3_encoder.h
new file mode 100755
index 0000000000..68c8d924e7
--- /dev/null
+++ b/system/stack/include/a2dp_vendor_lhdcv3_encoder.h
@@ -0,0 +1,77 @@
+/*
+ * Copyright (C) 2016 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+//
+// Interface to the A2DP LHDC Encoder
+//
+
+#ifndef A2DP_VENDOR_LHDCV3_ENCODER_H
+#define A2DP_VENDOR_LHDCV3_ENCODER_H
+
+#include "a2dp_codec_api.h"
+
+typedef enum {
+  BTAV_A2DP_CODEC_LHDC_CONFIG_NOTUSED = 0,
+  BTAV_A2DP_CODEC_LHDC_CONFIG_AR,
+  BTAV_A2DP_CODEC_LHDC_CONFIG_META,
+} btav_a2dp_codec_lhdc_ConfigCfg_t;
+
+typedef enum {
+  BTAV_A2DP_CODEC_LHDC_DATA_NOTUSED = 0,
+  BTAV_A2DP_CODEC_LHDC_DATA_GYRO_XY,
+} btav_a2dp_codec_lhdc_DataCfg_t;
+
+// Loads the A2DP LHDC encoder.
+// Return true on success, otherwise false.
+bool A2DP_VendorLoadEncoderLhdcV3(void);
+
+// Unloads the A2DP LHDC encoder.
+void A2DP_VendorUnloadEncoderLhdcV3(void);
+
+// Initialize the A2DP LHDC encoder.
+// |p_peer_params| contains the A2DP peer information
+// The current A2DP codec config is in |a2dp_codec_config|.
+// |read_callback| is the callback for reading the input audio data.
+// |enqueue_callback| is the callback for enqueueing the encoded audio data.
+void a2dp_vendor_lhdcv3_encoder_init(
+    const tA2DP_ENCODER_INIT_PEER_PARAMS* p_peer_params,
+    A2dpCodecConfig* a2dp_codec_config,
+    a2dp_source_read_callback_t read_callback,
+    a2dp_source_enqueue_callback_t enqueue_callback);
+
+// Cleanup the A2DP LHDC encoder.
+void a2dp_vendor_lhdcv3_encoder_cleanup(void);
+
+// Reset the feeding for the A2DP LHDC encoder.
+void a2dp_vendor_lhdcv3_feeding_reset(void);
+
+// Flush the feeding for the A2DP LHDC encoder.
+void a2dp_vendor_lhdcv3_feeding_flush(void);
+
+// Get the A2DP LHDC encoded maximum frame size
+int a2dp_vendor_lhdcv3_get_effective_frame_size();
+
+// Get the A2DP LHDC encoder interval (in milliseconds).
+uint64_t a2dp_vendor_lhdcv3_get_encoder_interval_ms(void);
+
+// Prepare and send A2DP LHDC encoded frames.
+// |timestamp_us| is the current timestamp (in microseconds).
+void a2dp_vendor_lhdcv3_send_frames(uint64_t timestamp_us);
+
+// Set transmit queue length for the A2DP LHDC ABR(Adaptive Bit Rate) mechanism.
+void a2dp_vendor_lhdcv3_set_transmit_queue_length(size_t transmit_queue_length);
+
+#endif  // A2DP_VENDOR_LHDCV3_ENCODER_H
diff --git a/system/stack/include/a2dp_vendor_lhdcv5.h b/system/stack/include/a2dp_vendor_lhdcv5.h
new file mode 100755
index 0000000000..bc27d8ea91
--- /dev/null
+++ b/system/stack/include/a2dp_vendor_lhdcv5.h
@@ -0,0 +1,291 @@
+/*
+ * Copyright (C) 2016 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+//
+// A2DP Codec API for LHDCV5
+//
+
+#ifndef A2DP_VENDOR_LHDCV5_H
+#define A2DP_VENDOR_LHDCV5_H
+
+#include "a2dp_codec_api.h"
+#include "a2dp_vendor_lhdc_constants.h"
+#include "a2dp_vendor_lhdcv5_constants.h"
+#include "avdt_api.h"
+
+/* lossless raw mode support */
+//#define LHDC_LOSSLESS_RAW_SUPPORT
+
+#define IS_SRC  (true)
+#define IS_SNK  (false)
+
+class A2dpCodecConfigLhdcV5Base : public A2dpCodecConfig {
+ protected:
+  	 A2dpCodecConfigLhdcV5Base(btav_a2dp_codec_index_t codec_index,
+                         const std::string& name,
+                         btav_a2dp_codec_priority_t codec_priority,
+                         bool is_source)
+      : A2dpCodecConfig(codec_index,  A2DP_CODEC_ID_LHDCV5, name, codec_priority),
+        is_source_(is_source) {}
+  tA2DP_STATUS setCodecConfig(const uint8_t* p_peer_codec_info, bool is_capability,
+                      uint8_t* p_result_codec_config) override;
+  bool setPeerCodecCapabilities(
+      const uint8_t* p_peer_codec_capabilities) override;
+
+ private:
+  bool is_source_;  // True if local is Source
+};
+
+class A2dpCodecConfigLhdcV5Source : public A2dpCodecConfigLhdcV5Base {
+ public:
+	A2dpCodecConfigLhdcV5Source(btav_a2dp_codec_priority_t codec_priority);
+	virtual ~A2dpCodecConfigLhdcV5Source();
+
+	bool init() override;
+	//uint64_t encoderIntervalMs() const override;
+	//int getEffectiveMtu() const override;
+
+ private:
+	bool useRtpHeaderMarkerBit() const override;
+	/*
+	bool updateEncoderUserConfig(
+		 const tA2DP_ENCODER_INIT_PEER_PARAMS* p_peer_params,
+		 bool* p_restart_input, bool* p_restart_output,
+		 bool* p_config_updated) override;
+		 */
+	void debug_codec_dump(int fd) override;
+};
+
+class A2dpCodecConfigLhdcV5Sink : public A2dpCodecConfigLhdcV5Base {
+public:
+ A2dpCodecConfigLhdcV5Sink(btav_a2dp_codec_priority_t codec_priority);
+ virtual ~A2dpCodecConfigLhdcV5Sink();
+
+ bool init() override;
+ //uint64_t encoderIntervalMs() const override;
+ //int getEffectiveMtu() const override;
+
+private:
+ bool useRtpHeaderMarkerBit() const override;
+ /*
+ bool updateEncoderUserConfig(
+		 const tA2DP_ENCODER_INIT_PEER_PARAMS* p_peer_params,
+		 bool* p_restart_input, bool* p_restart_output,
+		 bool* p_config_updated) override;
+		 */
+};
+
+bool A2DP_VendorGetLowLatencyEnabledLhdcV5();
+// Checks whether the codec capabilities contain a valid A2DP LHDC Source
+// codec.
+// NOTE: only codecs that are implemented are considered valid.
+// Returns true if |p_codec_info| contains information about a valid LHDC
+// codec, otherwise false.
+bool A2DP_IsVendorSourceCodecValidLhdcV5(const uint8_t* p_codec_info);
+
+// Checks whether the codec capabilities contain a valid peer A2DP LHDC Sink
+// codec.
+// NOTE: only codecs that are implemented are considered valid.
+// Returns true if |p_codec_info| contains information about a valid LHDC
+// codec, otherwise false.
+bool A2DP_IsVendorPeerSinkCodecValidLhdcV5(const uint8_t* p_codec_info);
+
+// Checks whether the A2DP data packets should contain RTP header.
+// |content_protection_enabled| is true if Content Protection is
+// enabled. |p_codec_info| contains information about the codec capabilities.
+// Returns true if the A2DP data packets should contain RTP header, otherwise
+// false.
+bool A2DP_VendorUsesRtpHeaderLhdcV5(bool content_protection_enabled,
+                                  const uint8_t* p_codec_info);
+
+// Gets the A2DP LHDC codec name for a given |p_codec_info|.
+const char* A2DP_VendorCodecNameLhdcV5(const uint8_t* p_codec_info);
+
+// Checks whether two A2DP LHDC codecs |p_codec_info_a| and |p_codec_info_b|
+// have the same type.
+// Returns true if the two codecs have the same type, otherwise false.
+bool A2DP_VendorCodecTypeEqualsLhdcV5(const uint8_t* p_codec_info_a,
+                                    const uint8_t* p_codec_info_b);
+
+// Checks whether two A2DP LHDC codecs |p_codec_info_a| and |p_codec_info_b|
+// are exactly the same.
+// Returns true if the two codecs are exactly the same, otherwise false.
+// If the codec type is not LHDC, the return value is false.
+bool A2DP_VendorCodecEqualsLhdcV5(const uint8_t* p_codec_info_a,
+                                const uint8_t* p_codec_info_b);
+
+// Gets the track sample rate value for the A2DP LHDC codec.
+// |p_codec_info| is a pointer to the LHDC codec_info to decode.
+// Returns the track sample rate on success, or -1 if |p_codec_info|
+// contains invalid codec information.
+int A2DP_VendorGetTrackSampleRateLhdcV5(const uint8_t* p_codec_info);
+
+// Gets the bits per audio sample for the A2DP LHDC codec.
+// |p_codec_info| is a pointer to the LHDC codec_info to decode.
+// Returns the bits per audio sample on success, or -1 if |p_codec_info|
+// contains invalid codec information.
+int A2DP_VendorGetTrackBitsPerSampleLhdcV5(const uint8_t* p_codec_info);
+
+// Gets the channel count for the A2DP LHDC codec.
+// |p_codec_info| is a pointer to the LHDC codec_info to decode.
+// Returns the channel count on success, or -1 if |p_codec_info|
+// contains invalid codec information.
+int A2DP_VendorGetTrackChannelCountLhdcV5(const uint8_t* p_codec_info);
+
+// Gets the channel mode code for the A2DP LHDC codec.
+// The actual value is codec-specific - see |A2DP_LHDC_CHANNEL_MODE_*|.
+// |p_codec_info| is a pointer to the LHDC codec_info to decode.
+// Returns the channel mode code on success, or -1 if |p_codec_info|
+// contains invalid codec information.
+int A2DP_VendorGetChannelModeCodeLhdcV5(const uint8_t* p_codec_info);
+
+// Gets the A2DP LHDC audio data timestamp from an audio packet.
+// |p_codec_info| contains the codec information.
+// |p_data| contains the audio data.
+// The timestamp is stored in |p_timestamp|.
+// Returns true on success, otherwise false.
+bool A2DP_VendorGetPacketTimestampLhdcV5(const uint8_t* p_codec_info,
+                                       const uint8_t* p_data,
+                                       uint32_t* p_timestamp);
+
+// Builds A2DP LHDC codec header for audio data.
+// |p_codec_info| contains the codec information.
+// |p_buf| contains the audio data.
+// |frames_per_packet| is the number of frames in this packet.
+// Returns true on success, otherwise false.
+bool A2DP_VendorBuildCodecHeaderLhdcV5(const uint8_t* p_codec_info, BT_HDR* p_buf,
+                                     uint16_t frames_per_packet);
+
+// Decodes A2DP LHDC codec info into a human readable string.
+// |p_codec_info| is a pointer to the LHDC codec_info to decode.
+// Returns a string describing the codec information.
+std::string A2DP_VendorCodecInfoStringLhdcV5(const uint8_t* p_codec_info);
+
+// Parse codec info and get the quality mode of the max target bit rate
+// |p_codec_info_| contains the codec information.
+// the translated quality mode from max target bit rate.
+// Returns true if successfully
+bool A2DP_VendorGetMaxBitRateLhdcV5(uint32_t *retval, const uint8_t* p_codec_info);
+bool A2DP_VendorGetMinBitRateLhdcV5(uint32_t *retval, const uint8_t* p_codec_info);
+
+bool A2DP_VendorGetVersionLhdcV5(uint32_t *retval, const uint8_t* p_codec_info);
+bool A2DP_VendorGetBitPerSampleLhdcV5(uint8_t *retval, const uint8_t* p_codec_info);
+
+bool A2DP_VendorHasJASFlagLhdcV5(uint8_t *retval, const uint8_t* p_codec_info);
+bool A2DP_VendorHasARFlagLhdcV5(uint8_t *retval, const uint8_t* p_codec_info);
+bool A2DP_VendorHasMETAFlagLhdcV5(uint8_t *retval, const uint8_t* p_codec_info);
+bool A2DP_VendorHasLLFlagLhdcV5(uint8_t *retval, const uint8_t* p_codec_info);
+bool A2DP_VendorHasLLessFlagLhdcV5(uint8_t *retval, const uint8_t* p_codec_info);
+bool A2DP_VendorHasLLessRawFlagLhdcV5(uint8_t *retval, const uint8_t* p_codec_info);
+
+// Decodes and displays LHDC codec info (for debugging).
+// |p_codec_info| is a pointer to the LHDC codec_info to decode and display.
+void A2DP_VendorDumpCodecInfoLhdcV5(const uint8_t* p_codec_info);
+
+// Gets the A2DP LHDC encoder interface that can be used to encode and prepare
+// A2DP packets for transmission - see |tA2DP_ENCODER_INTERFACE|.
+// |p_codec_info| contains the codec information.
+// Returns the A2DP LHDC encoder interface if the |p_codec_info| is valid and
+// supported, otherwise NULL.
+const tA2DP_ENCODER_INTERFACE* A2DP_VendorGetEncoderInterfaceLhdcV5(
+    const uint8_t* p_codec_info);
+
+// Adjusts the A2DP LHDC codec, based on local support and Bluetooth
+// specification.
+// |p_codec_info| contains the codec information to adjust.
+// Returns true if |p_codec_info| is valid and supported, otherwise false.
+bool A2DP_VendorAdjustCodecLhdcV5(uint8_t* p_codec_info);
+
+// Gets the A2DP LHDC Source codec index for a given |p_codec_info|.
+// Returns the corresponding |btav_a2dp_codec_index_t| on success,
+// otherwise |BTAV_A2DP_CODEC_INDEX_MAX|.
+btav_a2dp_codec_index_t A2DP_VendorSourceCodecIndexLhdcV5(
+    const uint8_t* p_codec_info);
+
+// Gets the A2DP LHDC Source codec name.
+const char* A2DP_VendorCodecIndexStrLhdcV5(void);
+
+// Initializes A2DP LHDC Source codec information into |tAVDT_CFG|
+// configuration entry pointed by |p_cfg|.
+bool A2DP_VendorInitCodecConfigLhdcV5(AvdtpSepConfig* p_cfg);
+
+bool A2DP_VendorGetSrcCapVectorLhdcV5(uint8_t* capVector);
+
+
+
+// Checks whether the codec capabilities contain a valid A2DP LHDC V3 Sink codec.
+// NOTE: only codecs that are implemented are considered valid.
+// Returns true if |p_codec_info| contains information about a valid SBC codec,
+// otherwise false.
+bool A2DP_IsVendorSinkCodecValidLhdcV5(const uint8_t* p_codec_info);
+
+// Checks whether the codec capabilities contain a valid peer A2DP SBC Source
+// codec.
+// NOTE: only codecs that are implemented are considered valid.
+// Returns true if |p_codec_info| contains information about a valid SBC codec,
+// otherwise false.
+bool A2DP_IsVendorPeerSourceCodecValidLhdcV5(const uint8_t* p_codec_info);
+
+// Checks whether A2DP SBC Sink codec is supported.
+// |p_codec_info| contains information about the codec capabilities.
+// Returns true if the A2DP SBC Sink codec is supported, otherwise false.
+tA2DP_STATUS A2DP_IsVendorSinkCodecSupportedLhdcV5(const uint8_t* p_codec_info);
+
+// Checks whether an A2DP SBC Source codec for a peer Source device is
+// supported.
+// |p_codec_info| contains information about the codec capabilities of the
+// peer device.
+// Returns true if the A2DP SBC Source codec for a peer Source device is
+// supported, otherwise false.
+bool A2DP_IsPeerSourceCodecSupportedLhdcV5(const uint8_t* p_codec_info);
+
+// Gets the A2DP SBC codec name for a given |p_codec_info|.
+const char* A2DP_VendorCodecNameLhdcV5Sink(const uint8_t* p_codec_info);
+
+// Gets the channel type for the A2DP SBC Sink codec:
+// 1 for mono, or 3 for dual/stereo/joint.
+// |p_codec_info| is a pointer to the SBC codec_info to decode.
+// Returns the channel type on success, or -1 if |p_codec_info|
+// contains invalid codec information.
+int A2DP_VendorGetSinkTrackChannelTypeLhdcV5(const uint8_t* p_codec_info);
+
+// Gets the A2DP SBC decoder interface that can be used to decode received A2DP
+// packets - see |tA2DP_DECODER_INTERFACE|.
+// |p_codec_info| contains the codec information.
+// Returns the A2DP SBC decoder interface if the |p_codec_info| is valid and
+// supported, otherwise NULL.
+const tA2DP_DECODER_INTERFACE* A2DP_VendorGetDecoderInterfaceLhdcV5(
+    const uint8_t* p_codec_info);
+
+// Gets the A2DP SBC Sink codec index for a given |p_codec_info|.
+// Returns the corresponding |btav_a2dp_codec_index_t| on success,
+// otherwise |BTAV_A2DP_CODEC_INDEX_MAX|.
+btav_a2dp_codec_index_t A2DP_VendorSinkCodecIndexLhdcV5(const uint8_t* p_codec_info);
+
+// Gets the A2DP LHDC V3 Sink codec name.
+const char* A2DP_VendorCodecIndexStrLhdcV5Sink(void);
+
+// Initializes A2DP SBC Sink codec information into |AvdtpSepConfig|
+// configuration entry pointed by |p_cfg|.
+bool A2DP_VendorInitCodecConfigLhdcV5Sink(AvdtpSepConfig* p_cfg);
+
+// Gets the track bitrate value for the A2DP LHDCV5 codec.
+// |p_codec_info| is a pointer to the LHDC codec_info to decode.
+// Returns the track bit rate on success, or -1 if |p_codec_info|
+// contains invalid codec information.
+int A2DP_VendorGetBitRateLhdcV5(const uint8_t* p_codec_info);
+
+#endif  // A2DP_VENDOR_LHDCV5_H
diff --git a/system/stack/include/a2dp_vendor_lhdcv5_constants.h b/system/stack/include/a2dp_vendor_lhdcv5_constants.h
new file mode 100755
index 0000000000..001234b0e7
--- /dev/null
+++ b/system/stack/include/a2dp_vendor_lhdcv5_constants.h
@@ -0,0 +1,258 @@
+/*
+ * Copyright (C) 2016 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+//
+// A2DP constants for LHDC codec
+//
+
+#ifndef A2DP_VENDOR_LHDCV5_CONSTANTS_H
+#define A2DP_VENDOR_LHDCV5_CONSTANTS_H
+
+////////////////////////////////////////////////////////////////////
+// LHDCV5 codec info (capabilities) format:
+// Total Length: A2DP_LHDCV5_CODEC_LEN + 1(losc)
+//  --------------------------------------------------------------------------------------
+//  H0   |    H1     |    H2     |  P0-P3   | P4-P5   |
+//  losc | mediaType | codecType | vendorId | codecId |
+//  --------------------------------------------------------------------------------------
+//  P6[5:0]     |
+//  Sample Rate |
+//  --------------------------------------------------------------------------------------
+//  P7[7:6]     | P7[5:4]     | P7[2:0]   |
+//  Min BitRate | Max BitRate | Bit Depth |
+//  --------------------------------------------------------------------------------------
+//  P8[4]       | P8[3:0]        |
+//  FrameLen5ms | Version Number |
+//  --------------------------------------------------------------------------------------
+//  P9[7]         | P9[6]       | P9[5]         | P9[4]         | P9[2] | P9[1] | P9[0] |
+//  Lossless48K   | Low Latency | Lossless24Bit | Lossless96K   | Meta  | JAS   | 3DAR  |
+//  --------------------------------------------------------------------------------------
+//  P10[7]         |
+//  LosslessRaw48K |
+//  --------------------------------------------------------------------------------------
+
+// P0-P3 Vendor ID: A2DP_LHDC_VENDOR_ID (0x0000053a)
+// P4-P5 Vendor Specific Codec ID: A2DP_LHDCV5_CODEC_ID (0x4C35)
+// P6[5:0] Sampling Frequency
+#define A2DP_LHDCV5_SAMPLING_FREQ_MASK    (0x35)
+#define A2DP_LHDCV5_SAMPLING_FREQ_44100   (0x20)
+#define A2DP_LHDCV5_SAMPLING_FREQ_48000   (0x10)
+#define A2DP_LHDCV5_SAMPLING_FREQ_96000   (0x04)
+#define A2DP_LHDCV5_SAMPLING_FREQ_192000  (0x01)
+#define A2DP_LHDCV5_SAMPLING_FREQ_NS      (0x00)
+
+// P7[2:0] Bit depth
+#define A2DP_LHDCV5_BIT_FMT_MASK  (0x07)
+#define A2DP_LHDCV5_BIT_FMT_16    (0x04)
+#define A2DP_LHDCV5_BIT_FMT_24    (0x02)
+#define A2DP_LHDCV5_BIT_FMT_32    (0x01)
+#define A2DP_LHDCV5_BIT_FMT_NS    (0x00)
+
+// P7[5:4] Max Bit Rate Type
+#define A2DP_LHDCV5_MAX_BIT_RATE_MASK   (0x30)
+#define A2DP_LHDCV5_MAX_BIT_RATE_900K   (0x30)
+#define A2DP_LHDCV5_MAX_BIT_RATE_500K   (0x20)
+#define A2DP_LHDCV5_MAX_BIT_RATE_400K   (0x10)
+#define A2DP_LHDCV5_MAX_BIT_RATE_1000K  (0x00)  //equivalent to no upper limit
+
+// P7[7:6] Min Bit Rate Type
+#define A2DP_LHDCV5_MIN_BIT_RATE_MASK   (0xC0)
+#define A2DP_LHDCV5_MIN_BIT_RATE_400K   (0xC0)
+#define A2DP_LHDCV5_MIN_BIT_RATE_256K   (0x80)
+#define A2DP_LHDCV5_MIN_BIT_RATE_160K   (0x40)
+#define A2DP_LHDCV5_MIN_BIT_RATE_64K    (0x00)  //equivalent to no lower limit
+
+// P8[3:0] Codec SubVersion (bitmap)
+#define A2DP_LHDCV5_VERSION_MASK    (0x0F)
+#define A2DP_LHDCV5_VER_1           (0x01)
+#define A2DP_LHDCV5_VER_NS          (0x00)
+
+// P8[5:4] Frame Length Type
+#define A2DP_LHDCV5_FRAME_LEN_MASK  (0x10)
+#define A2DP_LHDCV5_FRAME_LEN_5MS   (0x10)
+#define A2DP_LHDCV5_FRAME_LEN_NS    (0x00)
+
+// P9[0] 3DAR
+// P9[1] JAS
+// P9[2] Meta
+// P9[4] Lossless96K
+// P9[5] Lossless24Bit
+// P9[6] LowLatency
+// P9[7] Lossless48K
+#define A2DP_LHDCV5_FEATURE_MASK        (0xC7)
+#define A2DP_LHDCV5_FEATURE_LLESS48K    (0x80)
+#define A2DP_LHDCV5_FEATURE_LL          (0x40)
+#define A2DP_LHDCV5_FEATURE_LLESS24BIT  (0x20)
+#define A2DP_LHDCV5_FEATURE_LLESS96K    (0x10)
+#define A2DP_LHDCV5_FEATURE_META        (0x04)
+#define A2DP_LHDCV5_FEATURE_JAS         (0x02)
+#define A2DP_LHDCV5_FEATURE_AR          (0x01)
+
+// P10[7] LosslessRaw48K
+#define A2DP_LHDCV5_FEATURE_LLESS_RAW   (0x80)
+////////////////////////////////////////////////////////////////////
+
+////////////////////////////////////////////////////////////////////
+//  attributes which not in codec info format
+//    channel mode
+//    channel separation mode
+////////////////////////////////////////////////////////////////////
+// channel mode:
+#define A2DP_LHDCV5_CHANNEL_MODE_MASK   (0x07)
+#define A2DP_LHDCV5_CHANNEL_MODE_MONO   (0x04)
+#define A2DP_LHDCV5_CHANNEL_MODE_DUAL   (0x02)
+#define A2DP_LHDCV5_CHANNEL_MODE_STEREO (0x01)
+#define A2DP_LHDCV5_CHANNEL_MODE_NS     (0x00)
+////////////////////////////////////////////////////////////////////
+
+/************************************************
+ * LHDC Feature Capabilities on A2DP specifics:
+   * feature id:                          (1 byte)
+   * target specific index:               (2 bits)
+   * target bit index on a specific:      (decimal: 0~63)
+************************************************/
+#define A2DP_LHDCV5_FEATURE_MAGIC_NUM (0x5C000000)
+
+// feature code:
+#define LHDCV5_FEATURE_CODE_MASK     (0xFF)
+#define LHDCV5_FEATURE_CODE_NA       (0x00)
+#define LHDCV5_FEATURE_CODE_JAS      (0x01)
+#define LHDCV5_FEATURE_CODE_AR       (0x02)
+#define LHDCV5_FEATURE_CODE_META     (0x03)
+#define LHDCV5_FEATURE_CODE_LL       (0x08)
+#define LHDCV5_FEATURE_CODE_LLESS    (0x09)
+#define LHDCV5_FEATURE_CODE_LLESS_RAW (0x0A)
+
+// target specific index:
+#define LHDCV5_FEATURE_ON_A2DP_SPECIFIC_1    (0x00)     //2-bit:00
+#define LHDCV5_FEATURE_ON_A2DP_SPECIFIC_2    (0x40)     //2-bit:01
+#define LHDCV5_FEATURE_ON_A2DP_SPECIFIC_3    (0x80)     //2-bit:10
+#define LHDCV5_FEATURE_ON_A2DP_SPECIFIC_4    (0xC0)     //2-bit:11
+
+// target bit index on the specific:
+//  specific@1
+#define LHDCV5_FEATURE_QM_SPEC_BIT_POS        (0x00)
+//  specific@2
+#define LHDCV5_FEATURE_LL_SPEC_BIT_POS        (0x00)
+//  specific@3
+#define LHDCV5_FEATURE_JAS_SPEC_BIT_POS       (0x00)
+#define LHDCV5_FEATURE_AR_SPEC_BIT_POS        (0x01)
+#define LHDCV5_FEATURE_META_SPEC_BIT_POS      (0x02)
+#define LHDCV5_FEATURE_LLESS_SPEC_BIT_POS     (0x07)
+#define LHDCV5_FEATURE_LLESS_RAW_SPEC_BIT_POS (0x08)
+// Notice: the highest bit position is limited by A2DP_LHDC_FEATURE_MAGIC_NUM(0x4C000000)
+//  ie., available range in a specific: int64[24:0]
+#define LHDCV5_FEATURE_MAX_SPEC_BIT_POS       (0x19)
+
+#define LHDC_SETUP_A2DP_SPEC(cfg, spec, has, value)  do{   \
+  if( spec == LHDCV5_FEATURE_ON_A2DP_SPECIFIC_1 ) \
+    (has) ? (cfg->codec_specific_1 |= value) : (cfg->codec_specific_1 &= ~value);   \
+  if( spec == LHDCV5_FEATURE_ON_A2DP_SPECIFIC_2 ) \
+    (has) ? (cfg->codec_specific_2 |= value) : (cfg->codec_specific_2 &= ~value);   \
+  if( spec == LHDCV5_FEATURE_ON_A2DP_SPECIFIC_3 ) \
+    (has) ? (cfg->codec_specific_3 |= value) : (cfg->codec_specific_3 &= ~value);   \
+  if( spec == LHDCV5_FEATURE_ON_A2DP_SPECIFIC_4 ) \
+    (has) ? (cfg->codec_specific_4 |= value) : (cfg->codec_specific_4 &= ~value);   \
+} while(0)
+
+#define LHDCV5_CHECK_IN_A2DP_SPEC(cfg, spec, value)  ({ \
+  bool marco_ret = false; \
+  do{   \
+    if( spec == LHDCV5_FEATURE_ON_A2DP_SPECIFIC_1 ) \
+      marco_ret = (cfg->codec_specific_1 & value);   \
+    if( spec == LHDCV5_FEATURE_ON_A2DP_SPECIFIC_2 ) \
+      marco_ret = (cfg->codec_specific_2 & value);   \
+    if( spec == LHDCV5_FEATURE_ON_A2DP_SPECIFIC_3 ) \
+      marco_ret = (cfg->codec_specific_3 & value);   \
+    if( spec == LHDCV5_FEATURE_ON_A2DP_SPECIFIC_4 ) \
+      marco_ret = (cfg->codec_specific_4 & value);   \
+    } while(0);  \
+  marco_ret;   \
+})
+
+//
+// Savitech - LHDC Extended API Start
+//
+/* LHDC Extend API Category */
+// A2DP Type API: handled in bt stack
+#define LHDCV5_EXTEND_API_CODE_A2DP_TYPE            (0x0A)
+// Lib Type API: handled by codec lib
+#define LHDCV5_EXTEND_API_CODE_LIB_TYPE             (0x0C)
+
+#define LHDCV5_EXTEND_API_A2DP_SPEC_CODE_HEAD       (4)   /* position of API command code in buffer field */
+#define LHDCV5_EXTEND_API_A2DP_SPEC_ID_HEAD         (8)   /* position of codec config id in buffer field */
+
+//
+// A2DP Type API: Get info from A2DP codec config's specifics
+//
+#define LHDCV5_EXTEND_API_A2DP_SPEC_CODE      (0x0A010001)
+#define LHDCV5_EXTEND_API_A2DP_SPEC_VER2      (0x02000000)
+
+/* id for A2DP codec config
+ * 0x01: codec_config_
+ * 0x02: codec_capability_
+ * 0x03: codec_local_capability_
+ * 0x04: codec_selectable_capability_
+ * 0x05: codec_user_config_
+ * 0x06: codec_audio_config_
+ */
+#define LHDCV5_EXTEND_API_A2DP_SPEC_CFG                (0x01)
+#define LHDCV5_EXTEND_API_A2DP_SPEC_CAP                (0x02)
+#define LHDCV5_EXTEND_API_A2DP_SPEC_LOCAL_CAP          (0x03)
+#define LHDCV5_EXTEND_API_A2DP_SPEC_SELECT_CAP         (0x04)
+#define LHDCV5_EXTEND_API_A2DP_SPEC_USER_CFG           (0x05)
+#define LHDCV5_EXTEND_API_A2DP_SPEC_AUDIO_CFG          (0x06)
+/* ************************************************************************
+ * Fields in buffer for LHDCV5_EXTEND_API_VER_GET_SPECIFIC_V2
+ * total 64 bytes:
+   * API Version:                   (4 bytes)
+   * API Code:                      (4 bytes)
+   * A2DP Codec Config Id:          (1 bytes)
+   * Reserved:                      (7 bytes)
+   * A2dp Specific1:                (8 bytes)
+   * A2dp Specific2:                (8 bytes)
+   * A2dp Specific3:                (8 bytes)
+   * A2dp Specific4:                (8 bytes)
+   * Info fields:                   (5*2 bytes)
+     * [0~1]: AR
+     * [2~3]: JAS
+     * [4~5]: META
+     * [6~7]: Low Latency
+     * [8~9]: Loss Less
+   * Pad:                           (6 bytes)
+ * ************************************************************************/
+#define LHDCV5_EXTEND_API_A2DP_SPEC_VER_SIZE        4       /* API version */
+#define LHDCV5_EXTEND_API_A2DP_SPEC_CODE_SIZE       4       /* API index code */
+#define LHDCV5_EXTEND_API_A2DP_SPEC_CFGID_SIZE      1       /* A2DP codec config code */
+#define LHDCV5_EXTEND_API_A2DP_SPEC_RSVD_V2         7       /* Reserved bytes */
+#define LHDCV5_EXTEND_API_A2DP_SPEC_1_SIZE          8       /* Specific 1 */
+#define LHDCV5_EXTEND_API_A2DP_SPEC_2_SIZE          8       /* Specific 2 */
+#define LHDCV5_EXTEND_API_A2DP_SPEC_3_SIZE          8       /* Specific 3 */
+#define LHDCV5_EXTEND_API_A2DP_SPEC_4_SIZE          8       /* Specific 4 */
+#define LHDCV5_EXTEND_API_A2DP_SPEC_INFO_SIZE_V2    (5<<1)  /* Info fields */
+// total size of buffer fields (64)
+#define LHDCV5_EXTEND_API_A2DP_SPEC_TOTAL_SIZE_V2   (64)
+
+#define LHDCV5_EXTEND_API_A2DP_SPEC1_HEAD_V2        (16)
+#define LHDCV5_EXTEND_API_A2DP_SPEC2_HEAD_V2        (24)
+#define LHDCV5_EXTEND_API_A2DP_SPEC3_HEAD_V2        (32)
+#define LHDCV5_EXTEND_API_A2DP_SPEC4_HEAD_V2        (40)
+#define LHDCV5_EXTEND_API_A2DP_SPEC_INFO_HEAD_V2    (48)
+
+//
+// Savitech - LHDC Extended API End
+//
+#endif  // A2DP_VENDOR_LHDCV5_CONSTANTS_H
diff --git a/system/stack/include/a2dp_vendor_lhdcv5_decoder.h b/system/stack/include/a2dp_vendor_lhdcv5_decoder.h
new file mode 100755
index 0000000000..ba5be98257
--- /dev/null
+++ b/system/stack/include/a2dp_vendor_lhdcv5_decoder.h
@@ -0,0 +1,58 @@
+/*
+ * Copyright (C) 2022 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+//
+// Interface to the A2DP LHDC V5 Decoder
+//
+
+#ifndef A2DP_VENDOR_LHDCV5_DECODER_H
+#define A2DP_VENDOR_LHDCV5_DECODER_H
+
+#include "a2dp_codec_api.h"
+#include "a2dp_vendor_lhdc_constants.h"
+#include "a2dp_vendor_lhdcv5_constants.h"
+
+
+// Save CODEC information
+// Return true on success, otherwise false.
+bool a2dp_lhdcv5_decoder_save_codec_info (const uint8_t* p_codec_info);
+
+// Loads the A2DP LHDC V5 decoder.
+// Return true on success, otherwise false.
+bool A2DP_VendorLoadDecoderLhdcV5(void);
+
+// Unloads the A2DP LHDC V5 decoder.
+void A2DP_VendorUnloadDecoderLhdcV5(void);
+
+// Initialize the A2DP LHDC V5 decoder.
+bool a2dp_vendor_lhdcv5_decoder_init(decoded_data_callback_t decode_callback);
+
+// Cleanup the A2DP LHDC V5 decoder.
+void a2dp_vendor_lhdcv5_decoder_cleanup(void);
+
+// Decode LHDC V5 packet to PCM
+bool a2dp_vendor_lhdcv5_decoder_decode_packet(BT_HDR* p_buf);
+
+// Start the A2DP LHDC V5 decoder.
+void a2dp_vendor_lhdcv5_decoder_start(void);
+
+// Suspend the A2DP LHDC V5 decoder.
+void a2dp_vendor_lhdcv5_decoder_suspend(void);
+
+// A2DP LHDC V5 decoder configuration.
+void a2dp_vendor_lhdcv5_decoder_configure(const uint8_t* p_codec_info);
+
+#endif  // A2DP_VENDOR_LHDCV5_DECODER_H
diff --git a/system/stack/include/a2dp_vendor_lhdcv5_encoder.h b/system/stack/include/a2dp_vendor_lhdcv5_encoder.h
new file mode 100755
index 0000000000..0e9dddf597
--- /dev/null
+++ b/system/stack/include/a2dp_vendor_lhdcv5_encoder.h
@@ -0,0 +1,66 @@
+/*
+ * Copyright (C) 2016 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+//
+// Interface to the A2DP LHDC Encoder
+//
+
+#ifndef A2DP_VENDOR_LHDCV5_ENCODER_H
+#define A2DP_VENDOR_LHDCV5_ENCODER_H
+
+#include "a2dp_codec_api.h"
+
+// Loads the A2DP LHDC encoder.
+// Return true on success, otherwise false.
+bool A2DP_VendorLoadEncoderLhdcV5(void);
+
+// Unloads the A2DP LHDC encoder.
+bool A2DP_VendorUnloadEncoderLhdcV5(void);
+
+// Initialize the A2DP LHDC encoder.
+// |p_peer_params| contains the A2DP peer information
+// The current A2DP codec config is in |a2dp_codec_config|.
+// |read_callback| is the callback for reading the input audio data.
+// |enqueue_callback| is the callback for enqueueing the encoded audio data.
+void a2dp_vendor_lhdcv5_encoder_init(
+    const tA2DP_ENCODER_INIT_PEER_PARAMS* p_peer_params,
+    A2dpCodecConfig* a2dp_codec_config,
+    a2dp_source_read_callback_t read_callback,
+    a2dp_source_enqueue_callback_t enqueue_callback);
+
+// Cleanup the A2DP LHDC encoder.
+void a2dp_vendor_lhdcv5_encoder_cleanup(void);
+
+// Reset the feeding for the A2DP LHDC encoder.
+void a2dp_vendor_lhdcv5_feeding_reset(void);
+
+// Flush the feeding for the A2DP LHDC encoder.
+void a2dp_vendor_lhdcv5_feeding_flush(void);
+
+// Get the A2DP LHDC encoded maximum frame size
+int a2dp_vendor_lhdcv5_get_effective_frame_size();
+
+// Get the A2DP LHDC encoder interval (in milliseconds).
+uint64_t a2dp_vendor_lhdcv5_get_encoder_interval_ms(void);
+
+// Prepare and send A2DP LHDC encoded frames.
+// |timestamp_us| is the current timestamp (in microseconds).
+void a2dp_vendor_lhdcv5_send_frames(uint64_t timestamp_us);
+
+// Set transmit queue length for the A2DP LHDC ABR(Adaptive Bit Rate) mechanism.
+void a2dp_vendor_lhdcv5_set_transmit_queue_length(size_t transmit_queue_length);
+
+#endif  // A2DP_VENDOR_LHDCV5_ENCODER_H
-- 
2.43.0

